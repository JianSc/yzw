###############################################################################
#
# IAR C/C++ Compiler V3.11.1.207 for STM8                 19/Jan/2024  20:42:43
# Copyright 2010-2019 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for STMicroelectronics STM8
#
#    Source file  =  .\Lib\C\stm8s_flash.c
#    Command line =  
#        -f "e:\Nas\电路\保温箱\YZW-S805-EE22(Rev1.0) -
#        KF7620\C\build\Debug\.obj\Lib\C\stm8s_flash.args.txt" (--silent -lCN
#        .\build\Debug\.obj\Lib\C\stm8s_flash.lst -I d:/IAR/STM8/stm8/inc -I
#        d:/IAR/STM8/stm8/lib -I Lib/H -I Lib/C -I User -D STM8S005
#        --data_model medium --code_model medium --dlib_config dlstm8smn.h -e
#        --vregs 16 -On --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_cross_call --debug --dependencies=m + -o
#        .\build\Debug\.obj\Lib\C\stm8s_flash.o .\Lib\C\stm8s_flash.c)
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  .\build\Debug\.obj\Lib\C\stm8s_flash.lst
#    Object file  =  .\build\Debug\.obj\Lib\C\stm8s_flash.o
#
###############################################################################

e:\Nas\电路\保温箱\YZW-S805-EE22(Rev1.0) - KF7620\C\Lib\C\stm8s_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_flash.c
      4            * @author  MCD Application Team
      5            * @version V2.3.0
      6            * @date    16-June-2017
      7            * @brief   This file contains all the functions for the FLASH peripheral.
      8             ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "stm8s_flash.h"
     30          
     31          /** @addtogroup STM8S_StdPeriph_Driver
     32            * @{
     33            */
     34          /**
     35          @code
     36           This driver provides functions to configure and program the Flash memory of all
     37           STM8S devices.
     38          
     39           It includes as well functions that can be either executed from RAM or not, and
     40           other functions that must be executed from RAM otherwise useless.
     41          
     42           The table below lists the functions that can be executed from RAM.
     43          
     44           +--------------------------------------------------------------------------------|
     45           |   Functions prototypes      |    RAM execution            |     Comments       |
     46           ---------------------------------------------------------------------------------|
     47           |                             | Mandatory in case of block  | Can be executed    |
     48           | FLASH_WaitForLastOperation  | Operation:                  | from Flash in case |
     49           |                             | - Block programming         | of byte and word   |
     50           |                             | - Block erase               | Operations         |
     51           |--------------------------------------------------------------------------------|
     52           | FLASH_ProgramBlock          |       Exclusively           | useless from Flash |
     53           |--------------------------------------------------------------------------------|
     54           | FLASH_EraseBlock            |       Exclusively           | useless from Flash |
     55           |--------------------------------------------------------------------------------|
     56          
     57           To be able to execute functions from RAM several steps have to be followed.
     58           These steps may differ from one toolchain to another.
     59           A detailed description is available below within this driver.
     60           You can also refer to the FLASH examples provided within the
     61           STM8S_StdPeriph_Lib package.
     62          
     63          @endcode
     64          */
     65          
     66          
     67          /* Private typedef -----------------------------------------------------------*/
     68          /* Private define ------------------------------------------------------------*/
     69          #define FLASH_CLEAR_BYTE    ((uint8_t)0x00)
     70          #define FLASH_SET_BYTE      ((uint8_t)0xFF)
     71          #define OPERATION_TIMEOUT   ((uint16_t)0xFFFF)
     72          /* Private macro -------------------------------------------------------------*/
     73          /* Private variables ---------------------------------------------------------*/
     74          /* Private function prototypes -----------------------------------------------*/
     75          /* Private Constants ---------------------------------------------------------*/
     76          
     77          /** @addtogroup FLASH_Public_functions
     78            * @{
     79            */
     80          
     81          /**
     82            * @brief  Unlocks the program or data EEPROM memory
     83            * @param  FLASH_MemType : Memory type to unlock
     84            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
     85            * @retval None
     86            */

   \                                 In section .far_func.text, align 1
     87          void FLASH_Unlock(FLASH_MemType_TypeDef FLASH_MemType)
     88          {
   \                     FLASH_Unlock:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
     89            /* Check parameter */
     90            assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 FD        CP        A, #0xfd
   \   000009 27 15        JREQ      L:??FLASH_Unlock_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 F7        CP        A, #0xf7
   \   00000F 27 0F        JREQ      L:??FLASH_Unlock_0
   \   000011 AE 005A      LDW       X, #0x5a
   \   000014 BF ..        LDW       S:?w1, X
   \   000016 5F           CLRW      X
   \   000017 BF ..        LDW       S:?w0, X
   \   000019 AE ....      LDW       X, #?_0
   \   00001C 8D ......    CALLF     assert_failed
     91            
     92            /* Unlock program memory */
     93            if(FLASH_MemType == FLASH_MEMTYPE_PROG)
   \                     ??FLASH_Unlock_0:
   \   000020 B6 ..        LD        A, S:?b8
   \   000022 A1 FD        CP        A, #0xfd
   \   000024 26 0A        JRNE      L:??FLASH_Unlock_1
     94            {
     95              FLASH->PUKR = FLASH_RASS_KEY1;
   \   000026 35 56 5062   MOV       L:0x5062, #0x56
     96              FLASH->PUKR = FLASH_RASS_KEY2;
   \   00002A 35 AE 5062   MOV       L:0x5062, #0xae
   \   00002E 20 08        JRA       L:??FLASH_Unlock_2
     97            }
     98            /* Unlock data memory */
     99            else
    100            {
    101              FLASH->DUKR = FLASH_RASS_KEY2; /* Warning: keys are reversed on data memory !!! */
   \                     ??FLASH_Unlock_1:
   \   000030 35 AE 5064   MOV       L:0x5064, #0xae
    102              FLASH->DUKR = FLASH_RASS_KEY1;
   \   000034 35 56 5064   MOV       L:0x5064, #0x56
    103            }
    104          }
   \                     ??FLASH_Unlock_2:
   \   000038 32 ....      POP       S:?b8
   \   00003B 87           RETF
    105          
    106          /**
    107            * @brief  Locks the program or data EEPROM memory
    108            * @param  FLASH_MemType : Memory type
    109            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
    110            * @retval None
    111            */

   \                                 In section .far_func.text, align 1
    112          void FLASH_Lock(FLASH_MemType_TypeDef FLASH_MemType)
    113          {
   \                     FLASH_Lock:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    114            /* Check parameter */
    115            assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 FD        CP        A, #0xfd
   \   000009 27 15        JREQ      L:??FLASH_Lock_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 F7        CP        A, #0xf7
   \   00000F 27 0F        JREQ      L:??FLASH_Lock_0
   \   000011 AE 0073      LDW       X, #0x73
   \   000014 BF ..        LDW       S:?w1, X
   \   000016 5F           CLRW      X
   \   000017 BF ..        LDW       S:?w0, X
   \   000019 AE ....      LDW       X, #?_0
   \   00001C 8D ......    CALLF     assert_failed
    116            
    117            /* Lock memory */
    118            FLASH->IAPSR &= (uint8_t)FLASH_MemType;
   \                     ??FLASH_Lock_0:
   \   000020 C6 505F      LD        A, L:0x505f
   \   000023 B4 ..        AND       A, S:?b8
   \   000025 C7 505F      LD        L:0x505f, A
    119          }
   \   000028 32 ....      POP       S:?b8
   \   00002B 87           RETF
    120          
    121          /**
    122            * @brief  DeInitializes the FLASH registers to their default reset values.
    123            * @param  None
    124            * @retval None
    125            */

   \                                 In section .far_func.text, align 1
    126          void FLASH_DeInit(void)
    127          {
    128            FLASH->CR1 = FLASH_CR1_RESET_VALUE;
   \                     FLASH_DeInit:
   \   000000 725F 505A    CLR       L:0x505a
    129            FLASH->CR2 = FLASH_CR2_RESET_VALUE;
   \   000004 725F 505B    CLR       L:0x505b
    130            FLASH->NCR2 = FLASH_NCR2_RESET_VALUE;
   \   000008 35 FF 505C   MOV       L:0x505c, #0xff
    131            FLASH->IAPSR &= (uint8_t)(~FLASH_IAPSR_DUL);
   \   00000C 7217 505F    BRES      L:0x505f, #0x3
    132            FLASH->IAPSR &= (uint8_t)(~FLASH_IAPSR_PUL);
   \   000010 7213 505F    BRES      L:0x505f, #0x1
    133            (void) FLASH->IAPSR; /* Reading of this register causes the clearing of status flags */
   \   000014 C6 505F      LD        A, L:0x505f
    134          }
   \   000017 87           RETF
    135          
    136          /**
    137            * @brief  Enables or Disables the Flash interrupt mode
    138            * @param  NewState : The new state of the flash interrupt mode
    139            *         This parameter can be a value of @ref FunctionalState enumeration.
    140            * @retval None
    141            */

   \                                 In section .far_func.text, align 1
    142          void FLASH_ITConfig(FunctionalState NewState)
    143          {
   \                     FLASH_ITConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    144            /* Check parameter */
    145            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??FLASH_ITConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??FLASH_ITConfig_0
   \   00000F AE 0091      LDW       X, #0x91
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    146            
    147            if(NewState != DISABLE)
   \                     ??FLASH_ITConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??FLASH_ITConfig_1
    148            {
    149              FLASH->CR1 |= FLASH_CR1_IE; /* Enables the interrupt sources */
   \   000022 7212 505A    BSET      L:0x505a, #0x1
   \   000026 20 04        JRA       L:??FLASH_ITConfig_2
    150            }
    151            else
    152            {
    153              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_IE); /* Disables the interrupt sources */
   \                     ??FLASH_ITConfig_1:
   \   000028 7213 505A    BRES      L:0x505a, #0x1
    154            }
    155          }
   \                     ??FLASH_ITConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    156          
    157          /**
    158            * @brief  Erases one byte in the program or data EEPROM memory
    159            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    160            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    161            * @param  Address : Address of the byte to erase
    162            * @retval None
    163            */

   \                                 In section .far_func.text, align 1
    164          void FLASH_EraseByte(uint32_t Address)
    165          {
   \                     FLASH_EraseByte:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?mov_l2_l0
    166            /* Check parameter */
    167            assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   000008 BE ..        LDW       X, S:?w4
   \   00000A A3 0000      CPW       X, #0x0
   \   00000D 26 05        JRNE      L:??FLASH_EraseByte_0
   \   00000F BE ..        LDW       X, S:?w5
   \   000011 A3 8000      CPW       X, #0x8000
   \                     ??FLASH_EraseByte_0:
   \   000014 25 0E        JRC       L:??FLASH_EraseByte_1
   \   000016 BE ..        LDW       X, S:?w4
   \   000018 A3 0001      CPW       X, #0x1
   \   00001B 26 05        JRNE      L:??FLASH_EraseByte_2
   \   00001D BE ..        LDW       X, S:?w5
   \   00001F A3 0000      CPW       X, #0x0
   \                     ??FLASH_EraseByte_2:
   \   000022 25 2B        JRC       L:??FLASH_EraseByte_3
   \                     ??FLASH_EraseByte_1:
   \   000024 BE ..        LDW       X, S:?w4
   \   000026 A3 0000      CPW       X, #0x0
   \   000029 26 05        JRNE      L:??FLASH_EraseByte_4
   \   00002B BE ..        LDW       X, S:?w5
   \   00002D A3 4000      CPW       X, #0x4000
   \                     ??FLASH_EraseByte_4:
   \   000030 25 0E        JRC       L:??FLASH_EraseByte_5
   \   000032 BE ..        LDW       X, S:?w4
   \   000034 A3 0000      CPW       X, #0x0
   \   000037 26 05        JRNE      L:??FLASH_EraseByte_6
   \   000039 BE ..        LDW       X, S:?w5
   \   00003B A3 4400      CPW       X, #0x4400
   \                     ??FLASH_EraseByte_6:
   \   00003E 25 0F        JRC       L:??FLASH_EraseByte_3
   \                     ??FLASH_EraseByte_5:
   \   000040 AE 00A7      LDW       X, #0xa7
   \   000043 BF ..        LDW       S:?w1, X
   \   000045 5F           CLRW      X
   \   000046 BF ..        LDW       S:?w0, X
   \   000048 AE ....      LDW       X, #?_0
   \   00004B 8D ......    CALLF     assert_failed
    168            
    169            /* Erase byte */
    170            *(PointerAttr uint8_t*) (MemoryAddressCast)Address = FLASH_CLEAR_BYTE; 
   \                     ??FLASH_EraseByte_3:
   \   00004F BE ..        LDW       X, S:?w5
   \   000051 7F           CLR       (X)
    171          }
   \   000052 AC ......    JPF       L:?epilogue_l2
    172          
    173          /**
    174            * @brief  Programs one byte in program or data EEPROM memory
    175            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    176            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    177            * @param  Address : Address where the byte will be programmed
    178            * @param  Data : Value to be programmed
    179            * @retval None
    180            */

   \                                 In section .far_func.text, align 1
    181          void FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    182          {
   \                     FLASH_ProgramByte:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 3B ....      PUSH      S:?b12
   \   000007 8D ......    CALLF     L:?mov_l2_l0
   \   00000B B7 ..        LD        S:?b12, A
    183            /* Check parameters */
    184            assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   00000D BE ..        LDW       X, S:?w4
   \   00000F A3 0000      CPW       X, #0x0
   \   000012 26 05        JRNE      L:??FLASH_ProgramByte_0
   \   000014 BE ..        LDW       X, S:?w5
   \   000016 A3 8000      CPW       X, #0x8000
   \                     ??FLASH_ProgramByte_0:
   \   000019 25 0E        JRC       L:??FLASH_ProgramByte_1
   \   00001B BE ..        LDW       X, S:?w4
   \   00001D A3 0001      CPW       X, #0x1
   \   000020 26 05        JRNE      L:??FLASH_ProgramByte_2
   \   000022 BE ..        LDW       X, S:?w5
   \   000024 A3 0000      CPW       X, #0x0
   \                     ??FLASH_ProgramByte_2:
   \   000027 25 2B        JRC       L:??FLASH_ProgramByte_3
   \                     ??FLASH_ProgramByte_1:
   \   000029 BE ..        LDW       X, S:?w4
   \   00002B A3 0000      CPW       X, #0x0
   \   00002E 26 05        JRNE      L:??FLASH_ProgramByte_4
   \   000030 BE ..        LDW       X, S:?w5
   \   000032 A3 4000      CPW       X, #0x4000
   \                     ??FLASH_ProgramByte_4:
   \   000035 25 0E        JRC       L:??FLASH_ProgramByte_5
   \   000037 BE ..        LDW       X, S:?w4
   \   000039 A3 0000      CPW       X, #0x0
   \   00003C 26 05        JRNE      L:??FLASH_ProgramByte_6
   \   00003E BE ..        LDW       X, S:?w5
   \   000040 A3 4400      CPW       X, #0x4400
   \                     ??FLASH_ProgramByte_6:
   \   000043 25 0F        JRC       L:??FLASH_ProgramByte_3
   \                     ??FLASH_ProgramByte_5:
   \   000045 AE 00B8      LDW       X, #0xb8
   \   000048 BF ..        LDW       S:?w1, X
   \   00004A 5F           CLRW      X
   \   00004B BF ..        LDW       S:?w0, X
   \   00004D AE ....      LDW       X, #?_0
   \   000050 8D ......    CALLF     assert_failed
    185            *(PointerAttr uint8_t*) (MemoryAddressCast)Address = Data;
   \                     ??FLASH_ProgramByte_3:
   \   000054 BE ..        LDW       X, S:?w5
   \   000056 B6 ..        LD        A, S:?b12
   \   000058 F7           LD        (X), A
    186          }
   \   000059 32 ....      POP       S:?b12
   \   00005C AC ......    JPF       L:?epilogue_l2
    187          
    188          /**
    189            * @brief  Reads any byte from flash memory
    190            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    191            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    192            * @param  Address : Address to read
    193            * @retval Value of the byte
    194            */

   \                                 In section .far_func.text, align 1
    195          uint8_t FLASH_ReadByte(uint32_t Address)
    196          {
   \                     FLASH_ReadByte:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?mov_l2_l0
    197            /* Check parameter */
    198            assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   000008 BE ..        LDW       X, S:?w4
   \   00000A A3 0000      CPW       X, #0x0
   \   00000D 26 05        JRNE      L:??FLASH_ReadByte_0
   \   00000F BE ..        LDW       X, S:?w5
   \   000011 A3 8000      CPW       X, #0x8000
   \                     ??FLASH_ReadByte_0:
   \   000014 25 0E        JRC       L:??FLASH_ReadByte_1
   \   000016 BE ..        LDW       X, S:?w4
   \   000018 A3 0001      CPW       X, #0x1
   \   00001B 26 05        JRNE      L:??FLASH_ReadByte_2
   \   00001D BE ..        LDW       X, S:?w5
   \   00001F A3 0000      CPW       X, #0x0
   \                     ??FLASH_ReadByte_2:
   \   000022 25 2B        JRC       L:??FLASH_ReadByte_3
   \                     ??FLASH_ReadByte_1:
   \   000024 BE ..        LDW       X, S:?w4
   \   000026 A3 0000      CPW       X, #0x0
   \   000029 26 05        JRNE      L:??FLASH_ReadByte_4
   \   00002B BE ..        LDW       X, S:?w5
   \   00002D A3 4000      CPW       X, #0x4000
   \                     ??FLASH_ReadByte_4:
   \   000030 25 0E        JRC       L:??FLASH_ReadByte_5
   \   000032 BE ..        LDW       X, S:?w4
   \   000034 A3 0000      CPW       X, #0x0
   \   000037 26 05        JRNE      L:??FLASH_ReadByte_6
   \   000039 BE ..        LDW       X, S:?w5
   \   00003B A3 4400      CPW       X, #0x4400
   \                     ??FLASH_ReadByte_6:
   \   00003E 25 0F        JRC       L:??FLASH_ReadByte_3
   \                     ??FLASH_ReadByte_5:
   \   000040 AE 00C6      LDW       X, #0xc6
   \   000043 BF ..        LDW       S:?w1, X
   \   000045 5F           CLRW      X
   \   000046 BF ..        LDW       S:?w0, X
   \   000048 AE ....      LDW       X, #?_0
   \   00004B 8D ......    CALLF     assert_failed
    199            
    200            /* Read byte */
    201            return(*(PointerAttr uint8_t *) (MemoryAddressCast)Address); 
   \                     ??FLASH_ReadByte_3:
   \   00004F BE ..        LDW       X, S:?w5
   \   000051 F6           LD        A, (X)
   \   000052 AC ......    JPF       L:?epilogue_l2
    202          }
    203          
    204          /**
    205            * @brief  Programs one word (4 bytes) in program or data EEPROM memory
    206            * @note   PointerAttr define is declared in the stm8s.h file to select if 
    207            *         the pointer will be declared as near (2 bytes) or far (3 bytes).
    208            * @param  Address : The address where the data will be programmed
    209            * @param  Data : Value to be programmed
    210            * @retval None
    211            */

   \                                 In section .far_func.text, align 1
    212          void FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    213          {
   \                     FLASH_ProgramWord:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l1
   \   000008 8D ......    CALLF     L:?mov_l2_l0
    214            /* Check parameters */
    215            assert_param(IS_FLASH_ADDRESS_OK(Address));
   \   00000C BE ..        LDW       X, S:?w4
   \   00000E A3 0000      CPW       X, #0x0
   \   000011 26 05        JRNE      L:??FLASH_ProgramWord_0
   \   000013 BE ..        LDW       X, S:?w5
   \   000015 A3 8000      CPW       X, #0x8000
   \                     ??FLASH_ProgramWord_0:
   \   000018 25 0E        JRC       L:??FLASH_ProgramWord_1
   \   00001A BE ..        LDW       X, S:?w4
   \   00001C A3 0001      CPW       X, #0x1
   \   00001F 26 05        JRNE      L:??FLASH_ProgramWord_2
   \   000021 BE ..        LDW       X, S:?w5
   \   000023 A3 0000      CPW       X, #0x0
   \                     ??FLASH_ProgramWord_2:
   \   000026 25 2B        JRC       L:??FLASH_ProgramWord_3
   \                     ??FLASH_ProgramWord_1:
   \   000028 BE ..        LDW       X, S:?w4
   \   00002A A3 0000      CPW       X, #0x0
   \   00002D 26 05        JRNE      L:??FLASH_ProgramWord_4
   \   00002F BE ..        LDW       X, S:?w5
   \   000031 A3 4000      CPW       X, #0x4000
   \                     ??FLASH_ProgramWord_4:
   \   000034 25 0E        JRC       L:??FLASH_ProgramWord_5
   \   000036 BE ..        LDW       X, S:?w4
   \   000038 A3 0000      CPW       X, #0x0
   \   00003B 26 05        JRNE      L:??FLASH_ProgramWord_6
   \   00003D BE ..        LDW       X, S:?w5
   \   00003F A3 4400      CPW       X, #0x4400
   \                     ??FLASH_ProgramWord_6:
   \   000042 25 0F        JRC       L:??FLASH_ProgramWord_3
   \                     ??FLASH_ProgramWord_5:
   \   000044 AE 00D7      LDW       X, #0xd7
   \   000047 BF ..        LDW       S:?w1, X
   \   000049 5F           CLRW      X
   \   00004A BF ..        LDW       S:?w0, X
   \   00004C AE ....      LDW       X, #?_0
   \   00004F 8D ......    CALLF     assert_failed
    216            
    217            /* Enable Word Write Once */
    218            FLASH->CR2 |= FLASH_CR2_WPRG;
   \                     ??FLASH_ProgramWord_3:
   \   000053 721C 505B    BSET      L:0x505b, #0x6
    219            FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NWPRG);
   \   000057 721D 505C    BRES      L:0x505c, #0x6
    220            
    221            /* Write one byte - from lowest address*/
    222            *((PointerAttr uint8_t*)(MemoryAddressCast)Address)       = *((uint8_t*)(&Data));
   \   00005B BE ..        LDW       X, S:?w5
   \   00005D 7B 01        LD        A, (0x1,SP)
   \   00005F F7           LD        (X), A
    223            /* Write one byte*/
    224            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 1) = *((uint8_t*)(&Data)+1); 
   \   000060 BE ..        LDW       X, S:?w5
   \   000062 5C           INCW      X
   \   000063 7B 02        LD        A, (0x2,SP)
   \   000065 F7           LD        (X), A
    225            /* Write one byte*/    
    226            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 2) = *((uint8_t*)(&Data)+2); 
   \   000066 BE ..        LDW       X, S:?w5
   \   000068 5C           INCW      X
   \   000069 5C           INCW      X
   \   00006A 7B 03        LD        A, (0x3,SP)
   \   00006C F7           LD        (X), A
    227            /* Write one byte - from higher address*/
    228            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 3) = *((uint8_t*)(&Data)+3); 
   \   00006D BE ..        LDW       X, S:?w5
   \   00006F 7B 04        LD        A, (0x4,SP)
   \   000071 1C 0003      ADDW      X, #0x3
   \   000074 F7           LD        (X), A
   \   000075 1D 0003      SUBW      X, #0x3
    229          }
   \   000078 5B 04        ADD       SP, #0x4
   \   00007A AC ......    JPF       L:?epilogue_l2
    230          
    231          /**
    232            * @brief  Programs option byte
    233            * @param  Address : option byte address to program
    234            * @param  Data : Value to write
    235            * @retval None
    236            */

   \                                 In section .far_func.text, align 1
    237          void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data)
    238          {
   \                     FLASH_ProgramOptionByte:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
   \   000009 B7 ..        LD        S:?b10, A
    239            /* Check parameter */
    240            assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   00000B BE ..        LDW       X, S:?w4
   \   00000D A3 4800      CPW       X, #0x4800
   \   000010 25 07        JRC       L:??FLASH_ProgramOptionByte_0
   \   000012 BE ..        LDW       X, S:?w4
   \   000014 A3 4880      CPW       X, #0x4880
   \   000017 25 0F        JRC       L:??FLASH_ProgramOptionByte_1
   \                     ??FLASH_ProgramOptionByte_0:
   \   000019 AE 00F0      LDW       X, #0xf0
   \   00001C BF ..        LDW       S:?w1, X
   \   00001E 5F           CLRW      X
   \   00001F BF ..        LDW       S:?w0, X
   \   000021 AE ....      LDW       X, #?_0
   \   000024 8D ......    CALLF     assert_failed
    241            
    242            /* Enable write access to option bytes */
    243            FLASH->CR2 |= FLASH_CR2_OPT;
   \                     ??FLASH_ProgramOptionByte_1:
   \   000028 721E 505B    BSET      L:0x505b, #0x7
    244            FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NOPT);
   \   00002C 721F 505C    BRES      L:0x505c, #0x7
    245            
    246            /* check if the option byte to program is ROP*/
    247            if(Address == 0x4800)
   \   000030 BE ..        LDW       X, S:?w4
   \   000032 A3 4800      CPW       X, #0x4800
   \   000035 26 07        JRNE      L:??FLASH_ProgramOptionByte_2
    248            {
    249              /* Program option byte*/
    250              *((NEAR uint8_t*)Address) = Data;
   \   000037 B6 ..        LD        A, S:?b10
   \   000039 92C7 ..      LD        [S:?w4.w], A
   \   00003C 20 0C        JRA       L:??FLASH_ProgramOptionByte_3
    251            }
    252            else
    253            {
    254              /* Program option byte and his complement */
    255              *((NEAR uint8_t*)Address) = Data;
   \                     ??FLASH_ProgramOptionByte_2:
   \   00003E B6 ..        LD        A, S:?b10
   \   000040 92C7 ..      LD        [S:?w4.w], A
    256              *((NEAR uint8_t*)((uint16_t)(Address + 1))) = (uint8_t)(~Data);
   \   000043 BE ..        LDW       X, S:?w4
   \   000045 5C           INCW      X
   \   000046 B6 ..        LD        A, S:?b10
   \   000048 43           CPL       A
   \   000049 F7           LD        (X), A
    257            }
    258            FLASH_WaitForLastOperation(FLASH_MEMTYPE_PROG);
   \                     ??FLASH_ProgramOptionByte_3:
   \   00004A A6 FD        LD        A, #0xfd
   \   00004C 8D ......    CALLF     FLASH_WaitForLastOperation
    259            
    260            /* Disable write access to option bytes */
    261            FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
   \   000050 721F 505B    BRES      L:0x505b, #0x7
    262            FLASH->NCR2 |= FLASH_NCR2_NOPT;
   \   000054 721E 505C    BSET      L:0x505c, #0x7
    263          }
   \   000058 32 ....      POP       S:?b10
   \   00005B AC ......    JPF       L:?epilogue_w4
    264          
    265          /**
    266            * @brief  Erases option byte
    267            * @param  Address : Option byte address to erase
    268            * @retval None
    269            */

   \                                 In section .far_func.text, align 1
    270          void FLASH_EraseOptionByte(uint16_t Address)
    271          {
   \                     FLASH_EraseOptionByte:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
    272            /* Check parameter */
    273            assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   000006 BE ..        LDW       X, S:?w4
   \   000008 A3 4800      CPW       X, #0x4800
   \   00000B 25 07        JRC       L:??FLASH_EraseOptionByte_0
   \   00000D BE ..        LDW       X, S:?w4
   \   00000F A3 4880      CPW       X, #0x4880
   \   000012 25 0F        JRC       L:??FLASH_EraseOptionByte_1
   \                     ??FLASH_EraseOptionByte_0:
   \   000014 AE 0111      LDW       X, #0x111
   \   000017 BF ..        LDW       S:?w1, X
   \   000019 5F           CLRW      X
   \   00001A BF ..        LDW       S:?w0, X
   \   00001C AE ....      LDW       X, #?_0
   \   00001F 8D ......    CALLF     assert_failed
    274            
    275            /* Enable write access to option bytes */
    276            FLASH->CR2 |= FLASH_CR2_OPT;
   \                     ??FLASH_EraseOptionByte_1:
   \   000023 721E 505B    BSET      L:0x505b, #0x7
    277            FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NOPT);
   \   000027 721F 505C    BRES      L:0x505c, #0x7
    278            
    279            /* check if the option byte to erase is ROP */
    280            if(Address == 0x4800)
   \   00002B BE ..        LDW       X, S:?w4
   \   00002D A3 4800      CPW       X, #0x4800
   \   000030 26 05        JRNE      L:??FLASH_EraseOptionByte_2
    281            {
    282              /* Erase option byte */
    283              *((NEAR uint8_t*)Address) = FLASH_CLEAR_BYTE;
   \   000032 923F ..      CLR       [S:?w4.w]
   \   000035 20 09        JRA       L:??FLASH_EraseOptionByte_3
    284            }
    285            else
    286            {
    287              /* Erase option byte and his complement */
    288              *((NEAR uint8_t*)Address) = FLASH_CLEAR_BYTE;
   \                     ??FLASH_EraseOptionByte_2:
   \   000037 923F ..      CLR       [S:?w4.w]
    289              *((NEAR uint8_t*)((uint16_t)(Address + (uint16_t)1 ))) = FLASH_SET_BYTE;
   \   00003A BE ..        LDW       X, S:?w4
   \   00003C 5C           INCW      X
   \   00003D A6 FF        LD        A, #0xff
   \   00003F F7           LD        (X), A
    290            }
    291            FLASH_WaitForLastOperation(FLASH_MEMTYPE_PROG);
   \                     ??FLASH_EraseOptionByte_3:
   \   000040 A6 FD        LD        A, #0xfd
   \   000042 8D ......    CALLF     FLASH_WaitForLastOperation
    292            
    293            /* Disable write access to option bytes */
    294            FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
   \   000046 721F 505B    BRES      L:0x505b, #0x7
    295            FLASH->NCR2 |= FLASH_NCR2_NOPT;
   \   00004A 721E 505C    BSET      L:0x505c, #0x7
    296          }
   \   00004E AC ......    JPF       L:?epilogue_w4
    297          
    298          /**
    299            * @brief  Reads one option byte
    300            * @param  Address  option byte address to read.
    301            * @retval Option byte read value + its complement
    302            */

   \                                 In section .far_func.text, align 1
    303          uint16_t FLASH_ReadOptionByte(uint16_t Address)
    304          {
   \                     FLASH_ReadOptionByte:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 BF ..        LDW       S:?w4, X
    305            uint8_t value_optbyte, value_optbyte_complement = 0;
   \   00000A 3F ..        CLR       S:?b15
    306            uint16_t res_value = 0;
   \   00000C 3F ..        CLR       S:?b11
   \   00000E 3F ..        CLR       S:?b10
    307            
    308            /* Check parameter */
    309            assert_param(IS_OPTION_BYTE_ADDRESS_OK(Address));
   \   000010 BE ..        LDW       X, S:?w4
   \   000012 A3 4800      CPW       X, #0x4800
   \   000015 25 07        JRC       L:??FLASH_ReadOptionByte_0
   \   000017 BE ..        LDW       X, S:?w4
   \   000019 A3 4880      CPW       X, #0x4880
   \   00001C 25 0F        JRC       L:??FLASH_ReadOptionByte_1
   \                     ??FLASH_ReadOptionByte_0:
   \   00001E AE 0135      LDW       X, #0x135
   \   000021 BF ..        LDW       S:?w1, X
   \   000023 5F           CLRW      X
   \   000024 BF ..        LDW       S:?w0, X
   \   000026 AE ....      LDW       X, #?_0
   \   000029 8D ......    CALLF     assert_failed
    310              
    311            value_optbyte = *((NEAR uint8_t*)Address); /* Read option byte */
   \                     ??FLASH_ReadOptionByte_1:
   \   00002D 92C6 ..      LD        A, [S:?w4.w]
   \   000030 B7 ..        LD        S:?b13, A
    312            value_optbyte_complement = *(((NEAR uint8_t*)Address) + 1); /* Read option byte complement */
   \   000032 BE ..        LDW       X, S:?w4
   \   000034 5C           INCW      X
   \   000035 F6           LD        A, (X)
   \   000036 B7 ..        LD        S:?b15, A
    313            
    314            /* Read-out protection option byte */
    315            if(Address == 0x4800)	 
   \   000038 BE ..        LDW       X, S:?w4
   \   00003A A3 4800      CPW       X, #0x4800
   \   00003D 26 08        JRNE      L:??FLASH_ReadOptionByte_2
    316            {
    317              res_value =	 value_optbyte;
   \   00003F 3F ..        CLR       S:?b12
   \   000041 8D ......    CALLF     L:?mov_w5_w6
   \   000045 20 23        JRA       L:??FLASH_ReadOptionByte_3
    318            }
    319            else
    320            {
    321              if(value_optbyte == (uint8_t)(~value_optbyte_complement))
   \                     ??FLASH_ReadOptionByte_2:
   \   000047 B6 ..        LD        A, S:?b15
   \   000049 43           CPL       A
   \   00004A B1 ..        CP        A, S:?b13
   \   00004C 26 17        JRNE      L:??FLASH_ReadOptionByte_4
    322              {
    323                res_value = (uint16_t)((uint16_t)value_optbyte << 8);
   \   00004E 5F           CLRW      X
   \   00004F B6 ..        LD        A, S:?b13
   \   000051 97           LD        XL, A
   \   000052 4F           CLR       A
   \   000053 02           RLWA      X, A
   \   000054 BF ..        LDW       S:?w5, X
    324                res_value = res_value | (uint16_t)value_optbyte_complement;
   \   000056 3F ..        CLR       S:?b14
   \   000058 BE ..        LDW       X, S:?w5
   \   00005A 01           RRWA      X, A
   \   00005B BA ..        OR        A, S:?b15
   \   00005D 01           RRWA      X, A
   \   00005E BA ..        OR        A, S:?b14
   \   000060 01           RRWA      X, A
   \   000061 BF ..        LDW       S:?w5, X
   \   000063 20 05        JRA       L:??FLASH_ReadOptionByte_3
    325              }
    326              else
    327              {
    328                res_value = FLASH_OPTIONBYTE_ERROR;
   \                     ??FLASH_ReadOptionByte_4:
   \   000065 AE 5555      LDW       X, #0x5555
   \   000068 BF ..        LDW       S:?w5, X
    329              }
    330            }
    331            return(res_value);
   \                     ??FLASH_ReadOptionByte_3:
   \   00006A BE ..        LDW       X, S:?w5
   \   00006C AC ......    JPF       L:?epilogue_l2_l3
    332          }
    333          
    334          /**
    335            * @brief  Select the Flash behaviour in low power mode
    336            * @param  FLASH_LPMode Low power mode selection
    337            *         This parameter can be any of the @ref FLASH_LPMode_TypeDef values.
    338            * @retval None
    339            */

   \                                 In section .far_func.text, align 1
    340          void FLASH_SetLowPowerMode(FLASH_LPMode_TypeDef FLASH_LPMode)
    341          {
   \                     FLASH_SetLowPowerMode:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    342            /* Check parameter */
    343            assert_param(IS_FLASH_LOW_POWER_MODE_OK(FLASH_LPMode));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 04        CP        A, #0x4
   \   000009 27 1F        JREQ      L:??FLASH_SetLowPowerMode_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 08        CP        A, #0x8
   \   00000F 27 19        JREQ      L:??FLASH_SetLowPowerMode_0
   \   000011 3D ..        TNZ       S:?b8
   \   000013 27 15        JREQ      L:??FLASH_SetLowPowerMode_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 0C        CP        A, #0xc
   \   000019 27 0F        JREQ      L:??FLASH_SetLowPowerMode_0
   \   00001B AE 0157      LDW       X, #0x157
   \   00001E BF ..        LDW       S:?w1, X
   \   000020 5F           CLRW      X
   \   000021 BF ..        LDW       S:?w0, X
   \   000023 AE ....      LDW       X, #?_0
   \   000026 8D ......    CALLF     assert_failed
    344            
    345            /* Clears the two bits */
    346            FLASH->CR1 &= (uint8_t)(~(FLASH_CR1_HALT | FLASH_CR1_AHALT)); 
   \                     ??FLASH_SetLowPowerMode_0:
   \   00002A C6 505A      LD        A, L:0x505a
   \   00002D A4 F3        AND       A, #0xf3
   \   00002F C7 505A      LD        L:0x505a, A
    347            
    348            /* Sets the new mode */
    349            FLASH->CR1 |= (uint8_t)FLASH_LPMode; 
   \   000032 C6 505A      LD        A, L:0x505a
   \   000035 BA ..        OR        A, S:?b8
   \   000037 C7 505A      LD        L:0x505a, A
    350          }
   \   00003A 32 ....      POP       S:?b8
   \   00003D 87           RETF
    351          
    352          /**
    353            * @brief  Sets the fixed programming time
    354            * @param  FLASH_ProgTime Indicates the programming time to be fixed
    355            *         This parameter can be any of the @ref FLASH_ProgramTime_TypeDef values.
    356            * @retval None
    357            */

   \                                 In section .far_func.text, align 1
    358          void FLASH_SetProgrammingTime(FLASH_ProgramTime_TypeDef FLASH_ProgTime)
    359          {
   \                     FLASH_SetProgrammingTime:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    360            /* Check parameter */
    361            assert_param(IS_FLASH_PROGRAM_TIME_OK(FLASH_ProgTime));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??FLASH_SetProgrammingTime_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??FLASH_SetProgrammingTime_0
   \   00000F AE 0169      LDW       X, #0x169
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    362            
    363            FLASH->CR1 &= (uint8_t)(~FLASH_CR1_FIX);
   \                     ??FLASH_SetProgrammingTime_0:
   \   00001E 7211 505A    BRES      L:0x505a, #0x0
    364            FLASH->CR1 |= (uint8_t)FLASH_ProgTime;
   \   000022 C6 505A      LD        A, L:0x505a
   \   000025 BA ..        OR        A, S:?b8
   \   000027 C7 505A      LD        L:0x505a, A
    365          }
   \   00002A 32 ....      POP       S:?b8
   \   00002D 87           RETF
    366          
    367          /**
    368            * @brief  Returns the Flash behaviour type in low power mode
    369            * @param  None
    370            * @retval FLASH_LPMode_TypeDef Flash behaviour type in low power mode
    371            */

   \                                 In section .far_func.text, align 1
    372          FLASH_LPMode_TypeDef FLASH_GetLowPowerMode(void)
    373          {
    374            return((FLASH_LPMode_TypeDef)(FLASH->CR1 & (uint8_t)(FLASH_CR1_HALT | FLASH_CR1_AHALT)));
   \                     FLASH_GetLowPowerMode:
   \   000000 C6 505A      LD        A, L:0x505a
   \   000003 A4 0C        AND       A, #0xc
   \   000005 87           RETF
    375          }
    376          
    377          /**
    378            * @brief  Returns the fixed programming time
    379            * @param  None
    380            * @retval FLASH_ProgramTime_TypeDef Fixed programming time value
    381            */

   \                                 In section .far_func.text, align 1
    382          FLASH_ProgramTime_TypeDef FLASH_GetProgrammingTime(void)
    383          {
    384            return((FLASH_ProgramTime_TypeDef)(FLASH->CR1 & FLASH_CR1_FIX));
   \                     FLASH_GetProgrammingTime:
   \   000000 C6 505A      LD        A, L:0x505a
   \   000003 A4 01        AND       A, #0x1
   \   000005 87           RETF
    385          }
    386          
    387          /**
    388            * @brief  Returns the Boot memory size in bytes
    389            * @param  None
    390            * @retval Boot memory size in bytes
    391            */

   \                                 In section .far_func.text, align 1
    392          uint32_t FLASH_GetBootSize(void)
    393          {
   \                     FLASH_GetBootSize:
   \   000000 8D ......    CALLF     L:?push_l2
    394            uint32_t temp = 0;
   \   000004 5F           CLRW      X
   \   000005 BF ..        LDW       S:?w5, X
   \   000007 BF ..        LDW       S:?w4, X
    395            
    396            /* Calculates the number of bytes */
    397            temp = (uint32_t)((uint32_t)FLASH->FPR * (uint32_t)512);
   \   000009 C6 505D      LD        A, L:0x505d
   \   00000C 5F           CLRW      X
   \   00000D 97           LD        XL, A
   \   00000E BF ..        LDW       S:?w1, X
   \   000010 5F           CLRW      X
   \   000011 BF ..        LDW       S:?w0, X
   \   000013 AE 0200      LDW       X, #0x200
   \   000016 BF ..        LDW       S:?w3, X
   \   000018 5F           CLRW      X
   \   000019 BF ..        LDW       S:?w2, X
   \   00001B 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   00001F 8D ......    CALLF     L:?mov_l2_l0
    398            
    399            /* Correction because size of 127.5 kb doesn't exist */
    400            if(FLASH->FPR == 0xFF)
   \   000023 C6 505D      LD        A, L:0x505d
   \   000026 A1 FF        CP        A, #0xff
   \   000028 26 14        JRNE      L:??FLASH_GetBootSize_0
    401            {
    402              temp += 512;
   \   00002A AE 0200      LDW       X, #0x200
   \   00002D BF ..        LDW       S:?w3, X
   \   00002F 5F           CLRW      X
   \   000030 BF ..        LDW       S:?w2, X
   \   000032 8D ......    CALLF     L:?mov_l0_l2
   \   000036 8D ......    CALLF     L:?add32_l0_l0_l1
   \   00003A 8D ......    CALLF     L:?mov_l2_l0
    403            }
    404            
    405            /* Return value */
    406            return(temp);
   \                     ??FLASH_GetBootSize_0:
   \   00003E 8D ......    CALLF     L:?mov_l0_l2
   \   000042 AC ......    JPF       L:?epilogue_l2
    407          }
    408          
    409          /**
    410            * @brief  Checks whether the specified SPI flag is set or not.
    411            * @param  FLASH_FLAG : Specifies the flag to check.
    412            *         This parameter can be any of the @ref FLASH_Flag_TypeDef enumeration.
    413            * @retval FlagStatus : Indicates the state of FLASH_FLAG.
    414            *         This parameter can be any of the @ref FlagStatus enumeration.
    415            * @note   This function can clear the EOP, WR_PG_DIS flags in the IAPSR register.
    416            */

   \                                 In section .far_func.text, align 1
    417          FlagStatus FLASH_GetFlagStatus(FLASH_Flag_TypeDef FLASH_FLAG)
    418          {
   \                     FLASH_GetFlagStatus:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
    419            FlagStatus status = RESET;
   \   000006 3F ..        CLR       S:?b8
    420            /* Check parameters */
    421            assert_param(IS_FLASH_FLAGS_OK(FLASH_FLAG));
   \   000008 B6 ..        LD        A, S:?b9
   \   00000A A1 40        CP        A, #0x40
   \   00000C 27 27        JREQ      L:??FLASH_GetFlagStatus_0
   \   00000E B6 ..        LD        A, S:?b9
   \   000010 A1 08        CP        A, #0x8
   \   000012 27 21        JREQ      L:??FLASH_GetFlagStatus_0
   \   000014 B6 ..        LD        A, S:?b9
   \   000016 A1 04        CP        A, #0x4
   \   000018 27 1B        JREQ      L:??FLASH_GetFlagStatus_0
   \   00001A B6 ..        LD        A, S:?b9
   \   00001C A1 02        CP        A, #0x2
   \   00001E 27 15        JREQ      L:??FLASH_GetFlagStatus_0
   \   000020 B6 ..        LD        A, S:?b9
   \   000022 A1 01        CP        A, #0x1
   \   000024 27 0F        JREQ      L:??FLASH_GetFlagStatus_0
   \   000026 AE 01A5      LDW       X, #0x1a5
   \   000029 BF ..        LDW       S:?w1, X
   \   00002B 5F           CLRW      X
   \   00002C BF ..        LDW       S:?w0, X
   \   00002E AE ....      LDW       X, #?_0
   \   000031 8D ......    CALLF     assert_failed
    422            
    423            /* Check the status of the specified FLASH flag */
    424            if((FLASH->IAPSR & (uint8_t)FLASH_FLAG) != (uint8_t)RESET)
   \                     ??FLASH_GetFlagStatus_0:
   \   000035 C6 505F      LD        A, L:0x505f
   \   000038 B4 ..        AND       A, S:?b9
   \   00003A A1 00        CP        A, #0x0
   \   00003C 27 06        JREQ      L:??FLASH_GetFlagStatus_1
    425            {
    426              status = SET; /* FLASH_FLAG is set */
   \   00003E A6 01        LD        A, #0x1
   \   000040 B7 ..        LD        S:?b8, A
   \   000042 20 02        JRA       L:??FLASH_GetFlagStatus_2
    427            }
    428            else
    429            {
    430              status = RESET; /* FLASH_FLAG is reset*/
   \                     ??FLASH_GetFlagStatus_1:
   \   000044 3F ..        CLR       S:?b8
    431            }
    432            
    433            /* Return the FLASH_FLAG status */
    434            return status;
   \                     ??FLASH_GetFlagStatus_2:
   \   000046 B6 ..        LD        A, S:?b8
   \   000048 AC ......    JPF       L:?epilogue_w4
    435          }
    436          
    437          /**
    438          @code
    439           All the functions defined below must be executed from RAM exclusively, except
    440           for the FLASH_WaitForLastOperation function which can be executed from Flash.
    441          
    442           Steps of the execution from RAM differs from one toolchain to another:
    443           - For Cosmic Compiler:
    444              1- Define a segment FLASH_CODE by the mean of " #pragma section (FLASH_CODE)".
    445              This segment is defined in the stm8s_flash.c file.
    446            2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file,
    447              or define it in Cosmic compiler preprocessor to enable the FLASH_CODE segment
    448             definition.
    449            3- In STVD Select Project\Settings\Linker\Category "input" and in the RAM section
    450              add the FLASH_CODE segment with "-ic" options.
    451            4- In main.c file call the _fctcpy() function with first segment character as 
    452              parameter "_fctcpy('F');" to load the declared moveable code segment
    453              (FLASH_CODE) in RAM before execution.
    454            5- By default the _fctcpy function is packaged in the Cosmic machine library,
    455              so the function prototype "int _fctcopy(char name);" must be added in main.c
    456              file.
    457          
    458            - For Raisonance Compiler
    459             1- Use the inram keyword in the function declaration to specify that it can be
    460              executed from RAM.
    461              This is done within the stm8s_flash.c file, and it's conditioned by 
    462              RAM_EXECUTION definition.
    463             2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file, or 
    464             define it in Raisonance compiler preprocessor to enable the access for the 
    465             inram functions.
    466             3- An inram function code is copied from Flash to RAM by the C startup code. 
    467             In some applications, the RAM area where the code was initially stored may be
    468             erased or corrupted, so it may be desirable to perform the copy again. 
    469             Depending on the application memory model, the memcpy() or fmemcpy() functions
    470             should be used to perform the copy.
    471                 In case your project uses the SMALL memory model (code smaller than 64K),
    472                 memcpy()function is recommended to perform the copy
    473                 In case your project uses the LARGE memory model, functions can be 
    474                everywhere in the 24-bits address space (not limited to the first 64KB of
    475                code), In this case, the use of memcpy() function will not be appropriate,
    476                you need to use the specific fmemcpy() function (which copies objects with
    477                24-bit addresses).
    478                - The linker automatically defines 2 symbols for each inram function:
    479                      __address__functionname is a symbol that holds the Flash address 
    480                     where the given function code is stored.
    481                      __size__functionname is a symbol that holds the function size in bytes.
    482               And we already have the function address (which is itself a pointer)
    483            4- In main.c file these two steps should be performed for each inram function:
    484                Import the "__address__functionname" and "__size__functionname" symbols
    485                 as global variables:
    486                   extern int __address__functionname; // Symbol holding the flash address
    487                   extern int __size__functionname;    // Symbol holding the function size
    488                In case of SMALL memory model use, Call the memcpy() function to copy the
    489                inram function to the RAM destination address:
    490                          memcpy(functionname, // RAM destination address
    491                                (void*)&__address__functionname, // Flash source address
    492                                (int)&__size__functionname); // Code size of the function
    493                In case of LARGE memory model use, call the fmemcpy() function to copy 
    494               the inram function to the RAM destination address:
    495                           memcpy(functionname, // RAM destination address
    496                                (void @far*)&__address__functionname, // Flash source address
    497                                (int)&__size__functionname); // Code size of the function
    498          
    499           - For IAR Compiler:
    500              1- Use the __ramfunc keyword in the function declaration to specify that it 
    501              can be executed from RAM.
    502              This is done within the stm8s_flash.c file, and it's conditioned by 
    503              RAM_EXECUTION definition.
    504              2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8s.h file, or 
    505             define it in IAR compiler preprocessor to enable the access for the 
    506             __ramfunc functions.
    507          
    508           - Note: 
    509              1- Ignore the IAR compiler warnings, these warnings don't impact the FLASH Program/Erase
    510              operations.
    511              The code performing the Flash Program/erase must be executed from RAM; the variables
    512              initializations don't necessary require the execution from RAM, only CR2/NCR2 registers 
    513              configuration and data programing must be executed from RAM.
    514              2- These warnings depends on IAR compiler: as the code generation is made using many
    515              runtime library functions to keep code size to a minimum.
    516              3- It is recommended to use High Speed Optimization with IAR (-Ohs), in order 
    517              to reduce the runtime library calls in the generated code.
    518          
    519          
    520          
    521           The FLASH examples given within the STM8S_StdPeriph_Lib package, details all 
    522           the steps described above.
    523          
    524          @endcode
    525          */
    526          
    527          /**
    528            * @brief
    529            *******************************************************************************
    530            *                         Execution from RAM enable
    531            *******************************************************************************
    532            *
    533            * To enable execution from RAM you can either uncomment the following define 
    534            * in the stm8s.h file or define it in your toolchain compiler preprocessor
    535            * - #define RAM_EXECUTION  (1) 
    536            */
    537            
    538          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    539           #pragma section (FLASH_CODE)
    540          #endif  /* _COSMIC_ && RAM_EXECUTION */
    541          /**
    542            * @brief  Wait for a Flash operation to complete.
    543            * @note   The call and execution of this function must be done from RAM in case
    544            *         of Block operation.
    545            * @param  FLASH_MemType : Memory type
    546            *         This parameter can be a value of @ref FLASH_MemType_TypeDef
    547            * @retval FLASH status
    548            */

   \                                 In section .far_func.text, align 1
    549          IN_RAM(FLASH_Status_TypeDef FLASH_WaitForLastOperation(FLASH_MemType_TypeDef FLASH_MemType)) 
    550          {
   \                     FLASH_WaitForLastOperation:
   \   000000 B7 ..        LD        S:?b1, A
    551            uint8_t flagstatus = 0x00;
   \   000002 3F ..        CLR       S:?b0
    552            uint16_t timeout = OPERATION_TIMEOUT;
   \   000004 5F           CLRW      X
   \   000005 5A           DECW      X
    553            
    554            /* Wait until operation completion or write protection page occurred */
    555          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined(STM8S105) || \
    556              defined (STM8S005) || defined(STM8AF52Ax) || defined(STM8AF62Ax) || defined(STM8AF626x)  
    557              if(FLASH_MemType == FLASH_MEMTYPE_PROG)
   \   000006 B6 ..        LD        A, S:?b1
   \   000008 A1 FD        CP        A, #0xfd
   \   00000A 26 11        JRNE      L:??FLASH_WaitForLastOperation_0
    558              {
    559                while((flagstatus == 0x00) && (timeout != 0x00))
   \                     ??FLASH_WaitForLastOperation_1:
   \   00000C 3D ..        TNZ       S:?b0
   \   00000E 26 1E        JRNE      L:??FLASH_WaitForLastOperation_2
   \   000010 5D           TNZW      X
   \   000011 27 1B        JREQ      L:??FLASH_WaitForLastOperation_2
    560                {
    561                  flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_EOP |
    562                                                                  FLASH_IAPSR_WR_PG_DIS));
   \   000013 C6 505F      LD        A, L:0x505f
   \   000016 A4 05        AND       A, #0x5
   \   000018 B7 ..        LD        S:?b0, A
    563                  timeout--;
   \   00001A 5A           DECW      X
   \   00001B 20 EF        JRA       L:??FLASH_WaitForLastOperation_1
    564                }
    565              }
    566              else
    567              {
    568                while((flagstatus == 0x00) && (timeout != 0x00))
   \                     ??FLASH_WaitForLastOperation_0:
   \   00001D 3D ..        TNZ       S:?b0
   \   00001F 26 0D        JRNE      L:??FLASH_WaitForLastOperation_2
   \   000021 5D           TNZW      X
   \   000022 27 0A        JREQ      L:??FLASH_WaitForLastOperation_2
    569                {
    570                  flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_HVOFF |
    571                                                                  FLASH_IAPSR_WR_PG_DIS));
   \   000024 C6 505F      LD        A, L:0x505f
   \   000027 A4 41        AND       A, #0x41
   \   000029 B7 ..        LD        S:?b0, A
    572                  timeout--;
   \   00002B 5A           DECW      X
   \   00002C 20 EF        JRA       L:??FLASH_WaitForLastOperation_0
    573                }
    574              }
    575          #else /*STM8S103, STM8S001, STM8S903, STM8AF622x */
    576            UNUSED(FLASH_MemType);
    577            while((flagstatus == 0x00) && (timeout != 0x00))
    578            {
    579              flagstatus = (uint8_t)(FLASH->IAPSR & (FLASH_IAPSR_EOP | FLASH_IAPSR_WR_PG_DIS));
    580              timeout--;
    581            }
    582          #endif /* STM8S208, STM8S207, STM8S105, STM8AF52Ax, STM8AF62Ax, STM8AF262x */
    583            
    584            if(timeout == 0x00 )
   \                     ??FLASH_WaitForLastOperation_2:
   \   00002E 5D           TNZW      X
   \   00002F 26 04        JRNE      L:??FLASH_WaitForLastOperation_3
    585            {
    586              flagstatus = FLASH_STATUS_TIMEOUT;
   \   000031 A6 02        LD        A, #0x2
   \   000033 B7 ..        LD        S:?b0, A
    587            }
    588            
    589            return((FLASH_Status_TypeDef)flagstatus);
   \                     ??FLASH_WaitForLastOperation_3:
   \   000035 B6 ..        LD        A, S:?b0
   \   000037 87           RETF
    590          }
    591          
    592          /**
    593            * @brief  Erases a block in the program or data memory.
    594            * @note   This function should be executed from RAM.
    595            * @param  FLASH_MemType :  The type of memory to erase
    596            * @param  BlockNum : Indicates the block number to erase
    597            * @retval None.
    598            */

   \                                 In section .far_func.text, align 1
    599          IN_RAM(void FLASH_EraseBlock(uint16_t BlockNum, FLASH_MemType_TypeDef FLASH_MemType))
    600          {
   \                     FLASH_EraseBlock:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w7
   \   000008 3B ....      PUSH      S:?b12
   \   00000B 52 02        SUB       SP, #0x2
   \   00000D BF ..        LDW       S:?w7, X
   \   00000F B7 ..        LD        S:?b12, A
    601            uint32_t startaddress = 0;
   \   000011 5F           CLRW      X
   \   000012 BF ..        LDW       S:?w5, X
   \   000014 BF ..        LDW       S:?w4, X
    602            
    603          #if defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) || \
    604              defined(STM8S001) || defined(STM8S903) || defined (STM8AF626x) || defined (STM8AF622x)
    605              uint32_t PointerAttr  *pwFlash;
    606          #elif defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || defined (STM8AF52Ax) 
    607            uint8_t PointerAttr  *pwFlash;
    608          #endif
    609            
    610            /* Check parameters */
    611            assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000016 B6 ..        LD        A, S:?b12
   \   000018 A1 FD        CP        A, #0xfd
   \   00001A 27 15        JREQ      L:??FLASH_EraseBlock_0
   \   00001C B6 ..        LD        A, S:?b12
   \   00001E A1 F7        CP        A, #0xf7
   \   000020 27 0F        JREQ      L:??FLASH_EraseBlock_0
   \   000022 AE 0263      LDW       X, #0x263
   \   000025 BF ..        LDW       S:?w1, X
   \   000027 5F           CLRW      X
   \   000028 BF ..        LDW       S:?w0, X
   \   00002A AE ....      LDW       X, #?_0
   \   00002D 8D ......    CALLF     assert_failed
    612            if(FLASH_MemType == FLASH_MEMTYPE_PROG)
   \                     ??FLASH_EraseBlock_0:
   \   000031 B6 ..        LD        A, S:?b12
   \   000033 A1 FD        CP        A, #0xfd
   \   000035 26 24        JRNE      L:??FLASH_EraseBlock_1
    613            {
    614              assert_param(IS_FLASH_PROG_BLOCK_NUMBER_OK(BlockNum));
   \   000037 BE ..        LDW       X, S:?w7
   \   000039 A3 0100      CPW       X, #0x100
   \   00003C 25 0F        JRC       L:??FLASH_EraseBlock_2
   \   00003E AE 0266      LDW       X, #0x266
   \   000041 BF ..        LDW       S:?w1, X
   \   000043 5F           CLRW      X
   \   000044 BF ..        LDW       S:?w0, X
   \   000046 AE ....      LDW       X, #?_0
   \   000049 8D ......    CALLF     assert_failed
    615              startaddress = FLASH_PROG_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_EraseBlock_2:
   \   00004D AE 8000      LDW       X, #0x8000
   \   000050 BF ..        LDW       S:?w1, X
   \   000052 58           SLLW      X
   \   000053 BF ..        LDW       S:?w0, X
   \   000055 8D ......    CALLF     L:?mov_l2_l0
   \   000059 20 22        JRA       L:??FLASH_EraseBlock_3
    616            }
    617            else
    618            {
    619              assert_param(IS_FLASH_DATA_BLOCK_NUMBER_OK(BlockNum));
   \                     ??FLASH_EraseBlock_1:
   \   00005B BE ..        LDW       X, S:?w7
   \   00005D A3 0008      CPW       X, #0x8
   \   000060 25 0F        JRC       L:??FLASH_EraseBlock_4
   \   000062 AE 026B      LDW       X, #0x26b
   \   000065 BF ..        LDW       S:?w1, X
   \   000067 5F           CLRW      X
   \   000068 BF ..        LDW       S:?w0, X
   \   00006A AE ....      LDW       X, #?_0
   \   00006D 8D ......    CALLF     assert_failed
    620              startaddress = FLASH_DATA_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_EraseBlock_4:
   \   000071 AE 4000      LDW       X, #0x4000
   \   000074 BF ..        LDW       S:?w1, X
   \   000076 5F           CLRW      X
   \   000077 BF ..        LDW       S:?w0, X
   \   000079 8D ......    CALLF     L:?mov_l2_l0
    621            }
    622            
    623            /* Point to the first block address */
    624          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || defined (STM8AF52Ax)
    625            pwFlash = (PointerAttr uint8_t *)(MemoryAddressCast)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
    626          #elif defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) || \
    627                defined(STM8S001) || defined (STM8S903) || defined (STM8AF626x) || defined (STM8AF622x)
    628              pwFlash = (PointerAttr uint32_t *)(MemoryAddressCast)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
   \                     ??FLASH_EraseBlock_3:
   \   00007D AE 0080      LDW       X, #0x80
   \   000080 BF ..        LDW       S:?w0, X
   \   000082 BE ..        LDW       X, S:?w7
   \   000084 8D ......    CALLF     L:?mul16_x_x_w0
   \   000088 BF ..        LDW       S:?w1, X
   \   00008A BE ..        LDW       X, S:?w5
   \   00008C 72BB ....    ADDW      X, S:?w1
   \   000090 1F 01        LDW       (0x1,SP), X
    629          #endif	/* STM8S208, STM8S207 */
    630            
    631            /* Enable erase block mode */
    632            FLASH->CR2 |= FLASH_CR2_ERASE;
   \   000092 721A 505B    BSET      L:0x505b, #0x5
    633            FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NERASE);
   \   000096 721B 505C    BRES      L:0x505c, #0x5
    634            
    635          #if defined(STM8S105) || defined(STM8S005) || defined(STM8S103) || defined(STM8S003) ||  \
    636              defined(STM8S001) || defined(STM8S903) || defined (STM8AF626x) || defined (STM8AF622x)
    637              *pwFlash = (uint32_t)0;
   \   00009A 1E 01        LDW       X, (0x1,SP)
   \   00009C 9093         LDW       Y, X
   \   00009E 5F           CLRW      X
   \   00009F BF ..        LDW       S:?w1, X
   \   0000A1 BF ..        LDW       S:?w0, X
   \   0000A3 93           LDW       X, Y
   \   0000A4 8D ......    CALLF     L:?load32_0x_l0
    638          #elif defined (STM8S208) || defined(STM8S207) || defined(STM8S007) || defined (STM8AF62Ax) || \
    639            defined (STM8AF52Ax)
    640              *pwFlash = (uint8_t)0;
    641            *(pwFlash + 1) = (uint8_t)0;
    642            *(pwFlash + 2) = (uint8_t)0;
    643            *(pwFlash + 3) = (uint8_t)0;    
    644          #endif
    645          }
   \   0000A8 5B 02        ADD       SP, #0x2
   \   0000AA 32 ....      POP       S:?b12
   \   0000AD 8D ......    CALLF     L:?pop_w7
   \   0000B1 AC ......    JPF       L:?epilogue_l2
    646          
    647          /**
    648            * @brief  Programs a memory block
    649            * @note   This function should be executed from RAM.
    650            * @param  FLASH_MemType : The type of memory to program
    651            * @param  BlockNum : The block number
    652            * @param  FLASH_ProgMode : The programming mode.
    653            * @param  Buffer : Pointer to buffer containing source data.
    654            * @retval None.
    655            */

   \                                 In section .far_func.text, align 1
    656          IN_RAM(void FLASH_ProgramBlock(uint16_t BlockNum, FLASH_MemType_TypeDef FLASH_MemType, 
    657                                  FLASH_ProgramMode_TypeDef FLASH_ProgMode, uint8_t *Buffer))
    658          {
   \                     FLASH_ProgramBlock:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 89           PUSHW     X
   \   000009 9089         PUSHW     Y
   \   00000B B7 ..        LD        S:?b15, A
   \   00000D 45 .. ..     MOV       S:?b14, S:?b0
    659            uint16_t Count = 0;
   \   000010 3F ..        CLR       S:?b13
   \   000012 3F ..        CLR       S:?b12
    660            uint32_t startaddress = 0;
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w5, X
   \   000017 BF ..        LDW       S:?w4, X
    661            
    662            /* Check parameters */
    663            assert_param(IS_MEMORY_TYPE_OK(FLASH_MemType));
   \   000019 B6 ..        LD        A, S:?b15
   \   00001B A1 FD        CP        A, #0xfd
   \   00001D 27 15        JREQ      L:??FLASH_ProgramBlock_0
   \   00001F B6 ..        LD        A, S:?b15
   \   000021 A1 F7        CP        A, #0xf7
   \   000023 27 0F        JREQ      L:??FLASH_ProgramBlock_0
   \   000025 AE 0297      LDW       X, #0x297
   \   000028 BF ..        LDW       S:?w1, X
   \   00002A 5F           CLRW      X
   \   00002B BF ..        LDW       S:?w0, X
   \   00002D AE ....      LDW       X, #?_0
   \   000030 8D ......    CALLF     assert_failed
    664            assert_param(IS_FLASH_PROGRAM_MODE_OK(FLASH_ProgMode));
   \                     ??FLASH_ProgramBlock_0:
   \   000034 3D ..        TNZ       S:?b14
   \   000036 27 15        JREQ      L:??FLASH_ProgramBlock_1
   \   000038 B6 ..        LD        A, S:?b14
   \   00003A A1 10        CP        A, #0x10
   \   00003C 27 0F        JREQ      L:??FLASH_ProgramBlock_1
   \   00003E AE 0298      LDW       X, #0x298
   \   000041 BF ..        LDW       S:?w1, X
   \   000043 5F           CLRW      X
   \   000044 BF ..        LDW       S:?w0, X
   \   000046 AE ....      LDW       X, #?_0
   \   000049 8D ......    CALLF     assert_failed
    665            if(FLASH_MemType == FLASH_MEMTYPE_PROG)
   \                     ??FLASH_ProgramBlock_1:
   \   00004D B6 ..        LD        A, S:?b15
   \   00004F A1 FD        CP        A, #0xfd
   \   000051 26 24        JRNE      L:??FLASH_ProgramBlock_2
    666            {
    667              assert_param(IS_FLASH_PROG_BLOCK_NUMBER_OK(BlockNum));
   \   000053 1E 03        LDW       X, (0x3,SP)
   \   000055 A3 0100      CPW       X, #0x100
   \   000058 25 0F        JRC       L:??FLASH_ProgramBlock_3
   \   00005A AE 029B      LDW       X, #0x29b
   \   00005D BF ..        LDW       S:?w1, X
   \   00005F 5F           CLRW      X
   \   000060 BF ..        LDW       S:?w0, X
   \   000062 AE ....      LDW       X, #?_0
   \   000065 8D ......    CALLF     assert_failed
    668              startaddress = FLASH_PROG_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_ProgramBlock_3:
   \   000069 AE 8000      LDW       X, #0x8000
   \   00006C BF ..        LDW       S:?w1, X
   \   00006E 58           SLLW      X
   \   00006F BF ..        LDW       S:?w0, X
   \   000071 8D ......    CALLF     L:?mov_l2_l0
   \   000075 20 22        JRA       L:??FLASH_ProgramBlock_4
    669            }
    670            else
    671            {
    672              assert_param(IS_FLASH_DATA_BLOCK_NUMBER_OK(BlockNum));
   \                     ??FLASH_ProgramBlock_2:
   \   000077 1E 03        LDW       X, (0x3,SP)
   \   000079 A3 0008      CPW       X, #0x8
   \   00007C 25 0F        JRC       L:??FLASH_ProgramBlock_5
   \   00007E AE 02A0      LDW       X, #0x2a0
   \   000081 BF ..        LDW       S:?w1, X
   \   000083 5F           CLRW      X
   \   000084 BF ..        LDW       S:?w0, X
   \   000086 AE ....      LDW       X, #?_0
   \   000089 8D ......    CALLF     assert_failed
    673              startaddress = FLASH_DATA_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_ProgramBlock_5:
   \   00008D AE 4000      LDW       X, #0x4000
   \   000090 BF ..        LDW       S:?w1, X
   \   000092 5F           CLRW      X
   \   000093 BF ..        LDW       S:?w0, X
   \   000095 8D ......    CALLF     L:?mov_l2_l0
    674            }
    675            
    676            /* Point to the first block address */
    677            startaddress = startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE);
   \                     ??FLASH_ProgramBlock_4:
   \   000099 1E 03        LDW       X, (0x3,SP)
   \   00009B BF ..        LDW       S:?w1, X
   \   00009D 5F           CLRW      X
   \   00009E BF ..        LDW       S:?w0, X
   \   0000A0 AE 0080      LDW       X, #0x80
   \   0000A3 BF ..        LDW       S:?w3, X
   \   0000A5 5F           CLRW      X
   \   0000A6 BF ..        LDW       S:?w2, X
   \   0000A8 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   0000AC 8D ......    CALLF     L:?mov_l1_l0
   \   0000B0 8D ......    CALLF     L:?mov_l0_l2
   \   0000B4 8D ......    CALLF     L:?add32_l0_l0_l1
   \   0000B8 8D ......    CALLF     L:?mov_l2_l0
    678            
    679            /* Selection of Standard or Fast programming mode */
    680            if(FLASH_ProgMode == FLASH_PROGRAMMODE_STANDARD)
   \   0000BC 3D ..        TNZ       S:?b14
   \   0000BE 26 0A        JRNE      L:??FLASH_ProgramBlock_6
    681            {
    682              /* Standard programming mode */ /*No need in standard mode */
    683              FLASH->CR2 |= FLASH_CR2_PRG;
   \   0000C0 7210 505B    BSET      L:0x505b, #0x0
    684              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NPRG);
   \   0000C4 7211 505C    BRES      L:0x505c, #0x0
   \   0000C8 20 08        JRA       L:??FLASH_ProgramBlock_7
    685            }
    686            else
    687            {
    688              /* Fast programming mode */
    689              FLASH->CR2 |= FLASH_CR2_FPRG;
   \                     ??FLASH_ProgramBlock_6:
   \   0000CA 7218 505B    BSET      L:0x505b, #0x4
    690              FLASH->NCR2 &= (uint8_t)(~FLASH_NCR2_NFPRG);
   \   0000CE 7219 505C    BRES      L:0x505c, #0x4
    691            }
    692            
    693            /* Copy data bytes from RAM to FLASH memory */
    694            for(Count = 0; Count < FLASH_BLOCK_SIZE; Count++)
   \                     ??FLASH_ProgramBlock_7:
   \   0000D2 5F           CLRW      X
   \   0000D3 BF ..        LDW       S:?w6, X
   \                     ??FLASH_ProgramBlock_8:
   \   0000D5 BE ..        LDW       X, S:?w6
   \   0000D7 A3 0080      CPW       X, #0x80
   \   0000DA 24 17        JRNC      L:??FLASH_ProgramBlock_9
    695            {
    696              *((PointerAttr uint8_t*) (MemoryAddressCast)startaddress + Count) = ((uint8_t)(Buffer[Count]));
   \   0000DC BE ..        LDW       X, S:?w5
   \   0000DE 72BB ....    ADDW      X, S:?w6
   \   0000E2 9093         LDW       Y, X
   \   0000E4 BE ..        LDW       X, S:?w6
   \   0000E6 72FB 01      ADDW      X, (0x1,SP)
   \   0000E9 F6           LD        A, (X)
   \   0000EA 90F7         LD        (Y), A
    697            }
   \   0000EC BE ..        LDW       X, S:?w6
   \   0000EE 5C           INCW      X
   \   0000EF BF ..        LDW       S:?w6, X
   \   0000F1 20 E2        JRA       L:??FLASH_ProgramBlock_8
    698          }
   \                     ??FLASH_ProgramBlock_9:
   \   0000F3 5B 04        ADD       SP, #0x4
   \   0000F5 AC ......    JPF       L:?epilogue_l2_l3

   \                                 In section .near.rodata, align 1
   \                     ?_0:
   \   000000 2E 5C 4C 69  DC8 ".\\Lib\\C\\stm8s_flash.c"
   \          62 5C 43 5C 
    699          
    700          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    701           /* End of FLASH_CODE section */
    702           #pragma section ()
    703          #endif /* _COSMIC_ && RAM_EXECUTION */
    704          
    705          /**
    706            * @}
    707            */
    708            
    709          /**
    710            * @}
    711            */
    712          
    713          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      22  ?_0
      24  FLASH_DeInit
     181  FLASH_EraseBlock
      86  FLASH_EraseByte
      82  FLASH_EraseOptionByte
      70  FLASH_GetBootSize
      76  FLASH_GetFlagStatus
       6  FLASH_GetLowPowerMode
       6  FLASH_GetProgrammingTime
      48  FLASH_ITConfig
      44  FLASH_Lock
     249  FLASH_ProgramBlock
      96  FLASH_ProgramByte
      95  FLASH_ProgramOptionByte
     126  FLASH_ProgramWord
      86  FLASH_ReadByte
     112  FLASH_ReadOptionByte
      62  FLASH_SetLowPowerMode
      46  FLASH_SetProgrammingTime
      60  FLASH_Unlock
      56  FLASH_WaitForLastOperation

 
 1 611 bytes in section .far_func.text
    22 bytes in section .near.rodata
 
 1 611 bytes of CODE  memory
    22 bytes of CONST memory

Errors: none
Warnings: none
