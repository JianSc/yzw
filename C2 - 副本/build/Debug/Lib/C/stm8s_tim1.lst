###############################################################################
#
# IAR C/C++ Compiler V3.11.1.207 for STM8                 09/Jan/2024  17:40:23
# Copyright 2010-2019 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for STMicroelectronics STM8
#
#    Source file  =  .\Lib\C\stm8s_tim1.c
#    Command line =  
#        -f
#        "e:\Nas\电路\保温箱\YZW-S8-EE22(Rev1.0)\C\build\Debug\Lib\C\stm8s_tim1.args.txt"
#        (--silent -lCN .\build\Debug\Lib\C\stm8s_tim1.lst -I d:/IAR/STM8 -I
#        d:/IAR/STM8/stm8/lib -I Lib/H -I Lib/C -I User -D STM8S003
#        --data_model medium --code_model medium --dlib_config dlstm8smn.h -e
#        --vregs 16 -On --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_cross_call --debug --dependencies=m + -o
#        .\build\Debug\Lib\C\stm8s_tim1.o .\Lib\C\stm8s_tim1.c)
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  .\build\Debug\Lib\C\stm8s_tim1.lst
#    Object file  =  .\build\Debug\Lib\C\stm8s_tim1.o
#
###############################################################################

e:\Nas\电路\保温箱\YZW-S8-EE22(Rev1.0)\C\Lib\C\stm8s_tim1.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_tim1.c
      4            * @author  MCD Application Team
      5            * @version V2.3.0
      6            * @date    16-June-2017
      7            * @brief   This file contains all the functions for the TIM1 peripheral.
      8             ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "stm8s_tim1.h"
     30          
     31          /** @addtogroup STM8S_StdPeriph_Driver
     32            * @{
     33            */
     34          /* Private typedef -----------------------------------------------------------*/
     35          /* Private define ------------------------------------------------------------*/
     36          /* Private macro -------------------------------------------------------------*/
     37          /* Private variables ---------------------------------------------------------*/
     38          /* Private function prototypes -----------------------------------------------*/
     39          static void TI1_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
     40                                 uint8_t TIM1_ICFilter);
     41          static void TI2_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
     42                                 uint8_t TIM1_ICFilter);
     43          static void TI3_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
     44                                 uint8_t TIM1_ICFilter);
     45          static void TI4_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
     46                                 uint8_t TIM1_ICFilter);
     47          
     48          /**
     49            * @addtogroup TIM1_Public_Functions
     50            * @{
     51            */
     52          
     53          /**
     54            * @brief  Deinitializes the TIM1 peripheral registers to their default reset values.
     55            * @param  None
     56            * @retval None
     57            */

   \                                 In section .far_func.text, align 1
     58          void TIM1_DeInit(void)
     59          {
     60            TIM1->CR1  = TIM1_CR1_RESET_VALUE;
   \                     TIM1_DeInit:
   \   000000 725F 5250    CLR       L:0x5250
     61            TIM1->CR2  = TIM1_CR2_RESET_VALUE;
   \   000004 725F 5251    CLR       L:0x5251
     62            TIM1->SMCR = TIM1_SMCR_RESET_VALUE;
   \   000008 725F 5252    CLR       L:0x5252
     63            TIM1->ETR  = TIM1_ETR_RESET_VALUE;
   \   00000C 725F 5253    CLR       L:0x5253
     64            TIM1->IER  = TIM1_IER_RESET_VALUE;
   \   000010 725F 5254    CLR       L:0x5254
     65            TIM1->SR2  = TIM1_SR2_RESET_VALUE;
   \   000014 725F 5256    CLR       L:0x5256
     66            /* Disable channels */
     67            TIM1->CCER1 = TIM1_CCER1_RESET_VALUE;
   \   000018 725F 525C    CLR       L:0x525c
     68            TIM1->CCER2 = TIM1_CCER2_RESET_VALUE;
   \   00001C 725F 525D    CLR       L:0x525d
     69            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
     70            TIM1->CCMR1 = 0x01;
   \   000020 35 01 5258   MOV       L:0x5258, #0x1
     71            TIM1->CCMR2 = 0x01;
   \   000024 35 01 5259   MOV       L:0x5259, #0x1
     72            TIM1->CCMR3 = 0x01;
   \   000028 35 01 525A   MOV       L:0x525a, #0x1
     73            TIM1->CCMR4 = 0x01;
   \   00002C 35 01 525B   MOV       L:0x525b, #0x1
     74            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
     75            TIM1->CCER1 = TIM1_CCER1_RESET_VALUE;
   \   000030 725F 525C    CLR       L:0x525c
     76            TIM1->CCER2 = TIM1_CCER2_RESET_VALUE;
   \   000034 725F 525D    CLR       L:0x525d
     77            TIM1->CCMR1 = TIM1_CCMR1_RESET_VALUE;
   \   000038 725F 5258    CLR       L:0x5258
     78            TIM1->CCMR2 = TIM1_CCMR2_RESET_VALUE;
   \   00003C 725F 5259    CLR       L:0x5259
     79            TIM1->CCMR3 = TIM1_CCMR3_RESET_VALUE;
   \   000040 725F 525A    CLR       L:0x525a
     80            TIM1->CCMR4 = TIM1_CCMR4_RESET_VALUE;
   \   000044 725F 525B    CLR       L:0x525b
     81            TIM1->CNTRH = TIM1_CNTRH_RESET_VALUE;
   \   000048 725F 525E    CLR       L:0x525e
     82            TIM1->CNTRL = TIM1_CNTRL_RESET_VALUE;
   \   00004C 725F 525F    CLR       L:0x525f
     83            TIM1->PSCRH = TIM1_PSCRH_RESET_VALUE;
   \   000050 725F 5260    CLR       L:0x5260
     84            TIM1->PSCRL = TIM1_PSCRL_RESET_VALUE;
   \   000054 725F 5261    CLR       L:0x5261
     85            TIM1->ARRH  = TIM1_ARRH_RESET_VALUE;
   \   000058 35 FF 5262   MOV       L:0x5262, #0xff
     86            TIM1->ARRL  = TIM1_ARRL_RESET_VALUE;
   \   00005C 35 FF 5263   MOV       L:0x5263, #0xff
     87            TIM1->CCR1H = TIM1_CCR1H_RESET_VALUE;
   \   000060 725F 5265    CLR       L:0x5265
     88            TIM1->CCR1L = TIM1_CCR1L_RESET_VALUE;
   \   000064 725F 5266    CLR       L:0x5266
     89            TIM1->CCR2H = TIM1_CCR2H_RESET_VALUE;
   \   000068 725F 5267    CLR       L:0x5267
     90            TIM1->CCR2L = TIM1_CCR2L_RESET_VALUE;
   \   00006C 725F 5268    CLR       L:0x5268
     91            TIM1->CCR3H = TIM1_CCR3H_RESET_VALUE;
   \   000070 725F 5269    CLR       L:0x5269
     92            TIM1->CCR3L = TIM1_CCR3L_RESET_VALUE;
   \   000074 725F 526A    CLR       L:0x526a
     93            TIM1->CCR4H = TIM1_CCR4H_RESET_VALUE;
   \   000078 725F 526B    CLR       L:0x526b
     94            TIM1->CCR4L = TIM1_CCR4L_RESET_VALUE;
   \   00007C 725F 526C    CLR       L:0x526c
     95            TIM1->OISR  = TIM1_OISR_RESET_VALUE;
   \   000080 725F 526F    CLR       L:0x526f
     96            TIM1->EGR   = 0x01; /* TIM1_EGR_UG */
   \   000084 35 01 5257   MOV       L:0x5257, #0x1
     97            TIM1->DTR   = TIM1_DTR_RESET_VALUE;
   \   000088 725F 526E    CLR       L:0x526e
     98            TIM1->BKR   = TIM1_BKR_RESET_VALUE;
   \   00008C 725F 526D    CLR       L:0x526d
     99            TIM1->RCR   = TIM1_RCR_RESET_VALUE;
   \   000090 725F 5264    CLR       L:0x5264
    100            TIM1->SR1   = TIM1_SR1_RESET_VALUE;
   \   000094 725F 5255    CLR       L:0x5255
    101          }
   \   000098 87           RETF
    102          
    103          /**
    104            * @brief  Initializes the TIM1 Time Base Unit according to the specified parameters.
    105            * @param  TIM1_Prescaler specifies the Prescaler value.
    106            * @param  TIM1_CounterMode specifies the counter mode  from @ref TIM1_CounterMode_TypeDef .
    107            * @param  TIM1_Period specifies the Period value.
    108            * @param  TIM1_RepetitionCounter specifies the Repetition counter value
    109            * @retval None
    110            */

   \                                 In section .far_func.text, align 1
    111          void TIM1_TimeBaseInit(uint16_t TIM1_Prescaler,
    112                                 TIM1_CounterMode_TypeDef TIM1_CounterMode,
    113                                 uint16_t TIM1_Period,
    114                                 uint8_t TIM1_RepetitionCounter)
    115          {
   \                     TIM1_TimeBaseInit:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 BF ..        LDW       S:?w6, X
   \   00000A B7 ..        LD        S:?b8, A
   \   00000C 90BF ..      LDW       S:?w5, Y
   \   00000F 45 .. ..     MOV       S:?b9, S:?b0
    116            /* Check parameters */
    117            assert_param(IS_TIM1_COUNTER_MODE_OK(TIM1_CounterMode));
   \   000012 3D ..        TNZ       S:?b8
   \   000014 27 27        JREQ      L:??TIM1_TimeBaseInit_0
   \   000016 B6 ..        LD        A, S:?b8
   \   000018 A1 10        CP        A, #0x10
   \   00001A 27 21        JREQ      L:??TIM1_TimeBaseInit_0
   \   00001C B6 ..        LD        A, S:?b8
   \   00001E A1 20        CP        A, #0x20
   \   000020 27 1B        JREQ      L:??TIM1_TimeBaseInit_0
   \   000022 B6 ..        LD        A, S:?b8
   \   000024 A1 40        CP        A, #0x40
   \   000026 27 15        JREQ      L:??TIM1_TimeBaseInit_0
   \   000028 B6 ..        LD        A, S:?b8
   \   00002A A1 60        CP        A, #0x60
   \   00002C 27 0F        JREQ      L:??TIM1_TimeBaseInit_0
   \   00002E AE 0075      LDW       X, #0x75
   \   000031 BF ..        LDW       S:?w1, X
   \   000033 5F           CLRW      X
   \   000034 BF ..        LDW       S:?w0, X
   \   000036 AE ....      LDW       X, #?_0
   \   000039 8D ......    CALLF     assert_failed
    118            
    119            /* Set the Autoreload value */
    120            TIM1->ARRH = (uint8_t)(TIM1_Period >> 8);
   \                     ??TIM1_TimeBaseInit_0:
   \   00003D B6 ..        LD        A, S:?b10
   \   00003F C7 5262      LD        L:0x5262, A
    121            TIM1->ARRL = (uint8_t)(TIM1_Period);
   \   000042 B6 ..        LD        A, S:?b11
   \   000044 C7 5263      LD        L:0x5263, A
    122            
    123            /* Set the Prescaler value */
    124            TIM1->PSCRH = (uint8_t)(TIM1_Prescaler >> 8);
   \   000047 B6 ..        LD        A, S:?b12
   \   000049 C7 5260      LD        L:0x5260, A
    125            TIM1->PSCRL = (uint8_t)(TIM1_Prescaler);
   \   00004C B6 ..        LD        A, S:?b13
   \   00004E C7 5261      LD        L:0x5261, A
    126            
    127            /* Select the Counter Mode */
    128            TIM1->CR1 = (uint8_t)((uint8_t)(TIM1->CR1 & (uint8_t)(~(TIM1_CR1_CMS | TIM1_CR1_DIR)))
    129                                  | (uint8_t)(TIM1_CounterMode));
   \   000051 C6 5250      LD        A, L:0x5250
   \   000054 A4 8F        AND       A, #0x8f
   \   000056 BA ..        OR        A, S:?b8
   \   000058 C7 5250      LD        L:0x5250, A
    130            
    131            /* Set the Repetition Counter value */
    132            TIM1->RCR = TIM1_RepetitionCounter;
   \   00005B B6 ..        LD        A, S:?b9
   \   00005D C7 5264      LD        L:0x5264, A
    133          }
   \   000060 AC ......    JPF       L:?epilogue_l2_w6
    134          
    135          /**
    136            * @brief  Initializes the TIM1 Channel1 according to the specified parameters.
    137            * @param  TIM1_OCMode specifies the Output Compare mode from 
    138            *         @ref TIM1_OCMode_TypeDef.
    139            * @param  TIM1_OutputState specifies the Output State from 
    140            *         @ref TIM1_OutputState_TypeDef.
    141            * @param  TIM1_OutputNState specifies the Complementary Output State 
    142            *         from @ref TIM1_OutputNState_TypeDef.
    143            * @param  TIM1_Pulse specifies the Pulse width value.
    144            * @param  TIM1_OCPolarity specifies the Output Compare Polarity from 
    145            *         @ref TIM1_OCPolarity_TypeDef.
    146            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare Polarity
    147            *         from @ref TIM1_OCNPolarity_TypeDef.
    148            * @param  TIM1_OCIdleState specifies the Output Compare Idle State from 
    149            *         @ref TIM1_OCIdleState_TypeDef.
    150            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle 
    151            *         State from @ref TIM1_OCIdleState_TypeDef.
    152            * @retval None
    153            */

   \                                 In section .far_func.text, align 1
    154          void TIM1_OC1Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    155                            TIM1_OutputState_TypeDef TIM1_OutputState,
    156                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    157                            uint16_t TIM1_Pulse,
    158                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    159                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    160                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    161                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    162          {
   \                     TIM1_OC1Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 3B ....      PUSH      S:?b14
   \   00000B 89           PUSHW     X
   \   00000C B7 ..        LD        S:?b8, A
   \   00000E 45 .. ..     MOV       S:?b14, S:?b0
   \   000011 45 .. ..     MOV       S:?b13, S:?b1
   \   000014 45 .. ..     MOV       S:?b12, S:?b2
   \   000017 45 .. ..     MOV       S:?b9, S:?b3
   \   00001A 45 .. ..     MOV       S:?b10, S:?b4
   \   00001D 45 .. ..     MOV       S:?b11, S:?b5
    163            /* Check the parameters */
    164            assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
   \   000020 3D ..        TNZ       S:?b8
   \   000022 27 2D        JREQ      L:??TIM1_OC1Init_0
   \   000024 B6 ..        LD        A, S:?b8
   \   000026 A1 10        CP        A, #0x10
   \   000028 27 27        JREQ      L:??TIM1_OC1Init_0
   \   00002A B6 ..        LD        A, S:?b8
   \   00002C A1 20        CP        A, #0x20
   \   00002E 27 21        JREQ      L:??TIM1_OC1Init_0
   \   000030 B6 ..        LD        A, S:?b8
   \   000032 A1 30        CP        A, #0x30
   \   000034 27 1B        JREQ      L:??TIM1_OC1Init_0
   \   000036 B6 ..        LD        A, S:?b8
   \   000038 A1 60        CP        A, #0x60
   \   00003A 27 15        JREQ      L:??TIM1_OC1Init_0
   \   00003C B6 ..        LD        A, S:?b8
   \   00003E A1 70        CP        A, #0x70
   \   000040 27 0F        JREQ      L:??TIM1_OC1Init_0
   \   000042 AE 00A4      LDW       X, #0xa4
   \   000045 BF ..        LDW       S:?w1, X
   \   000047 5F           CLRW      X
   \   000048 BF ..        LDW       S:?w0, X
   \   00004A AE ....      LDW       X, #?_0
   \   00004D 8D ......    CALLF     assert_failed
    165            assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
   \                     ??TIM1_OC1Init_0:
   \   000051 3D ..        TNZ       S:?b14
   \   000053 27 15        JREQ      L:??TIM1_OC1Init_1
   \   000055 B6 ..        LD        A, S:?b14
   \   000057 A1 11        CP        A, #0x11
   \   000059 27 0F        JREQ      L:??TIM1_OC1Init_1
   \   00005B AE 00A5      LDW       X, #0xa5
   \   00005E BF ..        LDW       S:?w1, X
   \   000060 5F           CLRW      X
   \   000061 BF ..        LDW       S:?w0, X
   \   000063 AE ....      LDW       X, #?_0
   \   000066 8D ......    CALLF     assert_failed
    166            assert_param(IS_TIM1_OUTPUTN_STATE_OK(TIM1_OutputNState));
   \                     ??TIM1_OC1Init_1:
   \   00006A 3D ..        TNZ       S:?b13
   \   00006C 27 15        JREQ      L:??TIM1_OC1Init_2
   \   00006E B6 ..        LD        A, S:?b13
   \   000070 A1 44        CP        A, #0x44
   \   000072 27 0F        JREQ      L:??TIM1_OC1Init_2
   \   000074 AE 00A6      LDW       X, #0xa6
   \   000077 BF ..        LDW       S:?w1, X
   \   000079 5F           CLRW      X
   \   00007A BF ..        LDW       S:?w0, X
   \   00007C AE ....      LDW       X, #?_0
   \   00007F 8D ......    CALLF     assert_failed
    167            assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     ??TIM1_OC1Init_2:
   \   000083 3D ..        TNZ       S:?b12
   \   000085 27 15        JREQ      L:??TIM1_OC1Init_3
   \   000087 B6 ..        LD        A, S:?b12
   \   000089 A1 22        CP        A, #0x22
   \   00008B 27 0F        JREQ      L:??TIM1_OC1Init_3
   \   00008D AE 00A7      LDW       X, #0xa7
   \   000090 BF ..        LDW       S:?w1, X
   \   000092 5F           CLRW      X
   \   000093 BF ..        LDW       S:?w0, X
   \   000095 AE ....      LDW       X, #?_0
   \   000098 8D ......    CALLF     assert_failed
    168            assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     ??TIM1_OC1Init_3:
   \   00009C 3D ..        TNZ       S:?b9
   \   00009E 27 15        JREQ      L:??TIM1_OC1Init_4
   \   0000A0 B6 ..        LD        A, S:?b9
   \   0000A2 A1 88        CP        A, #0x88
   \   0000A4 27 0F        JREQ      L:??TIM1_OC1Init_4
   \   0000A6 AE 00A8      LDW       X, #0xa8
   \   0000A9 BF ..        LDW       S:?w1, X
   \   0000AB 5F           CLRW      X
   \   0000AC BF ..        LDW       S:?w0, X
   \   0000AE AE ....      LDW       X, #?_0
   \   0000B1 8D ......    CALLF     assert_failed
    169            assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
   \                     ??TIM1_OC1Init_4:
   \   0000B5 B6 ..        LD        A, S:?b10
   \   0000B7 A1 55        CP        A, #0x55
   \   0000B9 27 13        JREQ      L:??TIM1_OC1Init_5
   \   0000BB 3D ..        TNZ       S:?b10
   \   0000BD 27 0F        JREQ      L:??TIM1_OC1Init_5
   \   0000BF AE 00A9      LDW       X, #0xa9
   \   0000C2 BF ..        LDW       S:?w1, X
   \   0000C4 5F           CLRW      X
   \   0000C5 BF ..        LDW       S:?w0, X
   \   0000C7 AE ....      LDW       X, #?_0
   \   0000CA 8D ......    CALLF     assert_failed
    170            assert_param(IS_TIM1_OCNIDLE_STATE_OK(TIM1_OCNIdleState));
   \                     ??TIM1_OC1Init_5:
   \   0000CE B6 ..        LD        A, S:?b11
   \   0000D0 A1 2A        CP        A, #0x2a
   \   0000D2 27 13        JREQ      L:??TIM1_OC1Init_6
   \   0000D4 3D ..        TNZ       S:?b11
   \   0000D6 27 0F        JREQ      L:??TIM1_OC1Init_6
   \   0000D8 AE 00AA      LDW       X, #0xaa
   \   0000DB BF ..        LDW       S:?w1, X
   \   0000DD 5F           CLRW      X
   \   0000DE BF ..        LDW       S:?w0, X
   \   0000E0 AE ....      LDW       X, #?_0
   \   0000E3 8D ......    CALLF     assert_failed
    171            
    172            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , 
    173            the Output N State, the Output Polarity & the Output N Polarity*/
    174            TIM1->CCER1 &= (uint8_t)(~( TIM1_CCER1_CC1E | TIM1_CCER1_CC1NE 
    175                                       | TIM1_CCER1_CC1P | TIM1_CCER1_CC1NP));
   \                     ??TIM1_OC1Init_6:
   \   0000E7 C6 525C      LD        A, L:0x525c
   \   0000EA A4 F0        AND       A, #0xf0
   \   0000EC C7 525C      LD        L:0x525c, A
    176            /* Set the Output State & Set the Output N State & Set the Output Polarity &
    177            Set the Output N Polarity */
    178            TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC1E)
    179                                               | (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC1NE))
    180                                     | (uint8_t)( (uint8_t)(TIM1_OCPolarity  & TIM1_CCER1_CC1P)
    181                                                 | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC1NP)));
   \   0000EF B6 ..        LD        A, S:?b9
   \   0000F1 A4 08        AND       A, #0x8
   \   0000F3 88           PUSH      A
   \   0000F4 B6 ..        LD        A, S:?b12
   \   0000F6 A4 02        AND       A, #0x2
   \   0000F8 B7 ..        LD        S:?b1, A
   \   0000FA 84           POP       A
   \   0000FB BA ..        OR        A, S:?b1
   \   0000FD 88           PUSH      A
   \   0000FE B6 ..        LD        A, S:?b13
   \   000100 A4 04        AND       A, #0x4
   \   000102 88           PUSH      A
   \   000103 B6 ..        LD        A, S:?b14
   \   000105 A4 01        AND       A, #0x1
   \   000107 B7 ..        LD        S:?b2, A
   \   000109 84           POP       A
   \   00010A BA ..        OR        A, S:?b2
   \   00010C B7 ..        LD        S:?b1, A
   \   00010E 84           POP       A
   \   00010F BA ..        OR        A, S:?b1
   \   000111 CA 525C      OR        A, L:0x525c
   \   000114 C7 525C      LD        L:0x525c, A
    182            
    183            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    184            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) | 
    185                                    (uint8_t)TIM1_OCMode);
   \   000117 C6 5258      LD        A, L:0x5258
   \   00011A A4 8F        AND       A, #0x8f
   \   00011C BA ..        OR        A, S:?b8
   \   00011E C7 5258      LD        L:0x5258, A
    186            
    187            /* Reset the Output Idle state & the Output N Idle state bits */
    188            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS1 | TIM1_OISR_OIS1N));
   \   000121 C6 526F      LD        A, L:0x526f
   \   000124 A4 FC        AND       A, #0xfc
   \   000126 C7 526F      LD        L:0x526f, A
    189            /* Set the Output Idle state & the Output N Idle state configuration */
    190            TIM1->OISR |= (uint8_t)((uint8_t)( TIM1_OCIdleState & TIM1_OISR_OIS1 ) | 
    191                                    (uint8_t)( TIM1_OCNIdleState & TIM1_OISR_OIS1N ));
   \   000129 B6 ..        LD        A, S:?b11
   \   00012B A4 02        AND       A, #0x2
   \   00012D 88           PUSH      A
   \   00012E B6 ..        LD        A, S:?b10
   \   000130 A4 01        AND       A, #0x1
   \   000132 B7 ..        LD        S:?b1, A
   \   000134 84           POP       A
   \   000135 BA ..        OR        A, S:?b1
   \   000137 CA 526F      OR        A, L:0x526f
   \   00013A C7 526F      LD        L:0x526f, A
    192            
    193            /* Set the Pulse value */
    194            TIM1->CCR1H = (uint8_t)(TIM1_Pulse >> 8);
   \   00013D 1E 01        LDW       X, (0x1,SP)
   \   00013F 9E           LD        A, XH
   \   000140 C7 5265      LD        L:0x5265, A
    195            TIM1->CCR1L = (uint8_t)(TIM1_Pulse);
   \   000143 7B 02        LD        A, (0x2,SP)
   \   000145 C7 5266      LD        L:0x5266, A
    196          }
   \   000148 5B 02        ADD       SP, #0x2
   \   00014A 32 ....      POP       S:?b14
   \   00014D AC ......    JPF       L:?epilogue_l2_w6
    197          
    198          /**
    199            * @brief  Initializes the TIM1 Channel2 according to the specified parameters.
    200            * @param  TIM1_OCMode specifies the Output Compare mode from
    201            *         @ref TIM1_OCMode_TypeDef.
    202            * @param  TIM1_OutputState specifies the Output State from 
    203            *         @ref TIM1_OutputState_TypeDef.
    204            * @param  TIM1_OutputNState specifies the Complementary Output State from 
    205            *         @ref TIM1_OutputNState_TypeDef.
    206            * @param  TIM1_Pulse specifies the Pulse width value.
    207            * @param  TIM1_OCPolarity specifies the Output Compare Polarity from 
    208            *         @ref TIM1_OCPolarity_TypeDef.
    209            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare Polarity
    210            *         from @ref TIM1_OCNPolarity_TypeDef.
    211            * @param  TIM1_OCIdleState specifies the Output Compare Idle State from 
    212            *         @ref TIM1_OCIdleState_TypeDef.
    213            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle 
    214            *         State from @ref TIM1_OCIdleState_TypeDef.
    215            * @retval None
    216            */

   \                                 In section .far_func.text, align 1
    217          void TIM1_OC2Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    218                            TIM1_OutputState_TypeDef TIM1_OutputState,
    219                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    220                            uint16_t TIM1_Pulse,
    221                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    222                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    223                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    224                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    225          {
   \                     TIM1_OC2Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 3B ....      PUSH      S:?b14
   \   00000B 89           PUSHW     X
   \   00000C B7 ..        LD        S:?b8, A
   \   00000E 45 .. ..     MOV       S:?b14, S:?b0
   \   000011 45 .. ..     MOV       S:?b13, S:?b1
   \   000014 45 .. ..     MOV       S:?b12, S:?b2
   \   000017 45 .. ..     MOV       S:?b9, S:?b3
   \   00001A 45 .. ..     MOV       S:?b10, S:?b4
   \   00001D 45 .. ..     MOV       S:?b11, S:?b5
    226            /* Check the parameters */
    227            assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
   \   000020 3D ..        TNZ       S:?b8
   \   000022 27 2D        JREQ      L:??TIM1_OC2Init_0
   \   000024 B6 ..        LD        A, S:?b8
   \   000026 A1 10        CP        A, #0x10
   \   000028 27 27        JREQ      L:??TIM1_OC2Init_0
   \   00002A B6 ..        LD        A, S:?b8
   \   00002C A1 20        CP        A, #0x20
   \   00002E 27 21        JREQ      L:??TIM1_OC2Init_0
   \   000030 B6 ..        LD        A, S:?b8
   \   000032 A1 30        CP        A, #0x30
   \   000034 27 1B        JREQ      L:??TIM1_OC2Init_0
   \   000036 B6 ..        LD        A, S:?b8
   \   000038 A1 60        CP        A, #0x60
   \   00003A 27 15        JREQ      L:??TIM1_OC2Init_0
   \   00003C B6 ..        LD        A, S:?b8
   \   00003E A1 70        CP        A, #0x70
   \   000040 27 0F        JREQ      L:??TIM1_OC2Init_0
   \   000042 AE 00E3      LDW       X, #0xe3
   \   000045 BF ..        LDW       S:?w1, X
   \   000047 5F           CLRW      X
   \   000048 BF ..        LDW       S:?w0, X
   \   00004A AE ....      LDW       X, #?_0
   \   00004D 8D ......    CALLF     assert_failed
    228            assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
   \                     ??TIM1_OC2Init_0:
   \   000051 3D ..        TNZ       S:?b14
   \   000053 27 15        JREQ      L:??TIM1_OC2Init_1
   \   000055 B6 ..        LD        A, S:?b14
   \   000057 A1 11        CP        A, #0x11
   \   000059 27 0F        JREQ      L:??TIM1_OC2Init_1
   \   00005B AE 00E4      LDW       X, #0xe4
   \   00005E BF ..        LDW       S:?w1, X
   \   000060 5F           CLRW      X
   \   000061 BF ..        LDW       S:?w0, X
   \   000063 AE ....      LDW       X, #?_0
   \   000066 8D ......    CALLF     assert_failed
    229            assert_param(IS_TIM1_OUTPUTN_STATE_OK(TIM1_OutputNState));
   \                     ??TIM1_OC2Init_1:
   \   00006A 3D ..        TNZ       S:?b13
   \   00006C 27 15        JREQ      L:??TIM1_OC2Init_2
   \   00006E B6 ..        LD        A, S:?b13
   \   000070 A1 44        CP        A, #0x44
   \   000072 27 0F        JREQ      L:??TIM1_OC2Init_2
   \   000074 AE 00E5      LDW       X, #0xe5
   \   000077 BF ..        LDW       S:?w1, X
   \   000079 5F           CLRW      X
   \   00007A BF ..        LDW       S:?w0, X
   \   00007C AE ....      LDW       X, #?_0
   \   00007F 8D ......    CALLF     assert_failed
    230            assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     ??TIM1_OC2Init_2:
   \   000083 3D ..        TNZ       S:?b12
   \   000085 27 15        JREQ      L:??TIM1_OC2Init_3
   \   000087 B6 ..        LD        A, S:?b12
   \   000089 A1 22        CP        A, #0x22
   \   00008B 27 0F        JREQ      L:??TIM1_OC2Init_3
   \   00008D AE 00E6      LDW       X, #0xe6
   \   000090 BF ..        LDW       S:?w1, X
   \   000092 5F           CLRW      X
   \   000093 BF ..        LDW       S:?w0, X
   \   000095 AE ....      LDW       X, #?_0
   \   000098 8D ......    CALLF     assert_failed
    231            assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     ??TIM1_OC2Init_3:
   \   00009C 3D ..        TNZ       S:?b9
   \   00009E 27 15        JREQ      L:??TIM1_OC2Init_4
   \   0000A0 B6 ..        LD        A, S:?b9
   \   0000A2 A1 88        CP        A, #0x88
   \   0000A4 27 0F        JREQ      L:??TIM1_OC2Init_4
   \   0000A6 AE 00E7      LDW       X, #0xe7
   \   0000A9 BF ..        LDW       S:?w1, X
   \   0000AB 5F           CLRW      X
   \   0000AC BF ..        LDW       S:?w0, X
   \   0000AE AE ....      LDW       X, #?_0
   \   0000B1 8D ......    CALLF     assert_failed
    232            assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
   \                     ??TIM1_OC2Init_4:
   \   0000B5 B6 ..        LD        A, S:?b10
   \   0000B7 A1 55        CP        A, #0x55
   \   0000B9 27 13        JREQ      L:??TIM1_OC2Init_5
   \   0000BB 3D ..        TNZ       S:?b10
   \   0000BD 27 0F        JREQ      L:??TIM1_OC2Init_5
   \   0000BF AE 00E8      LDW       X, #0xe8
   \   0000C2 BF ..        LDW       S:?w1, X
   \   0000C4 5F           CLRW      X
   \   0000C5 BF ..        LDW       S:?w0, X
   \   0000C7 AE ....      LDW       X, #?_0
   \   0000CA 8D ......    CALLF     assert_failed
    233            assert_param(IS_TIM1_OCNIDLE_STATE_OK(TIM1_OCNIdleState));
   \                     ??TIM1_OC2Init_5:
   \   0000CE B6 ..        LD        A, S:?b11
   \   0000D0 A1 2A        CP        A, #0x2a
   \   0000D2 27 13        JREQ      L:??TIM1_OC2Init_6
   \   0000D4 3D ..        TNZ       S:?b11
   \   0000D6 27 0F        JREQ      L:??TIM1_OC2Init_6
   \   0000D8 AE 00E9      LDW       X, #0xe9
   \   0000DB BF ..        LDW       S:?w1, X
   \   0000DD 5F           CLRW      X
   \   0000DE BF ..        LDW       S:?w0, X
   \   0000E0 AE ....      LDW       X, #?_0
   \   0000E3 8D ......    CALLF     assert_failed
    234            
    235            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , 
    236            the Output N State, the Output Polarity & the Output N Polarity*/
    237            TIM1->CCER1 &= (uint8_t)(~( TIM1_CCER1_CC2E | TIM1_CCER1_CC2NE | 
    238                                       TIM1_CCER1_CC2P | TIM1_CCER1_CC2NP));
   \                     ??TIM1_OC2Init_6:
   \   0000E7 C6 525C      LD        A, L:0x525c
   \   0000EA A4 0F        AND       A, #0xf
   \   0000EC C7 525C      LD        L:0x525c, A
    239            
    240            /* Set the Output State & Set the Output N State & Set the Output Polarity &
    241            Set the Output N Polarity */
    242            TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC2E  ) | 
    243                                               (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC2NE )) | 
    244                                     (uint8_t)((uint8_t)(TIM1_OCPolarity  & TIM1_CCER1_CC2P  ) | 
    245                                               (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC2NP )));
   \   0000EF B6 ..        LD        A, S:?b9
   \   0000F1 A4 80        AND       A, #0x80
   \   0000F3 88           PUSH      A
   \   0000F4 B6 ..        LD        A, S:?b12
   \   0000F6 A4 20        AND       A, #0x20
   \   0000F8 B7 ..        LD        S:?b1, A
   \   0000FA 84           POP       A
   \   0000FB BA ..        OR        A, S:?b1
   \   0000FD 88           PUSH      A
   \   0000FE B6 ..        LD        A, S:?b13
   \   000100 A4 40        AND       A, #0x40
   \   000102 88           PUSH      A
   \   000103 B6 ..        LD        A, S:?b14
   \   000105 A4 10        AND       A, #0x10
   \   000107 B7 ..        LD        S:?b2, A
   \   000109 84           POP       A
   \   00010A BA ..        OR        A, S:?b2
   \   00010C B7 ..        LD        S:?b1, A
   \   00010E 84           POP       A
   \   00010F BA ..        OR        A, S:?b1
   \   000111 CA 525C      OR        A, L:0x525c
   \   000114 C7 525C      LD        L:0x525c, A
    246            
    247            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    248            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | 
    249                                    (uint8_t)TIM1_OCMode);
   \   000117 C6 5259      LD        A, L:0x5259
   \   00011A A4 8F        AND       A, #0x8f
   \   00011C BA ..        OR        A, S:?b8
   \   00011E C7 5259      LD        L:0x5259, A
    250            
    251            /* Reset the Output Idle state & the Output N Idle state bits */
    252            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS2 | TIM1_OISR_OIS2N));
   \   000121 C6 526F      LD        A, L:0x526f
   \   000124 A4 F3        AND       A, #0xf3
   \   000126 C7 526F      LD        L:0x526f, A
    253            /* Set the Output Idle state & the Output N Idle state configuration */
    254            TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS2 & TIM1_OCIdleState) | 
    255                                    (uint8_t)(TIM1_OISR_OIS2N & TIM1_OCNIdleState));
   \   000129 B6 ..        LD        A, S:?b11
   \   00012B A4 08        AND       A, #0x8
   \   00012D 88           PUSH      A
   \   00012E B6 ..        LD        A, S:?b10
   \   000130 A4 04        AND       A, #0x4
   \   000132 B7 ..        LD        S:?b1, A
   \   000134 84           POP       A
   \   000135 BA ..        OR        A, S:?b1
   \   000137 CA 526F      OR        A, L:0x526f
   \   00013A C7 526F      LD        L:0x526f, A
    256            
    257            /* Set the Pulse value */
    258            TIM1->CCR2H = (uint8_t)(TIM1_Pulse >> 8);
   \   00013D 1E 01        LDW       X, (0x1,SP)
   \   00013F 9E           LD        A, XH
   \   000140 C7 5267      LD        L:0x5267, A
    259            TIM1->CCR2L = (uint8_t)(TIM1_Pulse);
   \   000143 7B 02        LD        A, (0x2,SP)
   \   000145 C7 5268      LD        L:0x5268, A
    260          }
   \   000148 5B 02        ADD       SP, #0x2
   \   00014A 32 ....      POP       S:?b14
   \   00014D AC ......    JPF       L:?epilogue_l2_w6
    261          
    262          /**
    263            * @brief  Initializes the TIM1 Channel3 according to the specified parameters.
    264            * @param  TIM1_OCMode specifies the Output Compare mode  from 
    265            *         @ref TIM1_OCMode_TypeDef.
    266            * @param  TIM1_OutputState specifies the Output State  
    267            *         from @ref TIM1_OutputState_TypeDef.
    268            * @param  TIM1_OutputNState specifies the Complementary Output State
    269            *         from @ref TIM1_OutputNState_TypeDef.
    270            * @param  TIM1_Pulse specifies the Pulse width value.
    271            * @param  TIM1_OCPolarity specifies the Output Compare Polarity  from 
    272            *         @ref TIM1_OCPolarity_TypeDef.
    273            * @param  TIM1_OCNPolarity specifies the Complementary  Output Compare 
    274            *         Polarity from @ref TIM1_OCNPolarity_TypeDef.
    275            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    276            *         from @ref TIM1_OCIdleState_TypeDef.
    277            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare 
    278            *         Idle State  from @ref TIM1_OCIdleState_TypeDef.
    279            * @retval None
    280            */

   \                                 In section .far_func.text, align 1
    281          void TIM1_OC3Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    282                            TIM1_OutputState_TypeDef TIM1_OutputState,
    283                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    284                            uint16_t TIM1_Pulse,
    285                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    286                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    287                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    288                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    289          {
   \                     TIM1_OC3Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 3B ....      PUSH      S:?b14
   \   00000B 89           PUSHW     X
   \   00000C B7 ..        LD        S:?b8, A
   \   00000E 45 .. ..     MOV       S:?b14, S:?b0
   \   000011 45 .. ..     MOV       S:?b13, S:?b1
   \   000014 45 .. ..     MOV       S:?b12, S:?b2
   \   000017 45 .. ..     MOV       S:?b9, S:?b3
   \   00001A 45 .. ..     MOV       S:?b10, S:?b4
   \   00001D 45 .. ..     MOV       S:?b11, S:?b5
    290            /* Check the parameters */
    291            assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
   \   000020 3D ..        TNZ       S:?b8
   \   000022 27 2D        JREQ      L:??TIM1_OC3Init_0
   \   000024 B6 ..        LD        A, S:?b8
   \   000026 A1 10        CP        A, #0x10
   \   000028 27 27        JREQ      L:??TIM1_OC3Init_0
   \   00002A B6 ..        LD        A, S:?b8
   \   00002C A1 20        CP        A, #0x20
   \   00002E 27 21        JREQ      L:??TIM1_OC3Init_0
   \   000030 B6 ..        LD        A, S:?b8
   \   000032 A1 30        CP        A, #0x30
   \   000034 27 1B        JREQ      L:??TIM1_OC3Init_0
   \   000036 B6 ..        LD        A, S:?b8
   \   000038 A1 60        CP        A, #0x60
   \   00003A 27 15        JREQ      L:??TIM1_OC3Init_0
   \   00003C B6 ..        LD        A, S:?b8
   \   00003E A1 70        CP        A, #0x70
   \   000040 27 0F        JREQ      L:??TIM1_OC3Init_0
   \   000042 AE 0123      LDW       X, #0x123
   \   000045 BF ..        LDW       S:?w1, X
   \   000047 5F           CLRW      X
   \   000048 BF ..        LDW       S:?w0, X
   \   00004A AE ....      LDW       X, #?_0
   \   00004D 8D ......    CALLF     assert_failed
    292            assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
   \                     ??TIM1_OC3Init_0:
   \   000051 3D ..        TNZ       S:?b14
   \   000053 27 15        JREQ      L:??TIM1_OC3Init_1
   \   000055 B6 ..        LD        A, S:?b14
   \   000057 A1 11        CP        A, #0x11
   \   000059 27 0F        JREQ      L:??TIM1_OC3Init_1
   \   00005B AE 0124      LDW       X, #0x124
   \   00005E BF ..        LDW       S:?w1, X
   \   000060 5F           CLRW      X
   \   000061 BF ..        LDW       S:?w0, X
   \   000063 AE ....      LDW       X, #?_0
   \   000066 8D ......    CALLF     assert_failed
    293            assert_param(IS_TIM1_OUTPUTN_STATE_OK(TIM1_OutputNState));
   \                     ??TIM1_OC3Init_1:
   \   00006A 3D ..        TNZ       S:?b13
   \   00006C 27 15        JREQ      L:??TIM1_OC3Init_2
   \   00006E B6 ..        LD        A, S:?b13
   \   000070 A1 44        CP        A, #0x44
   \   000072 27 0F        JREQ      L:??TIM1_OC3Init_2
   \   000074 AE 0125      LDW       X, #0x125
   \   000077 BF ..        LDW       S:?w1, X
   \   000079 5F           CLRW      X
   \   00007A BF ..        LDW       S:?w0, X
   \   00007C AE ....      LDW       X, #?_0
   \   00007F 8D ......    CALLF     assert_failed
    294            assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     ??TIM1_OC3Init_2:
   \   000083 3D ..        TNZ       S:?b12
   \   000085 27 15        JREQ      L:??TIM1_OC3Init_3
   \   000087 B6 ..        LD        A, S:?b12
   \   000089 A1 22        CP        A, #0x22
   \   00008B 27 0F        JREQ      L:??TIM1_OC3Init_3
   \   00008D AE 0126      LDW       X, #0x126
   \   000090 BF ..        LDW       S:?w1, X
   \   000092 5F           CLRW      X
   \   000093 BF ..        LDW       S:?w0, X
   \   000095 AE ....      LDW       X, #?_0
   \   000098 8D ......    CALLF     assert_failed
    295            assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \                     ??TIM1_OC3Init_3:
   \   00009C 3D ..        TNZ       S:?b9
   \   00009E 27 15        JREQ      L:??TIM1_OC3Init_4
   \   0000A0 B6 ..        LD        A, S:?b9
   \   0000A2 A1 88        CP        A, #0x88
   \   0000A4 27 0F        JREQ      L:??TIM1_OC3Init_4
   \   0000A6 AE 0127      LDW       X, #0x127
   \   0000A9 BF ..        LDW       S:?w1, X
   \   0000AB 5F           CLRW      X
   \   0000AC BF ..        LDW       S:?w0, X
   \   0000AE AE ....      LDW       X, #?_0
   \   0000B1 8D ......    CALLF     assert_failed
    296            assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
   \                     ??TIM1_OC3Init_4:
   \   0000B5 B6 ..        LD        A, S:?b10
   \   0000B7 A1 55        CP        A, #0x55
   \   0000B9 27 13        JREQ      L:??TIM1_OC3Init_5
   \   0000BB 3D ..        TNZ       S:?b10
   \   0000BD 27 0F        JREQ      L:??TIM1_OC3Init_5
   \   0000BF AE 0128      LDW       X, #0x128
   \   0000C2 BF ..        LDW       S:?w1, X
   \   0000C4 5F           CLRW      X
   \   0000C5 BF ..        LDW       S:?w0, X
   \   0000C7 AE ....      LDW       X, #?_0
   \   0000CA 8D ......    CALLF     assert_failed
    297            assert_param(IS_TIM1_OCNIDLE_STATE_OK(TIM1_OCNIdleState));
   \                     ??TIM1_OC3Init_5:
   \   0000CE B6 ..        LD        A, S:?b11
   \   0000D0 A1 2A        CP        A, #0x2a
   \   0000D2 27 13        JREQ      L:??TIM1_OC3Init_6
   \   0000D4 3D ..        TNZ       S:?b11
   \   0000D6 27 0F        JREQ      L:??TIM1_OC3Init_6
   \   0000D8 AE 0129      LDW       X, #0x129
   \   0000DB BF ..        LDW       S:?w1, X
   \   0000DD 5F           CLRW      X
   \   0000DE BF ..        LDW       S:?w0, X
   \   0000E0 AE ....      LDW       X, #?_0
   \   0000E3 8D ......    CALLF     assert_failed
    298            
    299            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , 
    300            the Output N State, the Output Polarity & the Output N Polarity*/
    301            TIM1->CCER2 &= (uint8_t)(~( TIM1_CCER2_CC3E | TIM1_CCER2_CC3NE | 
    302                                       TIM1_CCER2_CC3P | TIM1_CCER2_CC3NP));
   \                     ??TIM1_OC3Init_6:
   \   0000E7 C6 525D      LD        A, L:0x525d
   \   0000EA A4 F0        AND       A, #0xf0
   \   0000EC C7 525D      LD        L:0x525d, A
    303            /* Set the Output State & Set the Output N State & Set the Output Polarity &
    304            Set the Output N Polarity */
    305            TIM1->CCER2 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState  & TIM1_CCER2_CC3E   ) |
    306                                               (uint8_t)(TIM1_OutputNState & TIM1_CCER2_CC3NE  )) | 
    307                                     (uint8_t)((uint8_t)(TIM1_OCPolarity   & TIM1_CCER2_CC3P   ) | 
    308                                               (uint8_t)(TIM1_OCNPolarity  & TIM1_CCER2_CC3NP  )));
   \   0000EF B6 ..        LD        A, S:?b9
   \   0000F1 A4 08        AND       A, #0x8
   \   0000F3 88           PUSH      A
   \   0000F4 B6 ..        LD        A, S:?b12
   \   0000F6 A4 02        AND       A, #0x2
   \   0000F8 B7 ..        LD        S:?b1, A
   \   0000FA 84           POP       A
   \   0000FB BA ..        OR        A, S:?b1
   \   0000FD 88           PUSH      A
   \   0000FE B6 ..        LD        A, S:?b13
   \   000100 A4 04        AND       A, #0x4
   \   000102 88           PUSH      A
   \   000103 B6 ..        LD        A, S:?b14
   \   000105 A4 01        AND       A, #0x1
   \   000107 B7 ..        LD        S:?b2, A
   \   000109 84           POP       A
   \   00010A BA ..        OR        A, S:?b2
   \   00010C B7 ..        LD        S:?b1, A
   \   00010E 84           POP       A
   \   00010F BA ..        OR        A, S:?b1
   \   000111 CA 525D      OR        A, L:0x525d
   \   000114 C7 525D      LD        L:0x525d, A
    309            
    310            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    311            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) | 
    312                                    (uint8_t)TIM1_OCMode);
   \   000117 C6 525A      LD        A, L:0x525a
   \   00011A A4 8F        AND       A, #0x8f
   \   00011C BA ..        OR        A, S:?b8
   \   00011E C7 525A      LD        L:0x525a, A
    313            
    314            /* Reset the Output Idle state & the Output N Idle state bits */
    315            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS3 | TIM1_OISR_OIS3N));
   \   000121 C6 526F      LD        A, L:0x526f
   \   000124 A4 CF        AND       A, #0xcf
   \   000126 C7 526F      LD        L:0x526f, A
    316            /* Set the Output Idle state & the Output N Idle state configuration */
    317            TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS3 & TIM1_OCIdleState) | 
    318                                    (uint8_t)(TIM1_OISR_OIS3N & TIM1_OCNIdleState));
   \   000129 B6 ..        LD        A, S:?b11
   \   00012B A4 20        AND       A, #0x20
   \   00012D 88           PUSH      A
   \   00012E B6 ..        LD        A, S:?b10
   \   000130 A4 10        AND       A, #0x10
   \   000132 B7 ..        LD        S:?b1, A
   \   000134 84           POP       A
   \   000135 BA ..        OR        A, S:?b1
   \   000137 CA 526F      OR        A, L:0x526f
   \   00013A C7 526F      LD        L:0x526f, A
    319            
    320            /* Set the Pulse value */
    321            TIM1->CCR3H = (uint8_t)(TIM1_Pulse >> 8);
   \   00013D 1E 01        LDW       X, (0x1,SP)
   \   00013F 9E           LD        A, XH
   \   000140 C7 5269      LD        L:0x5269, A
    322            TIM1->CCR3L = (uint8_t)(TIM1_Pulse);
   \   000143 7B 02        LD        A, (0x2,SP)
   \   000145 C7 526A      LD        L:0x526a, A
    323          }
   \   000148 5B 02        ADD       SP, #0x2
   \   00014A 32 ....      POP       S:?b14
   \   00014D AC ......    JPF       L:?epilogue_l2_w6
    324          
    325          /**
    326            * @brief  Initializes the TIM1 Channel4 according to the specified parameters.
    327            * @param  TIM1_OCMode specifies the Output Compare mode  from 
    328            *         @ref TIM1_OCMode_TypeDef.
    329            * @param  TIM1_OutputState specifies the Output State
    330            *         from @ref TIM1_OutputState_TypeDef.
    331            * @param  TIM1_Pulse specifies the Pulse width  value.
    332            * @param  TIM1_OCPolarity specifies the Output Compare Polarity
    333            *         from @ref TIM1_OCPolarity_TypeDef.
    334            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    335            *         from @ref TIM1_OCIdleState_TypeDef.
    336            * @retval None
    337            */

   \                                 In section .far_func.text, align 1
    338          void TIM1_OC4Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    339                            TIM1_OutputState_TypeDef TIM1_OutputState,
    340                            uint16_t TIM1_Pulse,
    341                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    342                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState)
    343          {
   \                     TIM1_OC4Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 B7 ..        LD        S:?b9, A
   \   00000A 45 .. ..     MOV       S:?b10, S:?b0
   \   00000D BF ..        LDW       S:?w6, X
   \   00000F 45 .. ..     MOV       S:?b11, S:?b1
   \   000012 45 .. ..     MOV       S:?b8, S:?b2
    344            /* Check the parameters */
    345            assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
   \   000015 3D ..        TNZ       S:?b9
   \   000017 27 2D        JREQ      L:??TIM1_OC4Init_0
   \   000019 B6 ..        LD        A, S:?b9
   \   00001B A1 10        CP        A, #0x10
   \   00001D 27 27        JREQ      L:??TIM1_OC4Init_0
   \   00001F B6 ..        LD        A, S:?b9
   \   000021 A1 20        CP        A, #0x20
   \   000023 27 21        JREQ      L:??TIM1_OC4Init_0
   \   000025 B6 ..        LD        A, S:?b9
   \   000027 A1 30        CP        A, #0x30
   \   000029 27 1B        JREQ      L:??TIM1_OC4Init_0
   \   00002B B6 ..        LD        A, S:?b9
   \   00002D A1 60        CP        A, #0x60
   \   00002F 27 15        JREQ      L:??TIM1_OC4Init_0
   \   000031 B6 ..        LD        A, S:?b9
   \   000033 A1 70        CP        A, #0x70
   \   000035 27 0F        JREQ      L:??TIM1_OC4Init_0
   \   000037 AE 0159      LDW       X, #0x159
   \   00003A BF ..        LDW       S:?w1, X
   \   00003C 5F           CLRW      X
   \   00003D BF ..        LDW       S:?w0, X
   \   00003F AE ....      LDW       X, #?_0
   \   000042 8D ......    CALLF     assert_failed
    346            assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
   \                     ??TIM1_OC4Init_0:
   \   000046 3D ..        TNZ       S:?b10
   \   000048 27 15        JREQ      L:??TIM1_OC4Init_1
   \   00004A B6 ..        LD        A, S:?b10
   \   00004C A1 11        CP        A, #0x11
   \   00004E 27 0F        JREQ      L:??TIM1_OC4Init_1
   \   000050 AE 015A      LDW       X, #0x15a
   \   000053 BF ..        LDW       S:?w1, X
   \   000055 5F           CLRW      X
   \   000056 BF ..        LDW       S:?w0, X
   \   000058 AE ....      LDW       X, #?_0
   \   00005B 8D ......    CALLF     assert_failed
    347            assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \                     ??TIM1_OC4Init_1:
   \   00005F 3D ..        TNZ       S:?b11
   \   000061 27 15        JREQ      L:??TIM1_OC4Init_2
   \   000063 B6 ..        LD        A, S:?b11
   \   000065 A1 22        CP        A, #0x22
   \   000067 27 0F        JREQ      L:??TIM1_OC4Init_2
   \   000069 AE 015B      LDW       X, #0x15b
   \   00006C BF ..        LDW       S:?w1, X
   \   00006E 5F           CLRW      X
   \   00006F BF ..        LDW       S:?w0, X
   \   000071 AE ....      LDW       X, #?_0
   \   000074 8D ......    CALLF     assert_failed
    348            assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
   \                     ??TIM1_OC4Init_2:
   \   000078 B6 ..        LD        A, S:?b8
   \   00007A A1 55        CP        A, #0x55
   \   00007C 27 13        JREQ      L:??TIM1_OC4Init_3
   \   00007E 3D ..        TNZ       S:?b8
   \   000080 27 0F        JREQ      L:??TIM1_OC4Init_3
   \   000082 AE 015C      LDW       X, #0x15c
   \   000085 BF ..        LDW       S:?w1, X
   \   000087 5F           CLRW      X
   \   000088 BF ..        LDW       S:?w0, X
   \   00008A AE ....      LDW       X, #?_0
   \   00008D 8D ......    CALLF     assert_failed
    349            
    350            /* Disable the Channel 4: Reset the CCE Bit */
    351            TIM1->CCER2 &= (uint8_t)(~(TIM1_CCER2_CC4E | TIM1_CCER2_CC4P));
   \                     ??TIM1_OC4Init_3:
   \   000091 C6 525D      LD        A, L:0x525d
   \   000094 A4 CF        AND       A, #0xcf
   \   000096 C7 525D      LD        L:0x525d, A
    352            /* Set the Output State  &  the Output Polarity */
    353            TIM1->CCER2 |= (uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER2_CC4E ) |  
    354                                     (uint8_t)(TIM1_OCPolarity  & TIM1_CCER2_CC4P ));
   \   000099 B6 ..        LD        A, S:?b11
   \   00009B A4 20        AND       A, #0x20
   \   00009D 88           PUSH      A
   \   00009E B6 ..        LD        A, S:?b10
   \   0000A0 A4 10        AND       A, #0x10
   \   0000A2 B7 ..        LD        S:?b1, A
   \   0000A4 84           POP       A
   \   0000A5 BA ..        OR        A, S:?b1
   \   0000A7 CA 525D      OR        A, L:0x525d
   \   0000AA C7 525D      LD        L:0x525d, A
    355            
    356            /* Reset the Output Compare Bit  and Set the Output Compare Mode */
    357            TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_OCM)) | 
    358                                    TIM1_OCMode);
   \   0000AD C6 525B      LD        A, L:0x525b
   \   0000B0 A4 8F        AND       A, #0x8f
   \   0000B2 BA ..        OR        A, S:?b9
   \   0000B4 C7 525B      LD        L:0x525b, A
    359            
    360            /* Set the Output Idle state */
    361            if (TIM1_OCIdleState != TIM1_OCIDLESTATE_RESET)
   \   0000B7 3D ..        TNZ       S:?b8
   \   0000B9 27 0A        JREQ      L:??TIM1_OC4Init_4
    362            {
    363              TIM1->OISR |= (uint8_t)(~TIM1_CCER2_CC4P);
   \   0000BB C6 526F      LD        A, L:0x526f
   \   0000BE AA DF        OR        A, #0xdf
   \   0000C0 C7 526F      LD        L:0x526f, A
   \   0000C3 20 04        JRA       L:??TIM1_OC4Init_5
    364            }
    365            else
    366            {
    367              TIM1->OISR &= (uint8_t)(~TIM1_OISR_OIS4);
   \                     ??TIM1_OC4Init_4:
   \   0000C5 721D 526F    BRES      L:0x526f, #0x6
    368            }
    369            
    370            /* Set the Pulse value */
    371            TIM1->CCR4H = (uint8_t)(TIM1_Pulse >> 8);
   \                     ??TIM1_OC4Init_5:
   \   0000C9 B6 ..        LD        A, S:?b12
   \   0000CB C7 526B      LD        L:0x526b, A
    372            TIM1->CCR4L = (uint8_t)(TIM1_Pulse);
   \   0000CE B6 ..        LD        A, S:?b13
   \   0000D0 C7 526C      LD        L:0x526c, A
    373          }
   \   0000D3 AC ......    JPF       L:?epilogue_l2_w6
    374          
    375          /**
    376            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    377            *         and the AOE(automatic output enable).
    378            * @param  TIM1_OSSIState specifies the OSSIS State from @ref TIM1_OSSIState_TypeDef.
    379            * @param  TIM1_LockLevel specifies the lock level from @ref TIM1_LockLevel_TypeDef.
    380            * @param  TIM1_DeadTime specifies the dead time value.
    381            * @param  TIM1_Break specifies the Break state @ref TIM1_BreakState_TypeDef.
    382            * @param  TIM1_BreakPolarity specifies the Break polarity from 
    383            *         @ref TIM1_BreakPolarity_TypeDef.
    384            * @param  TIM1_AutomaticOutput specifies the Automatic Output configuration 
    385            *         from @ref TIM1_AutomaticOutput_TypeDef.
    386            * @retval None
    387            */

   \                                 In section .far_func.text, align 1
    388          void TIM1_BDTRConfig(TIM1_OSSIState_TypeDef TIM1_OSSIState,
    389                               TIM1_LockLevel_TypeDef TIM1_LockLevel,
    390                               uint8_t TIM1_DeadTime,
    391                               TIM1_BreakState_TypeDef TIM1_Break,
    392                               TIM1_BreakPolarity_TypeDef TIM1_BreakPolarity,
    393                               TIM1_AutomaticOutput_TypeDef TIM1_AutomaticOutput)
    394          {
   \                     TIM1_BDTRConfig:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 B7 ..        LD        S:?b12, A
   \   00000A 45 .. ..     MOV       S:?b8, S:?b0
   \   00000D 45 .. ..     MOV       S:?b13, S:?b1
   \   000010 45 .. ..     MOV       S:?b9, S:?b2
   \   000013 45 .. ..     MOV       S:?b10, S:?b3
   \   000016 45 .. ..     MOV       S:?b11, S:?b4
    395            /* Check the parameters */
    396            assert_param(IS_TIM1_OSSI_STATE_OK(TIM1_OSSIState));
   \   000019 B6 ..        LD        A, S:?b12
   \   00001B A1 04        CP        A, #0x4
   \   00001D 27 13        JREQ      L:??TIM1_BDTRConfig_0
   \   00001F 3D ..        TNZ       S:?b12
   \   000021 27 0F        JREQ      L:??TIM1_BDTRConfig_0
   \   000023 AE 018C      LDW       X, #0x18c
   \   000026 BF ..        LDW       S:?w1, X
   \   000028 5F           CLRW      X
   \   000029 BF ..        LDW       S:?w0, X
   \   00002B AE ....      LDW       X, #?_0
   \   00002E 8D ......    CALLF     assert_failed
    397            assert_param(IS_TIM1_LOCK_LEVEL_OK(TIM1_LockLevel));
   \                     ??TIM1_BDTRConfig_0:
   \   000032 3D ..        TNZ       S:?b8
   \   000034 27 21        JREQ      L:??TIM1_BDTRConfig_1
   \   000036 B6 ..        LD        A, S:?b8
   \   000038 A1 01        CP        A, #0x1
   \   00003A 27 1B        JREQ      L:??TIM1_BDTRConfig_1
   \   00003C B6 ..        LD        A, S:?b8
   \   00003E A1 02        CP        A, #0x2
   \   000040 27 15        JREQ      L:??TIM1_BDTRConfig_1
   \   000042 B6 ..        LD        A, S:?b8
   \   000044 A1 03        CP        A, #0x3
   \   000046 27 0F        JREQ      L:??TIM1_BDTRConfig_1
   \   000048 AE 018D      LDW       X, #0x18d
   \   00004B BF ..        LDW       S:?w1, X
   \   00004D 5F           CLRW      X
   \   00004E BF ..        LDW       S:?w0, X
   \   000050 AE ....      LDW       X, #?_0
   \   000053 8D ......    CALLF     assert_failed
    398            assert_param(IS_TIM1_BREAK_STATE_OK(TIM1_Break));
   \                     ??TIM1_BDTRConfig_1:
   \   000057 B6 ..        LD        A, S:?b9
   \   000059 A1 10        CP        A, #0x10
   \   00005B 27 13        JREQ      L:??TIM1_BDTRConfig_2
   \   00005D 3D ..        TNZ       S:?b9
   \   00005F 27 0F        JREQ      L:??TIM1_BDTRConfig_2
   \   000061 AE 018E      LDW       X, #0x18e
   \   000064 BF ..        LDW       S:?w1, X
   \   000066 5F           CLRW      X
   \   000067 BF ..        LDW       S:?w0, X
   \   000069 AE ....      LDW       X, #?_0
   \   00006C 8D ......    CALLF     assert_failed
    399            assert_param(IS_TIM1_BREAK_POLARITY_OK(TIM1_BreakPolarity));
   \                     ??TIM1_BDTRConfig_2:
   \   000070 3D ..        TNZ       S:?b10
   \   000072 27 15        JREQ      L:??TIM1_BDTRConfig_3
   \   000074 B6 ..        LD        A, S:?b10
   \   000076 A1 20        CP        A, #0x20
   \   000078 27 0F        JREQ      L:??TIM1_BDTRConfig_3
   \   00007A AE 018F      LDW       X, #0x18f
   \   00007D BF ..        LDW       S:?w1, X
   \   00007F 5F           CLRW      X
   \   000080 BF ..        LDW       S:?w0, X
   \   000082 AE ....      LDW       X, #?_0
   \   000085 8D ......    CALLF     assert_failed
    400            assert_param(IS_TIM1_AUTOMATIC_OUTPUT_STATE_OK(TIM1_AutomaticOutput));
   \                     ??TIM1_BDTRConfig_3:
   \   000089 B6 ..        LD        A, S:?b11
   \   00008B A1 40        CP        A, #0x40
   \   00008D 27 13        JREQ      L:??TIM1_BDTRConfig_4
   \   00008F 3D ..        TNZ       S:?b11
   \   000091 27 0F        JREQ      L:??TIM1_BDTRConfig_4
   \   000093 AE 0190      LDW       X, #0x190
   \   000096 BF ..        LDW       S:?w1, X
   \   000098 5F           CLRW      X
   \   000099 BF ..        LDW       S:?w0, X
   \   00009B AE ....      LDW       X, #?_0
   \   00009E 8D ......    CALLF     assert_failed
    401            
    402            TIM1->DTR = (uint8_t)(TIM1_DeadTime);
   \                     ??TIM1_BDTRConfig_4:
   \   0000A2 B6 ..        LD        A, S:?b13
   \   0000A4 C7 526E      LD        L:0x526e, A
    403            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
    404            the dead time value  and the Automatic Output Enable Bit */
    405            
    406            TIM1->BKR  =  (uint8_t)((uint8_t)(TIM1_OSSIState | (uint8_t)TIM1_LockLevel)  | 
    407                                    (uint8_t)((uint8_t)(TIM1_Break | (uint8_t)TIM1_BreakPolarity)  | 
    408                                    (uint8_t)TIM1_AutomaticOutput));
   \   0000A7 B6 ..        LD        A, S:?b10
   \   0000A9 BA ..        OR        A, S:?b9
   \   0000AB BA ..        OR        A, S:?b11
   \   0000AD 88           PUSH      A
   \   0000AE B6 ..        LD        A, S:?b8
   \   0000B0 BA ..        OR        A, S:?b12
   \   0000B2 B7 ..        LD        S:?b1, A
   \   0000B4 84           POP       A
   \   0000B5 BA ..        OR        A, S:?b1
   \   0000B7 C7 526D      LD        L:0x526d, A
    409          }
   \   0000BA AC ......    JPF       L:?epilogue_l2_w6
    410          
    411          /**
    412            * @brief  Initializes the TIM1 peripheral according to the specified parameters.
    413            * @param  TIM1_Channel specifies the input capture channel from TIM1_Channel_TypeDef.
    414            * @param  TIM1_ICPolarity specifies the Input capture polarity from  
    415            *         TIM1_ICPolarity_TypeDef .
    416            * @param  TIM1_ICSelection specifies the Input capture source selection from 
    417            *         TIM1_ICSelection_TypeDef.
    418            * @param  TIM1_ICPrescaler specifies the Input capture Prescaler from
    419            *         TIM1_ICPSC_TypeDef.
    420            * @param  TIM1_ICFilter specifies the Input capture filter value.
    421            * @retval None
    422            */

   \                                 In section .far_func.text, align 1
    423          void TIM1_ICInit(TIM1_Channel_TypeDef TIM1_Channel,
    424                           TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
    425                           TIM1_ICSelection_TypeDef TIM1_ICSelection,
    426                           TIM1_ICPSC_TypeDef TIM1_ICPrescaler,
    427                           uint8_t TIM1_ICFilter)
    428          {
   \                     TIM1_ICInit:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 3B ....      PUSH      S:?b12
   \   000007 B7 ..        LD        S:?b8, A
   \   000009 45 .. ..     MOV       S:?b9, S:?b0
   \   00000C 45 .. ..     MOV       S:?b11, S:?b1
   \   00000F 45 .. ..     MOV       S:?b10, S:?b2
   \   000012 45 .. ..     MOV       S:?b12, S:?b3
    429            /* Check the parameters */
    430            assert_param(IS_TIM1_CHANNEL_OK(TIM1_Channel));
   \   000015 3D ..        TNZ       S:?b8
   \   000017 27 21        JREQ      L:??TIM1_ICInit_0
   \   000019 B6 ..        LD        A, S:?b8
   \   00001B A1 01        CP        A, #0x1
   \   00001D 27 1B        JREQ      L:??TIM1_ICInit_0
   \   00001F B6 ..        LD        A, S:?b8
   \   000021 A1 02        CP        A, #0x2
   \   000023 27 15        JREQ      L:??TIM1_ICInit_0
   \   000025 B6 ..        LD        A, S:?b8
   \   000027 A1 03        CP        A, #0x3
   \   000029 27 0F        JREQ      L:??TIM1_ICInit_0
   \   00002B AE 01AE      LDW       X, #0x1ae
   \   00002E BF ..        LDW       S:?w1, X
   \   000030 5F           CLRW      X
   \   000031 BF ..        LDW       S:?w0, X
   \   000033 AE ....      LDW       X, #?_0
   \   000036 8D ......    CALLF     assert_failed
    431            assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_ICPolarity));
   \                     ??TIM1_ICInit_0:
   \   00003A 3D ..        TNZ       S:?b9
   \   00003C 27 15        JREQ      L:??TIM1_ICInit_1
   \   00003E B6 ..        LD        A, S:?b9
   \   000040 A1 01        CP        A, #0x1
   \   000042 27 0F        JREQ      L:??TIM1_ICInit_1
   \   000044 AE 01AF      LDW       X, #0x1af
   \   000047 BF ..        LDW       S:?w1, X
   \   000049 5F           CLRW      X
   \   00004A BF ..        LDW       S:?w0, X
   \   00004C AE ....      LDW       X, #?_0
   \   00004F 8D ......    CALLF     assert_failed
    432            assert_param(IS_TIM1_IC_SELECTION_OK(TIM1_ICSelection));
   \                     ??TIM1_ICInit_1:
   \   000053 B6 ..        LD        A, S:?b11
   \   000055 A1 01        CP        A, #0x1
   \   000057 27 1B        JREQ      L:??TIM1_ICInit_2
   \   000059 B6 ..        LD        A, S:?b11
   \   00005B A1 02        CP        A, #0x2
   \   00005D 27 15        JREQ      L:??TIM1_ICInit_2
   \   00005F B6 ..        LD        A, S:?b11
   \   000061 A1 03        CP        A, #0x3
   \   000063 27 0F        JREQ      L:??TIM1_ICInit_2
   \   000065 AE 01B0      LDW       X, #0x1b0
   \   000068 BF ..        LDW       S:?w1, X
   \   00006A 5F           CLRW      X
   \   00006B BF ..        LDW       S:?w0, X
   \   00006D AE ....      LDW       X, #?_0
   \   000070 8D ......    CALLF     assert_failed
    433            assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_ICPrescaler));
   \                     ??TIM1_ICInit_2:
   \   000074 3D ..        TNZ       S:?b10
   \   000076 27 21        JREQ      L:??TIM1_ICInit_3
   \   000078 B6 ..        LD        A, S:?b10
   \   00007A A1 04        CP        A, #0x4
   \   00007C 27 1B        JREQ      L:??TIM1_ICInit_3
   \   00007E B6 ..        LD        A, S:?b10
   \   000080 A1 08        CP        A, #0x8
   \   000082 27 15        JREQ      L:??TIM1_ICInit_3
   \   000084 B6 ..        LD        A, S:?b10
   \   000086 A1 0C        CP        A, #0xc
   \   000088 27 0F        JREQ      L:??TIM1_ICInit_3
   \   00008A AE 01B1      LDW       X, #0x1b1
   \   00008D BF ..        LDW       S:?w1, X
   \   00008F 5F           CLRW      X
   \   000090 BF ..        LDW       S:?w0, X
   \   000092 AE ....      LDW       X, #?_0
   \   000095 8D ......    CALLF     assert_failed
    434            assert_param(IS_TIM1_IC_FILTER_OK(TIM1_ICFilter));
   \                     ??TIM1_ICInit_3:
   \   000099 B6 ..        LD        A, S:?b12
   \   00009B A1 10        CP        A, #0x10
   \   00009D 25 0F        JRC       L:??TIM1_ICInit_4
   \   00009F AE 01B2      LDW       X, #0x1b2
   \   0000A2 BF ..        LDW       S:?w1, X
   \   0000A4 5F           CLRW      X
   \   0000A5 BF ..        LDW       S:?w0, X
   \   0000A7 AE ....      LDW       X, #?_0
   \   0000AA 8D ......    CALLF     assert_failed
    435            
    436            if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??TIM1_ICInit_4:
   \   0000AE 3D ..        TNZ       S:?b8
   \   0000B0 26 14        JRNE      L:??TIM1_ICInit_5
    437            {
    438              /* TI1 Configuration */
    439              TI1_Config((uint8_t)TIM1_ICPolarity,
    440                         (uint8_t)TIM1_ICSelection,
    441                         (uint8_t)TIM1_ICFilter);
   \   0000B2 45 .. ..     MOV       S:?b1, S:?b12
   \   0000B5 45 .. ..     MOV       S:?b0, S:?b11
   \   0000B8 B6 ..        LD        A, S:?b9
   \   0000BA 8D ......    CALLF     TI1_Config
    442              /* Set the Input Capture Prescaler value */
    443              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   \   0000BE B6 ..        LD        A, S:?b10
   \   0000C0 8D ......    CALLF     TIM1_SetIC1Prescaler
   \   0000C4 20 46        JRA       L:??TIM1_ICInit_6
    444            }
    445            else if (TIM1_Channel == TIM1_CHANNEL_2)
   \                     ??TIM1_ICInit_5:
   \   0000C6 B6 ..        LD        A, S:?b8
   \   0000C8 A1 01        CP        A, #0x1
   \   0000CA 26 14        JRNE      L:??TIM1_ICInit_7
    446            {
    447              /* TI2 Configuration */
    448              TI2_Config((uint8_t)TIM1_ICPolarity,
    449                         (uint8_t)TIM1_ICSelection,
    450                         (uint8_t)TIM1_ICFilter);
   \   0000CC 45 .. ..     MOV       S:?b1, S:?b12
   \   0000CF 45 .. ..     MOV       S:?b0, S:?b11
   \   0000D2 B6 ..        LD        A, S:?b9
   \   0000D4 8D ......    CALLF     TI2_Config
    451              /* Set the Input Capture Prescaler value */
    452              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   \   0000D8 B6 ..        LD        A, S:?b10
   \   0000DA 8D ......    CALLF     TIM1_SetIC2Prescaler
   \   0000DE 20 2C        JRA       L:??TIM1_ICInit_6
    453            }
    454            else if (TIM1_Channel == TIM1_CHANNEL_3)
   \                     ??TIM1_ICInit_7:
   \   0000E0 B6 ..        LD        A, S:?b8
   \   0000E2 A1 02        CP        A, #0x2
   \   0000E4 26 14        JRNE      L:??TIM1_ICInit_8
    455            {
    456              /* TI3 Configuration */
    457              TI3_Config((uint8_t)TIM1_ICPolarity,
    458                         (uint8_t)TIM1_ICSelection,
    459                         (uint8_t)TIM1_ICFilter);
   \   0000E6 45 .. ..     MOV       S:?b1, S:?b12
   \   0000E9 45 .. ..     MOV       S:?b0, S:?b11
   \   0000EC B6 ..        LD        A, S:?b9
   \   0000EE 8D ......    CALLF     TI3_Config
    460              /* Set the Input Capture Prescaler value */
    461              TIM1_SetIC3Prescaler(TIM1_ICPrescaler);
   \   0000F2 B6 ..        LD        A, S:?b10
   \   0000F4 8D ......    CALLF     TIM1_SetIC3Prescaler
   \   0000F8 20 12        JRA       L:??TIM1_ICInit_6
    462            }
    463            else
    464            {
    465              /* TI4 Configuration */
    466              TI4_Config((uint8_t)TIM1_ICPolarity,
    467                         (uint8_t)TIM1_ICSelection,
    468                         (uint8_t)TIM1_ICFilter);
   \                     ??TIM1_ICInit_8:
   \   0000FA 45 .. ..     MOV       S:?b1, S:?b12
   \   0000FD 45 .. ..     MOV       S:?b0, S:?b11
   \   000100 B6 ..        LD        A, S:?b9
   \   000102 8D ......    CALLF     TI4_Config
    469              /* Set the Input Capture Prescaler value */
    470              TIM1_SetIC4Prescaler(TIM1_ICPrescaler);
   \   000106 B6 ..        LD        A, S:?b10
   \   000108 8D ......    CALLF     TIM1_SetIC4Prescaler
    471            }
    472          }
   \                     ??TIM1_ICInit_6:
   \   00010C 32 ....      POP       S:?b12
   \   00010F AC ......    JPF       L:?epilogue_l2
    473          
    474          /**
    475            * @brief  Configures the TIM1 peripheral in PWM Input Mode according to the 
    476            *         specified parameters.
    477            * @param  TIM1_Channel specifies the input capture channel from 
    478            *         @ref TIM1_Channel_TypeDef.
    479            * @param  TIM1_ICPolarity specifies the Input capture polarity from  
    480            *         @ref TIM1_ICPolarity_TypeDef .
    481            * @param  TIM1_ICSelection specifies the Input capture source selection  from
    482            *         @ref TIM1_ICSelection_TypeDef.
    483            * @param  TIM1_ICPrescaler specifies the Input capture Prescaler from  
    484            *         @ref TIM1_ICPSC_TypeDef.
    485            * @param  TIM1_ICFilter specifies the Input capture filter value.
    486            * @retval None
    487            */

   \                                 In section .far_func.text, align 1
    488          void TIM1_PWMIConfig(TIM1_Channel_TypeDef TIM1_Channel,
    489                               TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
    490                               TIM1_ICSelection_TypeDef TIM1_ICSelection,
    491                               TIM1_ICPSC_TypeDef TIM1_ICPrescaler,
    492                               uint8_t TIM1_ICFilter)
    493          {
   \                     TIM1_PWMIConfig:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 3B ....      PUSH      S:?b14
   \   00000B B7 ..        LD        S:?b8, A
   \   00000D 45 .. ..     MOV       S:?b9, S:?b0
   \   000010 45 .. ..     MOV       S:?b11, S:?b1
   \   000013 45 .. ..     MOV       S:?b10, S:?b2
   \   000016 45 .. ..     MOV       S:?b12, S:?b3
    494            uint8_t icpolarity = TIM1_ICPOLARITY_RISING;
   \   000019 3F ..        CLR       S:?b14
    495            uint8_t icselection = TIM1_ICSELECTION_DIRECTTI;
   \   00001B 35 01 ....   MOV       S:?b13, #0x1
    496            
    497            /* Check the parameters */
    498            assert_param(IS_TIM1_PWMI_CHANNEL_OK(TIM1_Channel));
   \   00001F 3D ..        TNZ       S:?b8
   \   000021 27 15        JREQ      L:??TIM1_PWMIConfig_0
   \   000023 B6 ..        LD        A, S:?b8
   \   000025 A1 01        CP        A, #0x1
   \   000027 27 0F        JREQ      L:??TIM1_PWMIConfig_0
   \   000029 AE 01F2      LDW       X, #0x1f2
   \   00002C BF ..        LDW       S:?w1, X
   \   00002E 5F           CLRW      X
   \   00002F BF ..        LDW       S:?w0, X
   \   000031 AE ....      LDW       X, #?_0
   \   000034 8D ......    CALLF     assert_failed
    499            assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_ICPolarity));
   \                     ??TIM1_PWMIConfig_0:
   \   000038 3D ..        TNZ       S:?b9
   \   00003A 27 15        JREQ      L:??TIM1_PWMIConfig_1
   \   00003C B6 ..        LD        A, S:?b9
   \   00003E A1 01        CP        A, #0x1
   \   000040 27 0F        JREQ      L:??TIM1_PWMIConfig_1
   \   000042 AE 01F3      LDW       X, #0x1f3
   \   000045 BF ..        LDW       S:?w1, X
   \   000047 5F           CLRW      X
   \   000048 BF ..        LDW       S:?w0, X
   \   00004A AE ....      LDW       X, #?_0
   \   00004D 8D ......    CALLF     assert_failed
    500            assert_param(IS_TIM1_IC_SELECTION_OK(TIM1_ICSelection));
   \                     ??TIM1_PWMIConfig_1:
   \   000051 B6 ..        LD        A, S:?b11
   \   000053 A1 01        CP        A, #0x1
   \   000055 27 1B        JREQ      L:??TIM1_PWMIConfig_2
   \   000057 B6 ..        LD        A, S:?b11
   \   000059 A1 02        CP        A, #0x2
   \   00005B 27 15        JREQ      L:??TIM1_PWMIConfig_2
   \   00005D B6 ..        LD        A, S:?b11
   \   00005F A1 03        CP        A, #0x3
   \   000061 27 0F        JREQ      L:??TIM1_PWMIConfig_2
   \   000063 AE 01F4      LDW       X, #0x1f4
   \   000066 BF ..        LDW       S:?w1, X
   \   000068 5F           CLRW      X
   \   000069 BF ..        LDW       S:?w0, X
   \   00006B AE ....      LDW       X, #?_0
   \   00006E 8D ......    CALLF     assert_failed
    501            assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_ICPrescaler));
   \                     ??TIM1_PWMIConfig_2:
   \   000072 3D ..        TNZ       S:?b10
   \   000074 27 21        JREQ      L:??TIM1_PWMIConfig_3
   \   000076 B6 ..        LD        A, S:?b10
   \   000078 A1 04        CP        A, #0x4
   \   00007A 27 1B        JREQ      L:??TIM1_PWMIConfig_3
   \   00007C B6 ..        LD        A, S:?b10
   \   00007E A1 08        CP        A, #0x8
   \   000080 27 15        JREQ      L:??TIM1_PWMIConfig_3
   \   000082 B6 ..        LD        A, S:?b10
   \   000084 A1 0C        CP        A, #0xc
   \   000086 27 0F        JREQ      L:??TIM1_PWMIConfig_3
   \   000088 AE 01F5      LDW       X, #0x1f5
   \   00008B BF ..        LDW       S:?w1, X
   \   00008D 5F           CLRW      X
   \   00008E BF ..        LDW       S:?w0, X
   \   000090 AE ....      LDW       X, #?_0
   \   000093 8D ......    CALLF     assert_failed
    502            
    503            /* Select the Opposite Input Polarity */
    504            if (TIM1_ICPolarity != TIM1_ICPOLARITY_FALLING)
   \                     ??TIM1_PWMIConfig_3:
   \   000097 B6 ..        LD        A, S:?b9
   \   000099 A1 01        CP        A, #0x1
   \   00009B 27 06        JREQ      L:??TIM1_PWMIConfig_4
    505            {
    506              icpolarity = TIM1_ICPOLARITY_FALLING;
   \   00009D A6 01        LD        A, #0x1
   \   00009F B7 ..        LD        S:?b14, A
   \   0000A1 20 02        JRA       L:??TIM1_PWMIConfig_5
    507            }
    508            else
    509            {
    510              icpolarity = TIM1_ICPOLARITY_RISING;
   \                     ??TIM1_PWMIConfig_4:
   \   0000A3 3F ..        CLR       S:?b14
    511            }
    512            
    513            /* Select the Opposite Input */
    514            if (TIM1_ICSelection == TIM1_ICSELECTION_DIRECTTI)
   \                     ??TIM1_PWMIConfig_5:
   \   0000A5 B6 ..        LD        A, S:?b11
   \   0000A7 A1 01        CP        A, #0x1
   \   0000A9 26 06        JRNE      L:??TIM1_PWMIConfig_6
    515            {
    516              icselection = TIM1_ICSELECTION_INDIRECTTI;
   \   0000AB A6 02        LD        A, #0x2
   \   0000AD B7 ..        LD        S:?b13, A
   \   0000AF 20 04        JRA       L:??TIM1_PWMIConfig_7
    517            }
    518            else
    519            {
    520              icselection = TIM1_ICSELECTION_DIRECTTI;
   \                     ??TIM1_PWMIConfig_6:
   \   0000B1 A6 01        LD        A, #0x1
   \   0000B3 B7 ..        LD        S:?b13, A
    521            }
    522            
    523            if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??TIM1_PWMIConfig_7:
   \   0000B5 3D ..        TNZ       S:?b8
   \   0000B7 26 26        JRNE      L:??TIM1_PWMIConfig_8
    524            {
    525              /* TI1 Configuration */
    526              TI1_Config((uint8_t)TIM1_ICPolarity, (uint8_t)TIM1_ICSelection,
    527                         (uint8_t)TIM1_ICFilter);
   \   0000B9 45 .. ..     MOV       S:?b1, S:?b12
   \   0000BC 45 .. ..     MOV       S:?b0, S:?b11
   \   0000BF B6 ..        LD        A, S:?b9
   \   0000C1 8D ......    CALLF     TI1_Config
    528              
    529              /* Set the Input Capture Prescaler value */
    530              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   \   0000C5 B6 ..        LD        A, S:?b10
   \   0000C7 8D ......    CALLF     TIM1_SetIC1Prescaler
    531              
    532              /* TI2 Configuration */
    533              TI2_Config(icpolarity, icselection, TIM1_ICFilter);
   \   0000CB 45 .. ..     MOV       S:?b1, S:?b12
   \   0000CE 45 .. ..     MOV       S:?b0, S:?b13
   \   0000D1 B6 ..        LD        A, S:?b14
   \   0000D3 8D ......    CALLF     TI2_Config
    534              
    535              /* Set the Input Capture Prescaler value */
    536              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   \   0000D7 B6 ..        LD        A, S:?b10
   \   0000D9 8D ......    CALLF     TIM1_SetIC2Prescaler
   \   0000DD 20 24        JRA       L:??TIM1_PWMIConfig_9
    537            }
    538            else
    539            {
    540              /* TI2 Configuration */
    541              TI2_Config((uint8_t)TIM1_ICPolarity, (uint8_t)TIM1_ICSelection,
    542                         (uint8_t)TIM1_ICFilter);
   \                     ??TIM1_PWMIConfig_8:
   \   0000DF 45 .. ..     MOV       S:?b1, S:?b12
   \   0000E2 45 .. ..     MOV       S:?b0, S:?b11
   \   0000E5 B6 ..        LD        A, S:?b9
   \   0000E7 8D ......    CALLF     TI2_Config
    543              
    544              /* Set the Input Capture Prescaler value */
    545              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   \   0000EB B6 ..        LD        A, S:?b10
   \   0000ED 8D ......    CALLF     TIM1_SetIC2Prescaler
    546              
    547              /* TI1 Configuration */
    548              TI1_Config(icpolarity, icselection, TIM1_ICFilter);
   \   0000F1 45 .. ..     MOV       S:?b1, S:?b12
   \   0000F4 45 .. ..     MOV       S:?b0, S:?b13
   \   0000F7 B6 ..        LD        A, S:?b14
   \   0000F9 8D ......    CALLF     TI1_Config
    549              
    550              /* Set the Input Capture Prescaler value */
    551              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   \   0000FD B6 ..        LD        A, S:?b10
   \   0000FF 8D ......    CALLF     TIM1_SetIC1Prescaler
    552            }
    553          }
   \                     ??TIM1_PWMIConfig_9:
   \   000103 32 ....      POP       S:?b14
   \   000106 AC ......    JPF       L:?epilogue_l2_w6
    554          
    555          /**
    556            * @brief  Enables or disables the TIM1 peripheral.
    557            * @param  NewState new state of the TIM1 peripheral.
    558            *         This parameter can be ENABLE or DISABLE.
    559            * @retval None
    560            */

   \                                 In section .far_func.text, align 1
    561          void TIM1_Cmd(FunctionalState NewState)
    562          {
   \                     TIM1_Cmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    563            /* Check the parameters */
    564            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_Cmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_Cmd_0
   \   00000F AE 0234      LDW       X, #0x234
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    565            
    566            /* set or Reset the CEN Bit */
    567            if (NewState != DISABLE)
   \                     ??TIM1_Cmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_Cmd_1
    568            {
    569              TIM1->CR1 |= TIM1_CR1_CEN;
   \   000022 7210 5250    BSET      L:0x5250, #0x0
   \   000026 20 04        JRA       L:??TIM1_Cmd_2
    570            }
    571            else
    572            {
    573              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_CEN);
   \                     ??TIM1_Cmd_1:
   \   000028 7211 5250    BRES      L:0x5250, #0x0
    574            }
    575          }
   \                     ??TIM1_Cmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    576          
    577          /**
    578            * @brief  Enables or disables the TIM1 peripheral Main Outputs.
    579            * @param  NewState new state of the TIM1 peripheral.
    580            *         This parameter can be ENABLE or DISABLE.
    581            * @retval None
    582            */

   \                                 In section .far_func.text, align 1
    583          void TIM1_CtrlPWMOutputs(FunctionalState NewState)
    584          {
   \                     TIM1_CtrlPWMOutputs:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    585            /* Check the parameters */
    586            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_CtrlPWMOutputs_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_CtrlPWMOutputs_0
   \   00000F AE 024A      LDW       X, #0x24a
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    587            
    588            /* Set or Reset the MOE Bit */
    589            
    590            if (NewState != DISABLE)
   \                     ??TIM1_CtrlPWMOutputs_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_CtrlPWMOutputs_1
    591            {
    592              TIM1->BKR |= TIM1_BKR_MOE;
   \   000022 721E 526D    BSET      L:0x526d, #0x7
   \   000026 20 04        JRA       L:??TIM1_CtrlPWMOutputs_2
    593            }
    594            else
    595            {
    596              TIM1->BKR &= (uint8_t)(~TIM1_BKR_MOE);
   \                     ??TIM1_CtrlPWMOutputs_1:
   \   000028 721F 526D    BRES      L:0x526d, #0x7
    597            }
    598          }
   \                     ??TIM1_CtrlPWMOutputs_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    599          
    600          /**
    601            * @brief  Enables or disables the specified TIM1 interrupts.
    602            * @param  NewState new state of the TIM1 peripheral.
    603            *         This parameter can be: ENABLE or DISABLE.
    604            * @param  TIM1_IT specifies the TIM1 interrupts sources to be enabled or disabled.
    605            *         This parameter can be any combination of the following values:
    606            *           - TIM1_IT_UPDATE: TIM1 update Interrupt source
    607            *           - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
    608            *           - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
    609            *           - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
    610            *           - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
    611            *           - TIM1_IT_CCUpdate: TIM1 Capture Compare Update Interrupt source
    612            *           - TIM1_IT_TRIGGER: TIM1 Trigger Interrupt source
    613            *           - TIM1_IT_BREAK: TIM1 Break Interrupt source
    614            * @param  NewState new state of the TIM1 peripheral.
    615            * @retval None
    616            */

   \                                 In section .far_func.text, align 1
    617          void TIM1_ITConfig(TIM1_IT_TypeDef  TIM1_IT, FunctionalState NewState)
    618          {
   \                     TIM1_ITConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
   \   000006 45 .. ..     MOV       S:?b8, S:?b0
    619            /* Check the parameters */
    620            assert_param(IS_TIM1_IT_OK(TIM1_IT));
   \   000009 3D ..        TNZ       S:?b9
   \   00000B 26 0F        JRNE      L:??TIM1_ITConfig_0
   \   00000D AE 026C      LDW       X, #0x26c
   \   000010 BF ..        LDW       S:?w1, X
   \   000012 5F           CLRW      X
   \   000013 BF ..        LDW       S:?w0, X
   \   000015 AE ....      LDW       X, #?_0
   \   000018 8D ......    CALLF     assert_failed
    621            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??TIM1_ITConfig_0:
   \   00001C 3D ..        TNZ       S:?b8
   \   00001E 27 15        JREQ      L:??TIM1_ITConfig_1
   \   000020 B6 ..        LD        A, S:?b8
   \   000022 A1 01        CP        A, #0x1
   \   000024 27 0F        JREQ      L:??TIM1_ITConfig_1
   \   000026 AE 026D      LDW       X, #0x26d
   \   000029 BF ..        LDW       S:?w1, X
   \   00002B 5F           CLRW      X
   \   00002C BF ..        LDW       S:?w0, X
   \   00002E AE ....      LDW       X, #?_0
   \   000031 8D ......    CALLF     assert_failed
    622            
    623            if (NewState != DISABLE)
   \                     ??TIM1_ITConfig_1:
   \   000035 3D ..        TNZ       S:?b8
   \   000037 27 0A        JREQ      L:??TIM1_ITConfig_2
    624            {
    625              /* Enable the Interrupt sources */
    626              TIM1->IER |= (uint8_t)TIM1_IT;
   \   000039 C6 5254      LD        A, L:0x5254
   \   00003C BA ..        OR        A, S:?b9
   \   00003E C7 5254      LD        L:0x5254, A
   \   000041 20 09        JRA       L:??TIM1_ITConfig_3
    627            }
    628            else
    629            {
    630              /* Disable the Interrupt sources */
    631              TIM1->IER &= (uint8_t)(~(uint8_t)TIM1_IT);
   \                     ??TIM1_ITConfig_2:
   \   000043 B6 ..        LD        A, S:?b9
   \   000045 43           CPL       A
   \   000046 C4 5254      AND       A, L:0x5254
   \   000049 C7 5254      LD        L:0x5254, A
    632            }
    633          }
   \                     ??TIM1_ITConfig_3:
   \   00004C AC ......    JPF       L:?epilogue_w4
    634          
    635          /**
    636            * @brief  Configures the TIM1 internal Clock.
    637            * @param  None
    638            * @retval None
    639            */

   \                                 In section .far_func.text, align 1
    640          void TIM1_InternalClockConfig(void)
    641          {
    642            /* Disable slave mode to clock the prescaler directly with the internal clock */
    643            TIM1->SMCR &= (uint8_t)(~TIM1_SMCR_SMS);
   \                     TIM1_InternalClockConfig:
   \   000000 C6 5252      LD        A, L:0x5252
   \   000003 A4 F8        AND       A, #0xf8
   \   000005 C7 5252      LD        L:0x5252, A
    644          }
   \   000008 87           RETF
    645          
    646          /**
    647            * @brief  Configures the TIM1 External clock Mode1.
    648            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
    649            *         This parameter can be one of the following values:
    650            *                       - TIM1_EXTTRGPSC_OFF
    651            *                       - TIM1_EXTTRGPSC_DIV2
    652            *                       - TIM1_EXTTRGPSC_DIV4
    653            *                       - TIM1_EXTTRGPSC_DIV8.
    654            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
    655            *         This parameter can be one of the following values:
    656            *                       - TIM1_EXTTRGPOLARITY_INVERTED
    657            *                       - TIM1_EXTTRGPOLARITY_NONINVERTED
    658            * @param  ExtTRGFilter specifies the External Trigger Filter.
    659            *         This parameter must be a value between 0x00 and 0x0F
    660            * @retval None
    661            */

   \                                 In section .far_func.text, align 1
    662          void TIM1_ETRClockMode1Config(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
    663                                        TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
    664                                        uint8_t ExtTRGFilter)
    665          {
   \                     TIM1_ETRClockMode1Config:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b9, A
   \   000009 45 .. ..     MOV       S:?b8, S:?b0
   \   00000C 45 .. ..     MOV       S:?b10, S:?b1
    666            /* Check the parameters */
    667            assert_param(IS_TIM1_EXT_PRESCALER_OK(TIM1_ExtTRGPrescaler));
   \   00000F 3D ..        TNZ       S:?b9
   \   000011 27 21        JREQ      L:??TIM1_ETRClockMode1Config_0
   \   000013 B6 ..        LD        A, S:?b9
   \   000015 A1 10        CP        A, #0x10
   \   000017 27 1B        JREQ      L:??TIM1_ETRClockMode1Config_0
   \   000019 B6 ..        LD        A, S:?b9
   \   00001B A1 20        CP        A, #0x20
   \   00001D 27 15        JREQ      L:??TIM1_ETRClockMode1Config_0
   \   00001F B6 ..        LD        A, S:?b9
   \   000021 A1 30        CP        A, #0x30
   \   000023 27 0F        JREQ      L:??TIM1_ETRClockMode1Config_0
   \   000025 AE 029B      LDW       X, #0x29b
   \   000028 BF ..        LDW       S:?w1, X
   \   00002A 5F           CLRW      X
   \   00002B BF ..        LDW       S:?w0, X
   \   00002D AE ....      LDW       X, #?_0
   \   000030 8D ......    CALLF     assert_failed
    668            assert_param(IS_TIM1_EXT_POLARITY_OK(TIM1_ExtTRGPolarity));
   \                     ??TIM1_ETRClockMode1Config_0:
   \   000034 B6 ..        LD        A, S:?b8
   \   000036 A1 80        CP        A, #0x80
   \   000038 27 13        JREQ      L:??TIM1_ETRClockMode1Config_1
   \   00003A 3D ..        TNZ       S:?b8
   \   00003C 27 0F        JREQ      L:??TIM1_ETRClockMode1Config_1
   \   00003E AE 029C      LDW       X, #0x29c
   \   000041 BF ..        LDW       S:?w1, X
   \   000043 5F           CLRW      X
   \   000044 BF ..        LDW       S:?w0, X
   \   000046 AE ....      LDW       X, #?_0
   \   000049 8D ......    CALLF     assert_failed
    669            
    670            /* Configure the ETR Clock source */
    671            TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
   \                     ??TIM1_ETRClockMode1Config_1:
   \   00004D 45 .. ..     MOV       S:?b1, S:?b10
   \   000050 45 .. ..     MOV       S:?b0, S:?b8
   \   000053 B6 ..        LD        A, S:?b9
   \   000055 8D ......    CALLF     TIM1_ETRConfig
    672            
    673            /* Select the External clock mode1 & Select the Trigger selection : ETRF */
    674            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~(uint8_t)(TIM1_SMCR_SMS | TIM1_SMCR_TS )))
    675                                   | (uint8_t)((uint8_t)TIM1_SLAVEMODE_EXTERNAL1 | TIM1_TS_ETRF ));
   \   000059 C6 5252      LD        A, L:0x5252
   \   00005C AA 77        OR        A, #0x77
   \   00005E C7 5252      LD        L:0x5252, A
    676          }
   \   000061 32 ....      POP       S:?b10
   \   000064 AC ......    JPF       L:?epilogue_w4
    677          
    678          /**
    679            * @brief  Configures the TIM1 External clock Mode2.
    680            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
    681            *         This parameter can be one of the following values:
    682            *                       - TIM1_EXTTRGPSC_OFF
    683            *                       - TIM1_EXTTRGPSC_DIV2
    684            *                       - TIM1_EXTTRGPSC_DIV4
    685            *                       - TIM1_EXTTRGPSC_DIV8.
    686            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
    687            *         This parameter can be one of the following values:
    688            *                       - TIM1_EXTTRGPOLARITY_INVERTED
    689            *                       - TIM1_EXTTRGPOLARITY_NONINVERTED
    690            * @param  ExtTRGFilter specifies the External Trigger Filter.
    691            *         This parameter must be a value between 0x00 and 0x0F
    692            * @retval None
    693            */

   \                                 In section .far_func.text, align 1
    694          void TIM1_ETRClockMode2Config(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
    695                                        TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
    696                                        uint8_t ExtTRGFilter)
    697          {
   \                     TIM1_ETRClockMode2Config:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b9, A
   \   000009 45 .. ..     MOV       S:?b8, S:?b0
   \   00000C 45 .. ..     MOV       S:?b10, S:?b1
    698            /* Check the parameters */
    699            assert_param(IS_TIM1_EXT_PRESCALER_OK(TIM1_ExtTRGPrescaler));
   \   00000F 3D ..        TNZ       S:?b9
   \   000011 27 21        JREQ      L:??TIM1_ETRClockMode2Config_0
   \   000013 B6 ..        LD        A, S:?b9
   \   000015 A1 10        CP        A, #0x10
   \   000017 27 1B        JREQ      L:??TIM1_ETRClockMode2Config_0
   \   000019 B6 ..        LD        A, S:?b9
   \   00001B A1 20        CP        A, #0x20
   \   00001D 27 15        JREQ      L:??TIM1_ETRClockMode2Config_0
   \   00001F B6 ..        LD        A, S:?b9
   \   000021 A1 30        CP        A, #0x30
   \   000023 27 0F        JREQ      L:??TIM1_ETRClockMode2Config_0
   \   000025 AE 02BB      LDW       X, #0x2bb
   \   000028 BF ..        LDW       S:?w1, X
   \   00002A 5F           CLRW      X
   \   00002B BF ..        LDW       S:?w0, X
   \   00002D AE ....      LDW       X, #?_0
   \   000030 8D ......    CALLF     assert_failed
    700            assert_param(IS_TIM1_EXT_POLARITY_OK(TIM1_ExtTRGPolarity));
   \                     ??TIM1_ETRClockMode2Config_0:
   \   000034 B6 ..        LD        A, S:?b8
   \   000036 A1 80        CP        A, #0x80
   \   000038 27 13        JREQ      L:??TIM1_ETRClockMode2Config_1
   \   00003A 3D ..        TNZ       S:?b8
   \   00003C 27 0F        JREQ      L:??TIM1_ETRClockMode2Config_1
   \   00003E AE 02BC      LDW       X, #0x2bc
   \   000041 BF ..        LDW       S:?w1, X
   \   000043 5F           CLRW      X
   \   000044 BF ..        LDW       S:?w0, X
   \   000046 AE ....      LDW       X, #?_0
   \   000049 8D ......    CALLF     assert_failed
    701            
    702            /* Configure the ETR Clock source */
    703            TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
   \                     ??TIM1_ETRClockMode2Config_1:
   \   00004D 45 .. ..     MOV       S:?b1, S:?b10
   \   000050 45 .. ..     MOV       S:?b0, S:?b8
   \   000053 B6 ..        LD        A, S:?b9
   \   000055 8D ......    CALLF     TIM1_ETRConfig
    704            
    705            /* Enable the External clock mode2 */
    706            TIM1->ETR |= TIM1_ETR_ECE;
   \   000059 721C 5253    BSET      L:0x5253, #0x6
    707          }
   \   00005D 32 ....      POP       S:?b10
   \   000060 AC ......    JPF       L:?epilogue_w4
    708          
    709          /**
    710            * @brief  Configures the TIM1 External Trigger.
    711            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
    712            *         This parameter can be one of the following values:
    713            *                       - TIM1_EXTTRGPSC_OFF
    714            *                       - TIM1_EXTTRGPSC_DIV2
    715            *                       - TIM1_EXTTRGPSC_DIV4
    716            *                       - TIM1_EXTTRGPSC_DIV8.
    717            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
    718            *         This parameter can be one of the following values:
    719            *                       - TIM1_EXTTRGPOLARITY_INVERTED
    720            *                       - TIM1_EXTTRGPOLARITY_NONINVERTED
    721            * @param  ExtTRGFilter specifies the External Trigger Filter.
    722            *         This parameter must be a value between 0x00 and 0x0F
    723            * @retval None
    724            */

   \                                 In section .far_func.text, align 1
    725          void TIM1_ETRConfig(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
    726                              TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
    727                              uint8_t ExtTRGFilter)
    728          {
   \                     TIM1_ETRConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b9, A
   \   000009 45 .. ..     MOV       S:?b8, S:?b0
   \   00000C 45 .. ..     MOV       S:?b10, S:?b1
    729            /* Check the parameters */
    730            assert_param(IS_TIM1_EXT_TRG_FILTER_OK(ExtTRGFilter));
   \   00000F B6 ..        LD        A, S:?b10
   \   000011 A1 10        CP        A, #0x10
   \   000013 25 0F        JRC       L:??TIM1_ETRConfig_0
   \   000015 AE 02DA      LDW       X, #0x2da
   \   000018 BF ..        LDW       S:?w1, X
   \   00001A 5F           CLRW      X
   \   00001B BF ..        LDW       S:?w0, X
   \   00001D AE ....      LDW       X, #?_0
   \   000020 8D ......    CALLF     assert_failed
    731            /* Set the Prescaler, the Filter value and the Polarity */
    732            TIM1->ETR |= (uint8_t)((uint8_t)(TIM1_ExtTRGPrescaler | (uint8_t)TIM1_ExtTRGPolarity )|
    733                                   (uint8_t)ExtTRGFilter );
   \                     ??TIM1_ETRConfig_0:
   \   000024 B6 ..        LD        A, S:?b8
   \   000026 BA ..        OR        A, S:?b9
   \   000028 BA ..        OR        A, S:?b10
   \   00002A CA 5253      OR        A, L:0x5253
   \   00002D C7 5253      LD        L:0x5253, A
    734          }
   \   000030 32 ....      POP       S:?b10
   \   000033 AC ......    JPF       L:?epilogue_w4
    735          
    736          /**
    737            * @brief  Configures the TIM1 Trigger as External Clock.
    738            * @param  TIM1_TIxExternalCLKSource specifies Trigger source.
    739            *         This parameter can be one of the following values:
    740            *                     - TIM1_TIXEXTERNALCLK1SOURCE_TI1: TI1 Edge Detector
    741            *                     - TIM1_TIXEXTERNALCLK1SOURCE_TI2: Filtered TIM1 Input 1
    742            *                     - TIM1_TIXEXTERNALCLK1SOURCE_TI1ED: Filtered TIM1 Input 2
    743            * @param  TIM1_ICPolarity specifies the TIx Polarity.
    744            *         This parameter can be:
    745            *                     - TIM1_ICPOLARITY_RISING
    746            *                     - TIM1_ICPOLARITY_FALLING
    747            * @param  ICFilter specifies the filter value.
    748            *         This parameter must be a value between 0x00 and 0x0F
    749            * @retval None
    750            */

   \                                 In section .far_func.text, align 1
    751          void TIM1_TIxExternalClockConfig(TIM1_TIxExternalCLK1Source_TypeDef TIM1_TIxExternalCLKSource,
    752                                           TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
    753                                           uint8_t ICFilter)
    754          {
   \                     TIM1_TIxExternalClockConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b9, A
   \   000009 45 .. ..     MOV       S:?b8, S:?b0
   \   00000C 45 .. ..     MOV       S:?b10, S:?b1
    755            /* Check the parameters */
    756            assert_param(IS_TIM1_TIXCLK_SOURCE_OK(TIM1_TIxExternalCLKSource));
   \   00000F B6 ..        LD        A, S:?b9
   \   000011 A1 40        CP        A, #0x40
   \   000013 27 1B        JREQ      L:??TIM1_TIxExternalClockConfig_0
   \   000015 B6 ..        LD        A, S:?b9
   \   000017 A1 60        CP        A, #0x60
   \   000019 27 15        JREQ      L:??TIM1_TIxExternalClockConfig_0
   \   00001B B6 ..        LD        A, S:?b9
   \   00001D A1 50        CP        A, #0x50
   \   00001F 27 0F        JREQ      L:??TIM1_TIxExternalClockConfig_0
   \   000021 AE 02F4      LDW       X, #0x2f4
   \   000024 BF ..        LDW       S:?w1, X
   \   000026 5F           CLRW      X
   \   000027 BF ..        LDW       S:?w0, X
   \   000029 AE ....      LDW       X, #?_0
   \   00002C 8D ......    CALLF     assert_failed
    757            assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_ICPolarity));
   \                     ??TIM1_TIxExternalClockConfig_0:
   \   000030 3D ..        TNZ       S:?b8
   \   000032 27 15        JREQ      L:??TIM1_TIxExternalClockConfig_1
   \   000034 B6 ..        LD        A, S:?b8
   \   000036 A1 01        CP        A, #0x1
   \   000038 27 0F        JREQ      L:??TIM1_TIxExternalClockConfig_1
   \   00003A AE 02F5      LDW       X, #0x2f5
   \   00003D BF ..        LDW       S:?w1, X
   \   00003F 5F           CLRW      X
   \   000040 BF ..        LDW       S:?w0, X
   \   000042 AE ....      LDW       X, #?_0
   \   000045 8D ......    CALLF     assert_failed
    758            assert_param(IS_TIM1_IC_FILTER_OK(ICFilter));
   \                     ??TIM1_TIxExternalClockConfig_1:
   \   000049 B6 ..        LD        A, S:?b10
   \   00004B A1 10        CP        A, #0x10
   \   00004D 25 0F        JRC       L:??TIM1_TIxExternalClockConfig_2
   \   00004F AE 02F6      LDW       X, #0x2f6
   \   000052 BF ..        LDW       S:?w1, X
   \   000054 5F           CLRW      X
   \   000055 BF ..        LDW       S:?w0, X
   \   000057 AE ....      LDW       X, #?_0
   \   00005A 8D ......    CALLF     assert_failed
    759            
    760            /* Configure the TIM1 Input Clock Source */
    761            if (TIM1_TIxExternalCLKSource == TIM1_TIXEXTERNALCLK1SOURCE_TI2)
   \                     ??TIM1_TIxExternalClockConfig_2:
   \   00005E B6 ..        LD        A, S:?b9
   \   000060 A1 60        CP        A, #0x60
   \   000062 26 0F        JRNE      L:??TIM1_TIxExternalClockConfig_3
    762            {
    763              TI2_Config((uint8_t)TIM1_ICPolarity, (uint8_t)TIM1_ICSELECTION_DIRECTTI, (uint8_t)ICFilter);
   \   000064 45 .. ..     MOV       S:?b1, S:?b10
   \   000067 35 01 ....   MOV       S:?b0, #0x1
   \   00006B B6 ..        LD        A, S:?b8
   \   00006D 8D ......    CALLF     TI2_Config
   \   000071 20 0D        JRA       L:??TIM1_TIxExternalClockConfig_4
    764            }
    765            else
    766            {
    767              TI1_Config((uint8_t)TIM1_ICPolarity, (uint8_t)TIM1_ICSELECTION_DIRECTTI, (uint8_t)ICFilter);
   \                     ??TIM1_TIxExternalClockConfig_3:
   \   000073 45 .. ..     MOV       S:?b1, S:?b10
   \   000076 35 01 ....   MOV       S:?b0, #0x1
   \   00007A B6 ..        LD        A, S:?b8
   \   00007C 8D ......    CALLF     TI1_Config
    768            }
    769            
    770            /* Select the Trigger source */
    771            TIM1_SelectInputTrigger((TIM1_TS_TypeDef)TIM1_TIxExternalCLKSource);
   \                     ??TIM1_TIxExternalClockConfig_4:
   \   000080 B6 ..        LD        A, S:?b9
   \   000082 8D ......    CALLF     TIM1_SelectInputTrigger
    772            
    773            /* Select the External clock mode1 */
    774            TIM1->SMCR |= (uint8_t)(TIM1_SLAVEMODE_EXTERNAL1);
   \   000086 C6 5252      LD        A, L:0x5252
   \   000089 AA 07        OR        A, #0x7
   \   00008B C7 5252      LD        L:0x5252, A
    775          }
   \   00008E 32 ....      POP       S:?b10
   \   000091 AC ......    JPF       L:?epilogue_w4
    776          
    777          /**
    778            * @brief  Selects the TIM1 Input Trigger source.
    779            * @param   TIM1_InputTriggerSource specifies Input Trigger source.
    780            * This parameter can be one of the following values:
    781            *                       - TIM1_TS_TI1F_ED: TI1 Edge Detector
    782            *                       - TIM1_TS_TI1FP1: Filtered Timer Input 1
    783            *                       - TIM1_TS_TI2FP2: Filtered Timer Input 2
    784            *                       - TIM1_TS_ETRF: External Trigger input
    785            * @retval None
    786            */

   \                                 In section .far_func.text, align 1
    787          void TIM1_SelectInputTrigger(TIM1_TS_TypeDef TIM1_InputTriggerSource)
    788          {
   \                     TIM1_SelectInputTrigger:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    789            /* Check the parameters */
    790            assert_param(IS_TIM1_TRIGGER_SELECTION_OK(TIM1_InputTriggerSource));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 40        CP        A, #0x40
   \   000009 27 2B        JREQ      L:??TIM1_SelectInputTrigger_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 50        CP        A, #0x50
   \   00000F 27 25        JREQ      L:??TIM1_SelectInputTrigger_0
   \   000011 B6 ..        LD        A, S:?b8
   \   000013 A1 60        CP        A, #0x60
   \   000015 27 1F        JREQ      L:??TIM1_SelectInputTrigger_0
   \   000017 B6 ..        LD        A, S:?b8
   \   000019 A1 70        CP        A, #0x70
   \   00001B 27 19        JREQ      L:??TIM1_SelectInputTrigger_0
   \   00001D B6 ..        LD        A, S:?b8
   \   00001F A1 30        CP        A, #0x30
   \   000021 27 13        JREQ      L:??TIM1_SelectInputTrigger_0
   \   000023 3D ..        TNZ       S:?b8
   \   000025 27 0F        JREQ      L:??TIM1_SelectInputTrigger_0
   \   000027 AE 0316      LDW       X, #0x316
   \   00002A BF ..        LDW       S:?w1, X
   \   00002C 5F           CLRW      X
   \   00002D BF ..        LDW       S:?w0, X
   \   00002F AE ....      LDW       X, #?_0
   \   000032 8D ......    CALLF     assert_failed
    791            
    792            /* Select the Tgigger Source */
    793            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~TIM1_SMCR_TS)) | (uint8_t)TIM1_InputTriggerSource);
   \                     ??TIM1_SelectInputTrigger_0:
   \   000036 C6 5252      LD        A, L:0x5252
   \   000039 A4 8F        AND       A, #0x8f
   \   00003B BA ..        OR        A, S:?b8
   \   00003D C7 5252      LD        L:0x5252, A
    794          }
   \   000040 32 ....      POP       S:?b8
   \   000043 87           RETF
    795          
    796          /**
    797            * @brief  Enables or Disables the TIM1 Update event.
    798            * @param   NewState new state of the TIM1 peripheral Preload register. This parameter can
    799            * be ENABLE or DISABLE.
    800            * @retval None
    801            */
    802          

   \                                 In section .far_func.text, align 1
    803          void TIM1_UpdateDisableConfig(FunctionalState NewState)
    804          {
   \                     TIM1_UpdateDisableConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    805            /* Check the parameters */
    806            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_UpdateDisableConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_UpdateDisableConfig_0
   \   00000F AE 0326      LDW       X, #0x326
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    807            
    808            /* Set or Reset the UDIS Bit */
    809            if (NewState != DISABLE)
   \                     ??TIM1_UpdateDisableConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_UpdateDisableConfig_1
    810            {
    811              TIM1->CR1 |= TIM1_CR1_UDIS;
   \   000022 7212 5250    BSET      L:0x5250, #0x1
   \   000026 20 04        JRA       L:??TIM1_UpdateDisableConfig_2
    812            }
    813            else
    814            {
    815              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_UDIS);
   \                     ??TIM1_UpdateDisableConfig_1:
   \   000028 7213 5250    BRES      L:0x5250, #0x1
    816            }
    817          }
   \                     ??TIM1_UpdateDisableConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    818          
    819          /**
    820            * @brief  Selects the TIM1 Update Request Interrupt source.
    821            * @param   TIM1_UpdateSource specifies the Update source.
    822            * This parameter can be one of the following values
    823            *                       - TIM1_UPDATESOURCE_REGULAR
    824            *                       - TIM1_UPDATESOURCE_GLOBAL
    825            * @retval None
    826            */

   \                                 In section .far_func.text, align 1
    827          void TIM1_UpdateRequestConfig(TIM1_UpdateSource_TypeDef TIM1_UpdateSource)
    828          {
   \                     TIM1_UpdateRequestConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    829            /* Check the parameters */
    830            assert_param(IS_TIM1_UPDATE_SOURCE_OK(TIM1_UpdateSource));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_UpdateRequestConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_UpdateRequestConfig_0
   \   00000F AE 033E      LDW       X, #0x33e
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    831            
    832            /* Set or Reset the URS Bit */
    833            if (TIM1_UpdateSource != TIM1_UPDATESOURCE_GLOBAL)
   \                     ??TIM1_UpdateRequestConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_UpdateRequestConfig_1
    834            {
    835              TIM1->CR1 |= TIM1_CR1_URS;
   \   000022 7214 5250    BSET      L:0x5250, #0x2
   \   000026 20 04        JRA       L:??TIM1_UpdateRequestConfig_2
    836            }
    837            else
    838            {
    839              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_URS);
   \                     ??TIM1_UpdateRequestConfig_1:
   \   000028 7215 5250    BRES      L:0x5250, #0x2
    840            }
    841          }
   \                     ??TIM1_UpdateRequestConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    842          
    843          /**
    844            * @brief  Enables or Disables the TIM1s Hall sensor interface.
    845            * @param   NewState new state of the TIM1 Hall sensor interface.This parameter can
    846            * be ENABLE or DISABLE.
    847            * @retval None
    848            */

   \                                 In section .far_func.text, align 1
    849          void TIM1_SelectHallSensor(FunctionalState NewState)
    850          {
   \                     TIM1_SelectHallSensor:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    851            /* Check the parameters */
    852            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_SelectHallSensor_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_SelectHallSensor_0
   \   00000F AE 0354      LDW       X, #0x354
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    853            
    854            /* Set or Reset the TI1S Bit */
    855            if (NewState != DISABLE)
   \                     ??TIM1_SelectHallSensor_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_SelectHallSensor_1
    856            {
    857              TIM1->CR2 |= TIM1_CR2_TI1S;
   \   000022 721E 5251    BSET      L:0x5251, #0x7
   \   000026 20 04        JRA       L:??TIM1_SelectHallSensor_2
    858            }
    859            else
    860            {
    861              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_TI1S);
   \                     ??TIM1_SelectHallSensor_1:
   \   000028 721F 5251    BRES      L:0x5251, #0x7
    862            }
    863          }
   \                     ??TIM1_SelectHallSensor_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    864          
    865          /**
    866            * @brief  Selects the TIM1s One Pulse Mode.
    867            * @param   TIM1_OPMode specifies the OPM Mode to be used.
    868            * This parameter can be one of the following values
    869            *                    - TIM1_OPMODE_SINGLE
    870            *                    - TIM1_OPMODE_REPETITIVE
    871            * @retval None
    872            */

   \                                 In section .far_func.text, align 1
    873          void TIM1_SelectOnePulseMode(TIM1_OPMode_TypeDef TIM1_OPMode)
    874          {
   \                     TIM1_SelectOnePulseMode:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    875            /* Check the parameters */
    876            assert_param(IS_TIM1_OPM_MODE_OK(TIM1_OPMode));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 01        CP        A, #0x1
   \   000009 27 13        JREQ      L:??TIM1_SelectOnePulseMode_0
   \   00000B 3D ..        TNZ       S:?b8
   \   00000D 27 0F        JREQ      L:??TIM1_SelectOnePulseMode_0
   \   00000F AE 036C      LDW       X, #0x36c
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    877            
    878            /* Set or Reset the OPM Bit */
    879            if (TIM1_OPMode != TIM1_OPMODE_REPETITIVE)
   \                     ??TIM1_SelectOnePulseMode_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_SelectOnePulseMode_1
    880            {
    881              TIM1->CR1 |= TIM1_CR1_OPM;
   \   000022 7216 5250    BSET      L:0x5250, #0x3
   \   000026 20 04        JRA       L:??TIM1_SelectOnePulseMode_2
    882            }
    883            else
    884            {
    885              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_OPM);
   \                     ??TIM1_SelectOnePulseMode_1:
   \   000028 7217 5250    BRES      L:0x5250, #0x3
    886            }
    887            
    888          }
   \                     ??TIM1_SelectOnePulseMode_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    889          
    890          /**
    891            * @brief  Selects the TIM1 Trigger Output Mode.
    892            * @param   TIM1_TRGOSource specifies the Trigger Output source.
    893            * This parameter can be one of the following values
    894            *                       - TIM1_TRGOSOURCE_RESET
    895            *                       - TIM1_TRGOSOURCE_ENABLE
    896            *                       - TIM1_TRGOSOURCE_UPDATE
    897            *                       - TIM1_TRGOSource_OC1
    898            *                       - TIM1_TRGOSOURCE_OC1REF
    899            *                       - TIM1_TRGOSOURCE_OC2REF
    900            *                       - TIM1_TRGOSOURCE_OC3REF
    901            * @retval None
    902            */

   \                                 In section .far_func.text, align 1
    903          void TIM1_SelectOutputTrigger(TIM1_TRGOSource_TypeDef TIM1_TRGOSource)
    904          {
   \                     TIM1_SelectOutputTrigger:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    905            /* Check the parameters */
    906            assert_param(IS_TIM1_TRGO_SOURCE_OK(TIM1_TRGOSource));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 33        JREQ      L:??TIM1_SelectOutputTrigger_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 10        CP        A, #0x10
   \   00000D 27 2D        JREQ      L:??TIM1_SelectOutputTrigger_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 20        CP        A, #0x20
   \   000013 27 27        JREQ      L:??TIM1_SelectOutputTrigger_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 30        CP        A, #0x30
   \   000019 27 21        JREQ      L:??TIM1_SelectOutputTrigger_0
   \   00001B B6 ..        LD        A, S:?b8
   \   00001D A1 40        CP        A, #0x40
   \   00001F 27 1B        JREQ      L:??TIM1_SelectOutputTrigger_0
   \   000021 B6 ..        LD        A, S:?b8
   \   000023 A1 50        CP        A, #0x50
   \   000025 27 15        JREQ      L:??TIM1_SelectOutputTrigger_0
   \   000027 B6 ..        LD        A, S:?b8
   \   000029 A1 60        CP        A, #0x60
   \   00002B 27 0F        JREQ      L:??TIM1_SelectOutputTrigger_0
   \   00002D AE 038A      LDW       X, #0x38a
   \   000030 BF ..        LDW       S:?w1, X
   \   000032 5F           CLRW      X
   \   000033 BF ..        LDW       S:?w0, X
   \   000035 AE ....      LDW       X, #?_0
   \   000038 8D ......    CALLF     assert_failed
    907            
    908            /* Reset the MMS Bits & Select the TRGO source */
    909            TIM1->CR2 = (uint8_t)((uint8_t)(TIM1->CR2 & (uint8_t)(~TIM1_CR2_MMS)) | 
    910                                  (uint8_t) TIM1_TRGOSource);
   \                     ??TIM1_SelectOutputTrigger_0:
   \   00003C C6 5251      LD        A, L:0x5251
   \   00003F A4 8F        AND       A, #0x8f
   \   000041 BA ..        OR        A, S:?b8
   \   000043 C7 5251      LD        L:0x5251, A
    911          }
   \   000046 32 ....      POP       S:?b8
   \   000049 87           RETF
    912          
    913          /**
    914            * @brief  Selects the TIM1 Slave Mode.
    915            * @param   TIM1_SlaveMode specifies the TIM1 Slave Mode.
    916            * This parameter can be one of the following values
    917            *                       - TIM1_SLAVEMODE_RESET
    918            *                       - TIM1_SLAVEMODE_GATED
    919            *                       - TIM1_SLAVEMODE_TRIGGER
    920            *                       - TIM1_SLAVEMODE_EXTERNAL1
    921            * @retval None
    922            */

   \                                 In section .far_func.text, align 1
    923          void TIM1_SelectSlaveMode(TIM1_SlaveMode_TypeDef TIM1_SlaveMode)
    924          {
   \                     TIM1_SelectSlaveMode:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    925            /* Check the parameters */
    926            assert_param(IS_TIM1_SLAVE_MODE_OK(TIM1_SlaveMode));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 04        CP        A, #0x4
   \   000009 27 21        JREQ      L:??TIM1_SelectSlaveMode_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 05        CP        A, #0x5
   \   00000F 27 1B        JREQ      L:??TIM1_SelectSlaveMode_0
   \   000011 B6 ..        LD        A, S:?b8
   \   000013 A1 06        CP        A, #0x6
   \   000015 27 15        JREQ      L:??TIM1_SelectSlaveMode_0
   \   000017 B6 ..        LD        A, S:?b8
   \   000019 A1 07        CP        A, #0x7
   \   00001B 27 0F        JREQ      L:??TIM1_SelectSlaveMode_0
   \   00001D AE 039E      LDW       X, #0x39e
   \   000020 BF ..        LDW       S:?w1, X
   \   000022 5F           CLRW      X
   \   000023 BF ..        LDW       S:?w0, X
   \   000025 AE ....      LDW       X, #?_0
   \   000028 8D ......    CALLF     assert_failed
    927            
    928            /* Reset the SMS Bits */ /* Select the Slave Mode */
    929            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~TIM1_SMCR_SMS)) |
    930                                   (uint8_t)TIM1_SlaveMode);
   \                     ??TIM1_SelectSlaveMode_0:
   \   00002C C6 5252      LD        A, L:0x5252
   \   00002F A4 F8        AND       A, #0xf8
   \   000031 BA ..        OR        A, S:?b8
   \   000033 C7 5252      LD        L:0x5252, A
    931          }
   \   000036 32 ....      POP       S:?b8
   \   000039 87           RETF
    932          
    933          /**
    934            * @brief  Sets or Resets the TIM1 Master/Slave Mode.
    935            * @param   NewState new state of the synchronization between TIM1 and its slaves
    936            *  (through TRGO). This parameter can be ENABLE or DISABLE.
    937            * @retval None
    938            */

   \                                 In section .far_func.text, align 1
    939          void TIM1_SelectMasterSlaveMode(FunctionalState NewState)
    940          {
   \                     TIM1_SelectMasterSlaveMode:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    941            /* Check the parameters */
    942            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_SelectMasterSlaveMode_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_SelectMasterSlaveMode_0
   \   00000F AE 03AE      LDW       X, #0x3ae
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    943            
    944            /* Set or Reset the MSM Bit */
    945            if (NewState != DISABLE)
   \                     ??TIM1_SelectMasterSlaveMode_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_SelectMasterSlaveMode_1
    946            {
    947              TIM1->SMCR |= TIM1_SMCR_MSM;
   \   000022 721E 5252    BSET      L:0x5252, #0x7
   \   000026 20 04        JRA       L:??TIM1_SelectMasterSlaveMode_2
    948            }
    949            else
    950            {
    951              TIM1->SMCR &= (uint8_t)(~TIM1_SMCR_MSM);
   \                     ??TIM1_SelectMasterSlaveMode_1:
   \   000028 721F 5252    BRES      L:0x5252, #0x7
    952            }
    953          }
   \                     ??TIM1_SelectMasterSlaveMode_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    954          
    955          /**
    956            * @brief  Configures the TIM1 Encoder Interface.
    957            * @param   TIM1_EncoderMode specifies the TIM1 Encoder Mode.
    958            * This parameter can be one of the following values
    959            * - TIM1_ENCODERMODE_TI1: Counter counts on TI1FP1 edge
    960          	* depending on TI2FP2 level.
    961            * - TIM1_ENCODERMODE_TI2: Counter counts on TI2FP2 edge
    962            *	depending on TI1FP1 level.
    963            * - TIM1_ENCODERMODE_TI12: Counter counts on both TI1FP1 and
    964            * TI2FP2 edges depending on the level of the other input.
    965            * @param   TIM1_IC1Polarity specifies the IC1 Polarity.
    966            * This parameter can be one of the following values
    967            *                       - TIM1_ICPOLARITY_FALLING
    968            *                       - TIM1_ICPOLARITY_RISING
    969            * @param   TIM1_IC2Polarity specifies the IC2 Polarity.
    970            * This parameter can be one of the following values
    971            *                       - TIM1_ICPOLARITY_FALLING
    972            *                       - TIM1_ICPOLARITY_RISING
    973            * @retval None
    974            */

   \                                 In section .far_func.text, align 1
    975          void TIM1_EncoderInterfaceConfig(TIM1_EncoderMode_TypeDef TIM1_EncoderMode,
    976                                           TIM1_ICPolarity_TypeDef TIM1_IC1Polarity,
    977                                           TIM1_ICPolarity_TypeDef TIM1_IC2Polarity)
    978          {
   \                     TIM1_EncoderInterfaceConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b10, A
   \   000009 45 .. ..     MOV       S:?b9, S:?b0
   \   00000C 45 .. ..     MOV       S:?b8, S:?b1
    979            /* Check the parameters */
    980            assert_param(IS_TIM1_ENCODER_MODE_OK(TIM1_EncoderMode));
   \   00000F B6 ..        LD        A, S:?b10
   \   000011 A1 01        CP        A, #0x1
   \   000013 27 1B        JREQ      L:??TIM1_EncoderInterfaceConfig_0
   \   000015 B6 ..        LD        A, S:?b10
   \   000017 A1 02        CP        A, #0x2
   \   000019 27 15        JREQ      L:??TIM1_EncoderInterfaceConfig_0
   \   00001B B6 ..        LD        A, S:?b10
   \   00001D A1 03        CP        A, #0x3
   \   00001F 27 0F        JREQ      L:??TIM1_EncoderInterfaceConfig_0
   \   000021 AE 03D4      LDW       X, #0x3d4
   \   000024 BF ..        LDW       S:?w1, X
   \   000026 5F           CLRW      X
   \   000027 BF ..        LDW       S:?w0, X
   \   000029 AE ....      LDW       X, #?_0
   \   00002C 8D ......    CALLF     assert_failed
    981            assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_IC1Polarity));
   \                     ??TIM1_EncoderInterfaceConfig_0:
   \   000030 3D ..        TNZ       S:?b9
   \   000032 27 15        JREQ      L:??TIM1_EncoderInterfaceConfig_1
   \   000034 B6 ..        LD        A, S:?b9
   \   000036 A1 01        CP        A, #0x1
   \   000038 27 0F        JREQ      L:??TIM1_EncoderInterfaceConfig_1
   \   00003A AE 03D5      LDW       X, #0x3d5
   \   00003D BF ..        LDW       S:?w1, X
   \   00003F 5F           CLRW      X
   \   000040 BF ..        LDW       S:?w0, X
   \   000042 AE ....      LDW       X, #?_0
   \   000045 8D ......    CALLF     assert_failed
    982            assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_IC2Polarity));
   \                     ??TIM1_EncoderInterfaceConfig_1:
   \   000049 3D ..        TNZ       S:?b8
   \   00004B 27 15        JREQ      L:??TIM1_EncoderInterfaceConfig_2
   \   00004D B6 ..        LD        A, S:?b8
   \   00004F A1 01        CP        A, #0x1
   \   000051 27 0F        JREQ      L:??TIM1_EncoderInterfaceConfig_2
   \   000053 AE 03D6      LDW       X, #0x3d6
   \   000056 BF ..        LDW       S:?w1, X
   \   000058 5F           CLRW      X
   \   000059 BF ..        LDW       S:?w0, X
   \   00005B AE ....      LDW       X, #?_0
   \   00005E 8D ......    CALLF     assert_failed
    983            
    984            /* Set the TI1 and the TI2 Polarities */
    985            if (TIM1_IC1Polarity != TIM1_ICPOLARITY_RISING)
   \                     ??TIM1_EncoderInterfaceConfig_2:
   \   000062 3D ..        TNZ       S:?b9
   \   000064 27 06        JREQ      L:??TIM1_EncoderInterfaceConfig_3
    986            {
    987              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \   000066 7212 525C    BSET      L:0x525c, #0x1
   \   00006A 20 04        JRA       L:??TIM1_EncoderInterfaceConfig_4
    988            }
    989            else
    990            {
    991              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TIM1_EncoderInterfaceConfig_3:
   \   00006C 7213 525C    BRES      L:0x525c, #0x1
    992            }
    993            
    994            if (TIM1_IC2Polarity != TIM1_ICPOLARITY_RISING)
   \                     ??TIM1_EncoderInterfaceConfig_4:
   \   000070 3D ..        TNZ       S:?b8
   \   000072 27 06        JREQ      L:??TIM1_EncoderInterfaceConfig_5
    995            {
    996              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \   000074 721A 525C    BSET      L:0x525c, #0x5
   \   000078 20 04        JRA       L:??TIM1_EncoderInterfaceConfig_6
    997            }
    998            else
    999            {
   1000              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TIM1_EncoderInterfaceConfig_5:
   \   00007A 721B 525C    BRES      L:0x525c, #0x5
   1001            }
   1002            /* Set the encoder Mode */
   1003            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(TIM1_SMCR_MSM | TIM1_SMCR_TS))
   1004                                   | (uint8_t) TIM1_EncoderMode);
   \                     ??TIM1_EncoderInterfaceConfig_6:
   \   00007E C6 5252      LD        A, L:0x5252
   \   000081 A4 F0        AND       A, #0xf0
   \   000083 BA ..        OR        A, S:?b10
   \   000085 C7 5252      LD        L:0x5252, A
   1005            
   1006            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1007            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_CCxS)) 
   1008                                    | (uint8_t) CCMR_TIxDirect_Set);
   \   000088 C6 5258      LD        A, L:0x5258
   \   00008B A4 FC        AND       A, #0xfc
   \   00008D AA 01        OR        A, #0x1
   \   00008F C7 5258      LD        L:0x5258, A
   1009            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_CCxS))
   1010                                    | (uint8_t) CCMR_TIxDirect_Set);
   \   000092 C6 5259      LD        A, L:0x5259
   \   000095 A4 FC        AND       A, #0xfc
   \   000097 AA 01        OR        A, #0x1
   \   000099 C7 5259      LD        L:0x5259, A
   1011          }
   \   00009C 32 ....      POP       S:?b10
   \   00009F AC ......    JPF       L:?epilogue_w4
   1012          
   1013          /**
   1014            * @brief  Configures the TIM1 Prescaler.
   1015            * @param   Prescaler specifies the Prescaler Register value
   1016            * This parameter must be a value between 0x0000 and 0xFFFF
   1017            * @param   TIM1_PSCReloadMode specifies the TIM1 Prescaler Reload mode.
   1018            * This parameter can be one of the following values
   1019            * - TIM1_PSCRELOADMODE_IMMEDIATE: The Prescaler is loaded immediately.
   1020            * - TIM1_PSCRELOADMODE_UPDATE: The Prescaler is loaded at the update event.
   1021            * @retval None
   1022            */

   \                                 In section .far_func.text, align 1
   1023          void TIM1_PrescalerConfig(uint16_t Prescaler,
   1024                                    TIM1_PSCReloadMode_TypeDef TIM1_PSCReloadMode)
   1025          {
   \                     TIM1_PrescalerConfig:
   \   000000 8D ......    CALLF     L:?push_w5
   \   000004 3B ....      PUSH      S:?b8
   \   000007 BF ..        LDW       S:?w5, X
   \   000009 B7 ..        LD        S:?b8, A
   1026            /* Check the parameters */
   1027            assert_param(IS_TIM1_PRESCALER_RELOAD_OK(TIM1_PSCReloadMode));
   \   00000B 3D ..        TNZ       S:?b8
   \   00000D 27 15        JREQ      L:??TIM1_PrescalerConfig_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 01        CP        A, #0x1
   \   000013 27 0F        JREQ      L:??TIM1_PrescalerConfig_0
   \   000015 AE 0403      LDW       X, #0x403
   \   000018 BF ..        LDW       S:?w1, X
   \   00001A 5F           CLRW      X
   \   00001B BF ..        LDW       S:?w0, X
   \   00001D AE ....      LDW       X, #?_0
   \   000020 8D ......    CALLF     assert_failed
   1028            
   1029            /* Set the Prescaler value */
   1030            TIM1->PSCRH = (uint8_t)(Prescaler >> 8);
   \                     ??TIM1_PrescalerConfig_0:
   \   000024 B6 ..        LD        A, S:?b10
   \   000026 C7 5260      LD        L:0x5260, A
   1031            TIM1->PSCRL = (uint8_t)(Prescaler);
   \   000029 B6 ..        LD        A, S:?b11
   \   00002B C7 5261      LD        L:0x5261, A
   1032            
   1033            /* Set or reset the UG Bit */
   1034            TIM1->EGR = (uint8_t)TIM1_PSCReloadMode;
   \   00002E B6 ..        LD        A, S:?b8
   \   000030 C7 5257      LD        L:0x5257, A
   1035          }
   \   000033 32 ....      POP       S:?b8
   \   000036 8D ......    CALLF     L:?pop_w5
   \   00003A 87           RETF
   1036          
   1037          /**
   1038            * @brief  Specifies the TIM1 Counter Mode to be used.
   1039            * @param   TIM1_CounterMode specifies the Counter Mode to be used
   1040            * This parameter can be one of the following values:
   1041            * - TIM1_COUNTERMODE_UP: TIM1 Up Counting Mode
   1042            * - TIM1_COUNTERMODE_DOWN: TIM1 Down Counting Mode
   1043            * - TIM1_COUNTERMODE_CENTERALIGNED1: TIM1 Center Aligned Mode1
   1044            * - TIM1_CounterMode_CenterAligned2: TIM1 Center Aligned Mode2
   1045            * - TIM1_COUNTERMODE_CENTERALIGNED3: TIM1 Center Aligned Mode3
   1046            * @retval None
   1047            */

   \                                 In section .far_func.text, align 1
   1048          void TIM1_CounterModeConfig(TIM1_CounterMode_TypeDef TIM1_CounterMode)
   1049          {
   \                     TIM1_CounterModeConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1050            /* Check the parameters */
   1051            assert_param(IS_TIM1_COUNTER_MODE_OK(TIM1_CounterMode));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 27        JREQ      L:??TIM1_CounterModeConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 10        CP        A, #0x10
   \   00000D 27 21        JREQ      L:??TIM1_CounterModeConfig_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 20        CP        A, #0x20
   \   000013 27 1B        JREQ      L:??TIM1_CounterModeConfig_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 40        CP        A, #0x40
   \   000019 27 15        JREQ      L:??TIM1_CounterModeConfig_0
   \   00001B B6 ..        LD        A, S:?b8
   \   00001D A1 60        CP        A, #0x60
   \   00001F 27 0F        JREQ      L:??TIM1_CounterModeConfig_0
   \   000021 AE 041B      LDW       X, #0x41b
   \   000024 BF ..        LDW       S:?w1, X
   \   000026 5F           CLRW      X
   \   000027 BF ..        LDW       S:?w0, X
   \   000029 AE ....      LDW       X, #?_0
   \   00002C 8D ......    CALLF     assert_failed
   1052            
   1053            
   1054            /* Reset the CMS and DIR Bits & Set the Counter Mode */
   1055            TIM1->CR1 = (uint8_t)((uint8_t)(TIM1->CR1 & (uint8_t)((uint8_t)(~TIM1_CR1_CMS) & (uint8_t)(~TIM1_CR1_DIR)))
   1056                                  | (uint8_t)TIM1_CounterMode);
   \                     ??TIM1_CounterModeConfig_0:
   \   000030 C6 5250      LD        A, L:0x5250
   \   000033 A4 8F        AND       A, #0x8f
   \   000035 BA ..        OR        A, S:?b8
   \   000037 C7 5250      LD        L:0x5250, A
   1057          }
   \   00003A 32 ....      POP       S:?b8
   \   00003D 87           RETF
   1058          
   1059          /**
   1060            * @brief  Forces the TIM1 Channel1 output waveform to active or inactive level.
   1061            * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1062            * This parameter can be one of the following values:
   1063            * - TIM1_FORCEDACTION_ACTIVE: Force active level on OC1REF
   1064            * - TIM1_FORCEDACTION_INACTIVE: Force inactive level on OC1REF.
   1065            * @retval None
   1066            */

   \                                 In section .far_func.text, align 1
   1067          void TIM1_ForcedOC1Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1068          {
   \                     TIM1_ForcedOC1Config:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1069            /* Check the parameters */
   1070            assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 50        CP        A, #0x50
   \   000009 27 15        JREQ      L:??TIM1_ForcedOC1Config_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 40        CP        A, #0x40
   \   00000F 27 0F        JREQ      L:??TIM1_ForcedOC1Config_0
   \   000011 AE 042E      LDW       X, #0x42e
   \   000014 BF ..        LDW       S:?w1, X
   \   000016 5F           CLRW      X
   \   000017 BF ..        LDW       S:?w0, X
   \   000019 AE ....      LDW       X, #?_0
   \   00001C 8D ......    CALLF     assert_failed
   1071            
   1072            /* Reset the OCM Bits & Configure the Forced output Mode */
   1073            TIM1->CCMR1 =  (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM))|
   1074                                     (uint8_t)TIM1_ForcedAction);
   \                     ??TIM1_ForcedOC1Config_0:
   \   000020 C6 5258      LD        A, L:0x5258
   \   000023 A4 8F        AND       A, #0x8f
   \   000025 BA ..        OR        A, S:?b8
   \   000027 C7 5258      LD        L:0x5258, A
   1075          }
   \   00002A 32 ....      POP       S:?b8
   \   00002D 87           RETF
   1076          
   1077          /**
   1078            * @brief  Forces the TIM1 Channel2 output waveform to active or inactive level.
   1079            * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1080            * This parameter can be one of the following values:
   1081            * - TIM1_FORCEDACTION_ACTIVE: Force active level on OC2REF
   1082            * - TIM1_FORCEDACTION_INACTIVE: Force inactive level on OC2REF.
   1083            * @retval None
   1084            */

   \                                 In section .far_func.text, align 1
   1085          void TIM1_ForcedOC2Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1086          {
   \                     TIM1_ForcedOC2Config:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1087            /* Check the parameters */
   1088            assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 50        CP        A, #0x50
   \   000009 27 15        JREQ      L:??TIM1_ForcedOC2Config_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 40        CP        A, #0x40
   \   00000F 27 0F        JREQ      L:??TIM1_ForcedOC2Config_0
   \   000011 AE 0440      LDW       X, #0x440
   \   000014 BF ..        LDW       S:?w1, X
   \   000016 5F           CLRW      X
   \   000017 BF ..        LDW       S:?w0, X
   \   000019 AE ....      LDW       X, #?_0
   \   00001C 8D ......    CALLF     assert_failed
   1089            
   1090            /* Reset the OCM Bits & Configure the Forced output Mode */
   1091            TIM1->CCMR2  =  (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM))
   1092                                      | (uint8_t)TIM1_ForcedAction);
   \                     ??TIM1_ForcedOC2Config_0:
   \   000020 C6 5259      LD        A, L:0x5259
   \   000023 A4 8F        AND       A, #0x8f
   \   000025 BA ..        OR        A, S:?b8
   \   000027 C7 5259      LD        L:0x5259, A
   1093          }
   \   00002A 32 ....      POP       S:?b8
   \   00002D 87           RETF
   1094          
   1095          /**
   1096            * @brief  Forces the TIM1 Channel3 output waveform to active or inactive level.
   1097            * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1098            * This parameter can be one of the following values:
   1099            *                       - TIM1_FORCEDACTION_ACTIVE: Force active level on OC3REF
   1100            *                       - TIM1_FORCEDACTION_INACTIVE: Force inactive level on
   1101            *                         OC3REF.
   1102            * @retval None
   1103            */

   \                                 In section .far_func.text, align 1
   1104          void TIM1_ForcedOC3Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1105          {
   \                     TIM1_ForcedOC3Config:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1106            /* Check the parameters */
   1107            assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 50        CP        A, #0x50
   \   000009 27 15        JREQ      L:??TIM1_ForcedOC3Config_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 40        CP        A, #0x40
   \   00000F 27 0F        JREQ      L:??TIM1_ForcedOC3Config_0
   \   000011 AE 0453      LDW       X, #0x453
   \   000014 BF ..        LDW       S:?w1, X
   \   000016 5F           CLRW      X
   \   000017 BF ..        LDW       S:?w0, X
   \   000019 AE ....      LDW       X, #?_0
   \   00001C 8D ......    CALLF     assert_failed
   1108            
   1109            /* Reset the OCM Bits */ /* Configure The Forced output Mode */
   1110            TIM1->CCMR3  =  (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM))  
   1111                                      | (uint8_t)TIM1_ForcedAction);
   \                     ??TIM1_ForcedOC3Config_0:
   \   000020 C6 525A      LD        A, L:0x525a
   \   000023 A4 8F        AND       A, #0x8f
   \   000025 BA ..        OR        A, S:?b8
   \   000027 C7 525A      LD        L:0x525a, A
   1112          }
   \   00002A 32 ....      POP       S:?b8
   \   00002D 87           RETF
   1113          
   1114          /**
   1115            * @brief  Forces the TIM1 Channel4 output waveform to active or inactive level.
   1116            * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1117            * This parameter can be one of the following values:
   1118            *                       - TIM1_FORCEDACTION_ACTIVE: Force active level on OC4REF
   1119            *                       - TIM1_FORCEDACTION_INACTIVE: Force inactive level on
   1120            *                         OC4REF.
   1121            * @retval None
   1122            */

   \                                 In section .far_func.text, align 1
   1123          void TIM1_ForcedOC4Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1124          {
   \                     TIM1_ForcedOC4Config:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1125            /* Check the parameters */
   1126            assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 50        CP        A, #0x50
   \   000009 27 15        JREQ      L:??TIM1_ForcedOC4Config_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 40        CP        A, #0x40
   \   00000F 27 0F        JREQ      L:??TIM1_ForcedOC4Config_0
   \   000011 AE 0466      LDW       X, #0x466
   \   000014 BF ..        LDW       S:?w1, X
   \   000016 5F           CLRW      X
   \   000017 BF ..        LDW       S:?w0, X
   \   000019 AE ....      LDW       X, #?_0
   \   00001C 8D ......    CALLF     assert_failed
   1127            
   1128            /* Reset the OCM Bits & Configure the Forced output Mode */
   1129            TIM1->CCMR4  =  (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_OCM)) 
   1130                                      | (uint8_t)TIM1_ForcedAction);
   \                     ??TIM1_ForcedOC4Config_0:
   \   000020 C6 525B      LD        A, L:0x525b
   \   000023 A4 8F        AND       A, #0x8f
   \   000025 BA ..        OR        A, S:?b8
   \   000027 C7 525B      LD        L:0x525b, A
   1131          }
   \   00002A 32 ....      POP       S:?b8
   \   00002D 87           RETF
   1132          
   1133          /**
   1134            * @brief  Enables or disables TIM1 peripheral Preload register on ARR.
   1135            * @param   NewState new state of the TIM1 peripheral Preload register.
   1136            * This parameter can be ENABLE or DISABLE.
   1137            * @retval None
   1138            */

   \                                 In section .far_func.text, align 1
   1139          void TIM1_ARRPreloadConfig(FunctionalState NewState)
   1140          {
   \                     TIM1_ARRPreloadConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1141            /* Check the parameters */
   1142            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_ARRPreloadConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_ARRPreloadConfig_0
   \   00000F AE 0476      LDW       X, #0x476
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1143            
   1144            /* Set or Reset the ARPE Bit */
   1145            if (NewState != DISABLE)
   \                     ??TIM1_ARRPreloadConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_ARRPreloadConfig_1
   1146            {
   1147              TIM1->CR1 |= TIM1_CR1_ARPE;
   \   000022 721E 5250    BSET      L:0x5250, #0x7
   \   000026 20 04        JRA       L:??TIM1_ARRPreloadConfig_2
   1148            }
   1149            else
   1150            {
   1151              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_ARPE);
   \                     ??TIM1_ARRPreloadConfig_1:
   \   000028 721F 5250    BRES      L:0x5250, #0x7
   1152            }
   1153          }
   \                     ??TIM1_ARRPreloadConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1154          
   1155          /**
   1156            * @brief  Selects the TIM1 peripheral Commutation event.
   1157            * @param   NewState new state of the Commutation event.
   1158            * This parameter can be ENABLE or DISABLE.
   1159            * @retval None
   1160            */

   \                                 In section .far_func.text, align 1
   1161          void TIM1_SelectCOM(FunctionalState NewState)
   1162          {
   \                     TIM1_SelectCOM:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1163            /* Check the parameters */
   1164            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_SelectCOM_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_SelectCOM_0
   \   00000F AE 048C      LDW       X, #0x48c
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1165            
   1166            /* Set or Reset the COMS Bit */
   1167            if (NewState != DISABLE)
   \                     ??TIM1_SelectCOM_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_SelectCOM_1
   1168            {
   1169              TIM1->CR2 |= TIM1_CR2_COMS;
   \   000022 7214 5251    BSET      L:0x5251, #0x2
   \   000026 20 04        JRA       L:??TIM1_SelectCOM_2
   1170            }
   1171            else
   1172            {
   1173              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_COMS);
   \                     ??TIM1_SelectCOM_1:
   \   000028 7215 5251    BRES      L:0x5251, #0x2
   1174            }
   1175          }
   \                     ??TIM1_SelectCOM_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1176          
   1177          /**
   1178            * @brief  Sets or Resets the TIM1 peripheral Capture Compare Preload Control bit.
   1179            * @param   NewState new state of the Capture Compare Preload Control bit.
   1180            * This parameter can be ENABLE or DISABLE.
   1181            * @retval None
   1182            */

   \                                 In section .far_func.text, align 1
   1183          void TIM1_CCPreloadControl(FunctionalState NewState)
   1184          {
   \                     TIM1_CCPreloadControl:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1185            /* Check the parameters */
   1186            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_CCPreloadControl_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_CCPreloadControl_0
   \   00000F AE 04A2      LDW       X, #0x4a2
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1187            
   1188            /* Set or Reset the CCPC Bit */
   1189            if (NewState != DISABLE)
   \                     ??TIM1_CCPreloadControl_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_CCPreloadControl_1
   1190            {
   1191              TIM1->CR2 |= TIM1_CR2_CCPC;
   \   000022 7210 5251    BSET      L:0x5251, #0x0
   \   000026 20 04        JRA       L:??TIM1_CCPreloadControl_2
   1192            }
   1193            else
   1194            {
   1195              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_CCPC);
   \                     ??TIM1_CCPreloadControl_1:
   \   000028 7211 5251    BRES      L:0x5251, #0x0
   1196            }
   1197          }
   \                     ??TIM1_CCPreloadControl_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1198          
   1199          /**
   1200            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR1.
   1201            * @param   NewState new state of the Capture Compare Preload register.
   1202            * This parameter can be ENABLE or DISABLE.
   1203            * @retval None
   1204            */

   \                                 In section .far_func.text, align 1
   1205          void TIM1_OC1PreloadConfig(FunctionalState NewState)
   1206          {
   \                     TIM1_OC1PreloadConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1207            /* Check the parameters */
   1208            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC1PreloadConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_OC1PreloadConfig_0
   \   00000F AE 04B8      LDW       X, #0x4b8
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1209            
   1210            /* Set or Reset the OC1PE Bit */
   1211            if (NewState != DISABLE)
   \                     ??TIM1_OC1PreloadConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC1PreloadConfig_1
   1212            {
   1213              TIM1->CCMR1 |= TIM1_CCMR_OCxPE;
   \   000022 7216 5258    BSET      L:0x5258, #0x3
   \   000026 20 04        JRA       L:??TIM1_OC1PreloadConfig_2
   1214            }
   1215            else
   1216            {
   1217              TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC1PreloadConfig_1:
   \   000028 7217 5258    BRES      L:0x5258, #0x3
   1218            }
   1219          }
   \                     ??TIM1_OC1PreloadConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1220          
   1221          /**
   1222            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR2.
   1223            * @param   NewState new state of the Capture Compare Preload register.
   1224            * This parameter can be ENABLE or DISABLE.
   1225            * @retval None
   1226            */

   \                                 In section .far_func.text, align 1
   1227          void TIM1_OC2PreloadConfig(FunctionalState NewState)
   1228          {
   \                     TIM1_OC2PreloadConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1229            /* Check the parameters */
   1230            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC2PreloadConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_OC2PreloadConfig_0
   \   00000F AE 04CE      LDW       X, #0x4ce
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1231            
   1232            /* Set or Reset the OC2PE Bit */
   1233            if (NewState != DISABLE)
   \                     ??TIM1_OC2PreloadConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC2PreloadConfig_1
   1234            {
   1235              TIM1->CCMR2 |= TIM1_CCMR_OCxPE;
   \   000022 7216 5259    BSET      L:0x5259, #0x3
   \   000026 20 04        JRA       L:??TIM1_OC2PreloadConfig_2
   1236            }
   1237            else
   1238            {
   1239              TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC2PreloadConfig_1:
   \   000028 7217 5259    BRES      L:0x5259, #0x3
   1240            }
   1241          }
   \                     ??TIM1_OC2PreloadConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1242          
   1243          /**
   1244            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR3.
   1245            * @param   NewState new state of the Capture Compare Preload register.
   1246            * This parameter can be ENABLE or DISABLE.
   1247            * @retval None
   1248            */

   \                                 In section .far_func.text, align 1
   1249          void TIM1_OC3PreloadConfig(FunctionalState NewState)
   1250          {
   \                     TIM1_OC3PreloadConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1251            /* Check the parameters */
   1252            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC3PreloadConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_OC3PreloadConfig_0
   \   00000F AE 04E4      LDW       X, #0x4e4
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1253            
   1254            /* Set or Reset the OC3PE Bit */
   1255            if (NewState != DISABLE)
   \                     ??TIM1_OC3PreloadConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC3PreloadConfig_1
   1256            {
   1257              TIM1->CCMR3 |= TIM1_CCMR_OCxPE;
   \   000022 7216 525A    BSET      L:0x525a, #0x3
   \   000026 20 04        JRA       L:??TIM1_OC3PreloadConfig_2
   1258            }
   1259            else
   1260            {
   1261              TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC3PreloadConfig_1:
   \   000028 7217 525A    BRES      L:0x525a, #0x3
   1262            }
   1263          }
   \                     ??TIM1_OC3PreloadConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1264          
   1265          /**
   1266            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR4.
   1267            * @param   NewState new state of the Capture Compare Preload register.
   1268            * This parameter can be ENABLE or DISABLE.
   1269            * @retval None
   1270            */

   \                                 In section .far_func.text, align 1
   1271          void TIM1_OC4PreloadConfig(FunctionalState NewState)
   1272          {
   \                     TIM1_OC4PreloadConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1273            /* Check the parameters */
   1274            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC4PreloadConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_OC4PreloadConfig_0
   \   00000F AE 04FA      LDW       X, #0x4fa
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1275            
   1276            /* Set or Reset the OC4PE Bit */
   1277            if (NewState != DISABLE)
   \                     ??TIM1_OC4PreloadConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC4PreloadConfig_1
   1278            {
   1279              TIM1->CCMR4 |= TIM1_CCMR_OCxPE;
   \   000022 7216 525B    BSET      L:0x525b, #0x3
   \   000026 20 04        JRA       L:??TIM1_OC4PreloadConfig_2
   1280            }
   1281            else
   1282            {
   1283              TIM1->CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC4PreloadConfig_1:
   \   000028 7217 525B    BRES      L:0x525b, #0x3
   1284            }
   1285          }
   \                     ??TIM1_OC4PreloadConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1286          
   1287          /**
   1288            * @brief  Configures the TIM1 Capture Compare 1 Fast feature.
   1289            * @param   NewState new state of the Output Compare Fast Enable bit.
   1290            * This parameter can be ENABLE or DISABLE.
   1291            * @retval None
   1292            */

   \                                 In section .far_func.text, align 1
   1293          void TIM1_OC1FastConfig(FunctionalState NewState)
   1294          {
   \                     TIM1_OC1FastConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1295            /* Check the parameters */
   1296            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC1FastConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_OC1FastConfig_0
   \   00000F AE 0510      LDW       X, #0x510
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1297            
   1298            /* Set or Reset the OC1FE Bit */
   1299            if (NewState != DISABLE)
   \                     ??TIM1_OC1FastConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC1FastConfig_1
   1300            {
   1301              TIM1->CCMR1 |= TIM1_CCMR_OCxFE;
   \   000022 7214 5258    BSET      L:0x5258, #0x2
   \   000026 20 04        JRA       L:??TIM1_OC1FastConfig_2
   1302            }
   1303            else
   1304            {
   1305              TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC1FastConfig_1:
   \   000028 7215 5258    BRES      L:0x5258, #0x2
   1306            }
   1307          }
   \                     ??TIM1_OC1FastConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1308          
   1309          /**
   1310            * @brief  Configures the TIM1 Capture Compare 2 Fast feature.
   1311            * @param   NewState new state of the Output Compare Fast Enable bit.
   1312            * This parameter can be ENABLE or DISABLE.
   1313            * @retval None
   1314            */

   \                                 In section .far_func.text, align 1
   1315          void TIM1_OC2FastConfig(FunctionalState NewState)
   1316          {
   \                     TIM1_OC2FastConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1317            /* Check the parameters */
   1318            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC2FastConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_OC2FastConfig_0
   \   00000F AE 0526      LDW       X, #0x526
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1319            
   1320            /* Set or Reset the OC2FE Bit */
   1321            if (NewState != DISABLE)
   \                     ??TIM1_OC2FastConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC2FastConfig_1
   1322            {
   1323              TIM1->CCMR2 |= TIM1_CCMR_OCxFE;
   \   000022 7214 5259    BSET      L:0x5259, #0x2
   \   000026 20 04        JRA       L:??TIM1_OC2FastConfig_2
   1324            }
   1325            else
   1326            {
   1327              TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC2FastConfig_1:
   \   000028 7215 5259    BRES      L:0x5259, #0x2
   1328            }
   1329          }
   \                     ??TIM1_OC2FastConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1330          
   1331          /**
   1332            * @brief  Configures the TIM1 Capture Compare 3 Fast feature.
   1333            * @param   NewState new state of the Output Compare Fast Enable bit.
   1334            * This parameter can be ENABLE or DISABLE.
   1335            * @retval None
   1336            */

   \                                 In section .far_func.text, align 1
   1337          void TIM1_OC3FastConfig(FunctionalState NewState)
   1338          {
   \                     TIM1_OC3FastConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1339            /* Check the parameters */
   1340            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC3FastConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_OC3FastConfig_0
   \   00000F AE 053C      LDW       X, #0x53c
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1341            
   1342            /* Set or Reset the OC3FE Bit */
   1343            if (NewState != DISABLE)
   \                     ??TIM1_OC3FastConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC3FastConfig_1
   1344            {
   1345              TIM1->CCMR3 |= TIM1_CCMR_OCxFE;
   \   000022 7214 525A    BSET      L:0x525a, #0x2
   \   000026 20 04        JRA       L:??TIM1_OC3FastConfig_2
   1346            }
   1347            else
   1348            {
   1349              TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC3FastConfig_1:
   \   000028 7215 525A    BRES      L:0x525a, #0x2
   1350            }
   1351          }
   \                     ??TIM1_OC3FastConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1352          
   1353          /**
   1354            * @brief  Configures the TIM1 Capture Compare 4 Fast feature.
   1355            * @param   NewState new state of the Output Compare Fast Enable bit.
   1356            * This parameter can be ENABLE or DISABLE.
   1357            * @retval None
   1358            */

   \                                 In section .far_func.text, align 1
   1359          void TIM1_OC4FastConfig(FunctionalState NewState)
   1360          {
   \                     TIM1_OC4FastConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1361            /* Check the parameters */
   1362            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC4FastConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??TIM1_OC4FastConfig_0
   \   00000F AE 0552      LDW       X, #0x552
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1363            
   1364            /* Set or Reset the OC4FE Bit */
   1365            if (NewState != DISABLE)
   \                     ??TIM1_OC4FastConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC4FastConfig_1
   1366            {
   1367              TIM1->CCMR4 |= TIM1_CCMR_OCxFE;
   \   000022 7214 525B    BSET      L:0x525b, #0x2
   \   000026 20 04        JRA       L:??TIM1_OC4FastConfig_2
   1368            }
   1369            else
   1370            {
   1371              TIM1->CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC4FastConfig_1:
   \   000028 7215 525B    BRES      L:0x525b, #0x2
   1372            }
   1373          }
   \                     ??TIM1_OC4FastConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1374          
   1375          /**
   1376            * @brief  Configures the TIM1 event to be generated by software.
   1377            * @param   TIM1_EventSource specifies the event source.
   1378            * This parameter can be one of the following values:
   1379            *                       - TIM1_EVENTSOURCE_UPDATE: TIM1 update Event source
   1380            *                       - TIM1_EVENTSOURCE_CC1: TIM1 Capture Compare 1 Event source
   1381            *                       - TIM1_EVENTSOURCE_CC2: TIM1 Capture Compare 2 Event source
   1382            *                       - TIM1_EVENTSOURCE_CC3: TIM1 Capture Compare 3 Event source
   1383            *                       - TIM1_EVENTSOURCE_CC4: TIM1 Capture Compare 4 Event source
   1384            *                       - TIM1_EVENTSOURCE_COM: TIM1 COM Event source
   1385            *                       - TIM1_EVENTSOURCE_TRIGGER: TIM1 Trigger Event source
   1386            *                       - TIM1_EventSourceBreak: TIM1 Break Event source
   1387            * @retval None
   1388            */

   \                                 In section .far_func.text, align 1
   1389          void TIM1_GenerateEvent(TIM1_EventSource_TypeDef TIM1_EventSource)
   1390          {
   \                     TIM1_GenerateEvent:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1391            /* Check the parameters */
   1392            assert_param(IS_TIM1_EVENT_SOURCE_OK(TIM1_EventSource));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 26 0F        JRNE      L:??TIM1_GenerateEvent_0
   \   000009 AE 0570      LDW       X, #0x570
   \   00000C BF ..        LDW       S:?w1, X
   \   00000E 5F           CLRW      X
   \   00000F BF ..        LDW       S:?w0, X
   \   000011 AE ....      LDW       X, #?_0
   \   000014 8D ......    CALLF     assert_failed
   1393            
   1394            /* Set the event sources */
   1395            TIM1->EGR = (uint8_t)TIM1_EventSource;
   \                     ??TIM1_GenerateEvent_0:
   \   000018 B6 ..        LD        A, S:?b8
   \   00001A C7 5257      LD        L:0x5257, A
   1396          }
   \   00001D 32 ....      POP       S:?b8
   \   000020 87           RETF
   1397          
   1398          /**
   1399            * @brief  Configures the TIM1 Channel 1 polarity.
   1400            * @param   TIM1_OCPolarity specifies the OC1 Polarity.
   1401            * This parameter can be one of the following values:
   1402            *                       - TIM1_OCPOLARITY_LOW: Output Compare active low
   1403            *                       - TIM1_OCPOLARITY_HIGH: Output Compare active high
   1404            * @retval None
   1405            */

   \                                 In section .far_func.text, align 1
   1406          void TIM1_OC1PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1407          {
   \                     TIM1_OC1PolarityConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1408            /* Check the parameters */
   1409            assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC1PolarityConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 22        CP        A, #0x22
   \   00000D 27 0F        JREQ      L:??TIM1_OC1PolarityConfig_0
   \   00000F AE 0581      LDW       X, #0x581
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1410            
   1411            /* Set or Reset the CC1P Bit */
   1412            if (TIM1_OCPolarity != TIM1_OCPOLARITY_HIGH)
   \                     ??TIM1_OC1PolarityConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC1PolarityConfig_1
   1413            {
   1414              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \   000022 7212 525C    BSET      L:0x525c, #0x1
   \   000026 20 04        JRA       L:??TIM1_OC1PolarityConfig_2
   1415            }
   1416            else
   1417            {
   1418              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TIM1_OC1PolarityConfig_1:
   \   000028 7213 525C    BRES      L:0x525c, #0x1
   1419            }
   1420          }
   \                     ??TIM1_OC1PolarityConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1421          
   1422          /**
   1423            * @brief  Configures the TIM1 Channel 1N polarity.
   1424            * @param   TIM1_OCNPolarity specifies the OC1N Polarity.
   1425            * This parameter can be one of the following values:
   1426            *                       - TIM1_OCNPOLARITY_LOW: Output Compare active low
   1427            *                       - TIM1_OCNPOLARITY_HIGH: Output Compare active high
   1428            * @retval None
   1429            */

   \                                 In section .far_func.text, align 1
   1430          void TIM1_OC1NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1431          {
   \                     TIM1_OC1NPolarityConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1432            /* Check the parameters */
   1433            assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC1NPolarityConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 88        CP        A, #0x88
   \   00000D 27 0F        JREQ      L:??TIM1_OC1NPolarityConfig_0
   \   00000F AE 0599      LDW       X, #0x599
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1434            
   1435            /* Set or Reset the CC3P Bit */
   1436            if (TIM1_OCNPolarity != TIM1_OCNPOLARITY_HIGH)
   \                     ??TIM1_OC1NPolarityConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC1NPolarityConfig_1
   1437            {
   1438              TIM1->CCER1 |= TIM1_CCER1_CC1NP;
   \   000022 7216 525C    BSET      L:0x525c, #0x3
   \   000026 20 04        JRA       L:??TIM1_OC1NPolarityConfig_2
   1439            }
   1440            else
   1441            {
   1442              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1NP);
   \                     ??TIM1_OC1NPolarityConfig_1:
   \   000028 7217 525C    BRES      L:0x525c, #0x3
   1443            }
   1444          }
   \                     ??TIM1_OC1NPolarityConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1445          
   1446          /**
   1447            * @brief  Configures the TIM1 Channel 2 polarity.
   1448            * @param   TIM1_OCPolarity specifies the OC2 Polarity.
   1449            * This parameter can be one of the following values:
   1450            *                       - TIM1_OCPOLARITY_LOW: Output Compare active low
   1451            *                       - TIM1_OCPOLARITY_HIGH: Output Compare active high
   1452            * @retval None
   1453            */

   \                                 In section .far_func.text, align 1
   1454          void TIM1_OC2PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1455          {
   \                     TIM1_OC2PolarityConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1456            /* Check the parameters */
   1457            assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC2PolarityConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 22        CP        A, #0x22
   \   00000D 27 0F        JREQ      L:??TIM1_OC2PolarityConfig_0
   \   00000F AE 05B1      LDW       X, #0x5b1
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1458            
   1459            /* Set or Reset the CC2P Bit */
   1460            if (TIM1_OCPolarity != TIM1_OCPOLARITY_HIGH)
   \                     ??TIM1_OC2PolarityConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC2PolarityConfig_1
   1461            {
   1462              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \   000022 721A 525C    BSET      L:0x525c, #0x5
   \   000026 20 04        JRA       L:??TIM1_OC2PolarityConfig_2
   1463            }
   1464            else
   1465            {
   1466              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TIM1_OC2PolarityConfig_1:
   \   000028 721B 525C    BRES      L:0x525c, #0x5
   1467            }
   1468          }
   \                     ??TIM1_OC2PolarityConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1469          
   1470          /**
   1471            * @brief  Configures the TIM1 Channel 2N polarity.
   1472            * @param   TIM1_OCNPolarity specifies the OC2N Polarity.
   1473            * This parameter can be one of the following values:
   1474            *                       - TIM1_OCNPOLARITY_LOW: Output Compare active low
   1475            *                       - TIM1_OCNPOLARITY_HIGH: Output Compare active high
   1476            * @retval None
   1477            */

   \                                 In section .far_func.text, align 1
   1478          void TIM1_OC2NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1479          {
   \                     TIM1_OC2NPolarityConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1480            /* Check the parameters */
   1481            assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC2NPolarityConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 88        CP        A, #0x88
   \   00000D 27 0F        JREQ      L:??TIM1_OC2NPolarityConfig_0
   \   00000F AE 05C9      LDW       X, #0x5c9
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1482            
   1483            /* Set or Reset the CC3P Bit */
   1484            if (TIM1_OCNPolarity != TIM1_OCNPOLARITY_HIGH)
   \                     ??TIM1_OC2NPolarityConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC2NPolarityConfig_1
   1485            {
   1486              TIM1->CCER1 |= TIM1_CCER1_CC2NP;
   \   000022 721E 525C    BSET      L:0x525c, #0x7
   \   000026 20 04        JRA       L:??TIM1_OC2NPolarityConfig_2
   1487            }
   1488            else
   1489            {
   1490              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2NP);
   \                     ??TIM1_OC2NPolarityConfig_1:
   \   000028 721F 525C    BRES      L:0x525c, #0x7
   1491            }
   1492          }
   \                     ??TIM1_OC2NPolarityConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1493          
   1494          /**
   1495            * @brief  Configures the TIM1 Channel 3 polarity.
   1496            * @param   TIM1_OCPolarity specifies the OC3 Polarity.
   1497            * This parameter can be one of the following values:
   1498            *                       - TIM1_OCPOLARITY_LOW: Output Compare active low
   1499            *                       - TIM1_OCPOLARITY_HIGH: Output Compare active high
   1500            * @retval None
   1501            */

   \                                 In section .far_func.text, align 1
   1502          void TIM1_OC3PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1503          {
   \                     TIM1_OC3PolarityConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1504            /* Check the parameters */
   1505            assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC3PolarityConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 22        CP        A, #0x22
   \   00000D 27 0F        JREQ      L:??TIM1_OC3PolarityConfig_0
   \   00000F AE 05E1      LDW       X, #0x5e1
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1506            
   1507            /* Set or Reset the CC3P Bit */
   1508            if (TIM1_OCPolarity != TIM1_OCPOLARITY_HIGH)
   \                     ??TIM1_OC3PolarityConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC3PolarityConfig_1
   1509            {
   1510              TIM1->CCER2 |= TIM1_CCER2_CC3P;
   \   000022 7212 525D    BSET      L:0x525d, #0x1
   \   000026 20 04        JRA       L:??TIM1_OC3PolarityConfig_2
   1511            }
   1512            else
   1513            {
   1514              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3P);
   \                     ??TIM1_OC3PolarityConfig_1:
   \   000028 7213 525D    BRES      L:0x525d, #0x1
   1515            }
   1516          }
   \                     ??TIM1_OC3PolarityConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1517          
   1518          
   1519          /**
   1520            * @brief  Configures the TIM1 Channel 3N polarity.
   1521            * @param   TIM1_OCNPolarity specifies the OC3N Polarity.
   1522            * This parameter can be one of the following values:
   1523            *                       - TIM1_OCNPOLARITY_LOW: Output Compare active low
   1524            *                       - TIM1_OCNPOLARITY_HIGH: Output Compare active high
   1525            * @retval None
   1526            */

   \                                 In section .far_func.text, align 1
   1527          void TIM1_OC3NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1528          {
   \                     TIM1_OC3NPolarityConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1529            /* Check the parameters */
   1530            assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC3NPolarityConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 88        CP        A, #0x88
   \   00000D 27 0F        JREQ      L:??TIM1_OC3NPolarityConfig_0
   \   00000F AE 05FA      LDW       X, #0x5fa
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1531            
   1532            /* Set or Reset the CC3P Bit */
   1533            if (TIM1_OCNPolarity != TIM1_OCNPOLARITY_HIGH)
   \                     ??TIM1_OC3NPolarityConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC3NPolarityConfig_1
   1534            {
   1535              TIM1->CCER2 |= TIM1_CCER2_CC3NP;
   \   000022 7216 525D    BSET      L:0x525d, #0x3
   \   000026 20 04        JRA       L:??TIM1_OC3NPolarityConfig_2
   1536            }
   1537            else
   1538            {
   1539              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3NP);
   \                     ??TIM1_OC3NPolarityConfig_1:
   \   000028 7217 525D    BRES      L:0x525d, #0x3
   1540            }
   1541          }
   \                     ??TIM1_OC3NPolarityConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1542          
   1543          /**
   1544            * @brief  Configures the TIM1 Channel 4 polarity.
   1545            * @param   TIM1_OCPolarity specifies the OC4 Polarity.
   1546            * This parameter can be one of the following values:
   1547            *                       - TIM1_OCPOLARITY_LOW: Output Compare active low
   1548            *                       - TIM1_OCPOLARITY_HIGH: Output Compare active high
   1549            * @retval None
   1550            */

   \                                 In section .far_func.text, align 1
   1551          void TIM1_OC4PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1552          {
   \                     TIM1_OC4PolarityConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1553            /* Check the parameters */
   1554            assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??TIM1_OC4PolarityConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 22        CP        A, #0x22
   \   00000D 27 0F        JREQ      L:??TIM1_OC4PolarityConfig_0
   \   00000F AE 0612      LDW       X, #0x612
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
   1555            
   1556            /* Set or Reset the CC4P Bit */
   1557            if (TIM1_OCPolarity != TIM1_OCPOLARITY_HIGH)
   \                     ??TIM1_OC4PolarityConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??TIM1_OC4PolarityConfig_1
   1558            {
   1559              TIM1->CCER2 |= TIM1_CCER2_CC4P;
   \   000022 721A 525D    BSET      L:0x525d, #0x5
   \   000026 20 04        JRA       L:??TIM1_OC4PolarityConfig_2
   1560            }
   1561            else
   1562            {
   1563              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4P);
   \                     ??TIM1_OC4PolarityConfig_1:
   \   000028 721B 525D    BRES      L:0x525d, #0x5
   1564            }
   1565          }
   \                     ??TIM1_OC4PolarityConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
   1566          
   1567          /**
   1568            * @brief  Enables or disables the TIM1 Capture Compare Channel x (x=1,..,4).
   1569            * @param   TIM1_Channel specifies the TIM1 Channel.
   1570            * This parameter can be one of the following values:
   1571            *                       - TIM1_CHANNEL_1: TIM1 Channel1
   1572            *                       - TIM1_CHANNEL_2: TIM1 Channel2
   1573            *                       - TIM1_CHANNEL_3: TIM1 Channel3
   1574            *                       - TIM1_CHANNEL_4: TIM1 Channel4
   1575            * @param   NewState specifies the TIM1 Channel CCxE bit new state.
   1576            * This parameter can be: ENABLE or DISABLE.
   1577            * @retval None
   1578            */

   \                                 In section .far_func.text, align 1
   1579          void TIM1_CCxCmd(TIM1_Channel_TypeDef TIM1_Channel, FunctionalState NewState)
   1580          {
   \                     TIM1_CCxCmd:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
   \   000006 45 .. ..     MOV       S:?b8, S:?b0
   1581            /* Check the parameters */
   1582            assert_param(IS_TIM1_CHANNEL_OK(TIM1_Channel));
   \   000009 3D ..        TNZ       S:?b9
   \   00000B 27 21        JREQ      L:??TIM1_CCxCmd_0
   \   00000D B6 ..        LD        A, S:?b9
   \   00000F A1 01        CP        A, #0x1
   \   000011 27 1B        JREQ      L:??TIM1_CCxCmd_0
   \   000013 B6 ..        LD        A, S:?b9
   \   000015 A1 02        CP        A, #0x2
   \   000017 27 15        JREQ      L:??TIM1_CCxCmd_0
   \   000019 B6 ..        LD        A, S:?b9
   \   00001B A1 03        CP        A, #0x3
   \   00001D 27 0F        JREQ      L:??TIM1_CCxCmd_0
   \   00001F AE 062E      LDW       X, #0x62e
   \   000022 BF ..        LDW       S:?w1, X
   \   000024 5F           CLRW      X
   \   000025 BF ..        LDW       S:?w0, X
   \   000027 AE ....      LDW       X, #?_0
   \   00002A 8D ......    CALLF     assert_failed
   1583            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??TIM1_CCxCmd_0:
   \   00002E 3D ..        TNZ       S:?b8
   \   000030 27 15        JREQ      L:??TIM1_CCxCmd_1
   \   000032 B6 ..        LD        A, S:?b8
   \   000034 A1 01        CP        A, #0x1
   \   000036 27 0F        JREQ      L:??TIM1_CCxCmd_1
   \   000038 AE 062F      LDW       X, #0x62f
   \   00003B BF ..        LDW       S:?w1, X
   \   00003D 5F           CLRW      X
   \   00003E BF ..        LDW       S:?w0, X
   \   000040 AE ....      LDW       X, #?_0
   \   000043 8D ......    CALLF     assert_failed
   1584            
   1585            if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??TIM1_CCxCmd_1:
   \   000047 3D ..        TNZ       S:?b9
   \   000049 26 10        JRNE      L:??TIM1_CCxCmd_2
   1586            {
   1587              /* Set or Reset the CC1E Bit */
   1588              if (NewState != DISABLE)
   \   00004B 3D ..        TNZ       S:?b8
   \   00004D 27 06        JREQ      L:??TIM1_CCxCmd_3
   1589              {
   1590                TIM1->CCER1 |= TIM1_CCER1_CC1E;
   \   00004F 7210 525C    BSET      L:0x525c, #0x0
   \   000053 20 40        JRA       L:??TIM1_CCxCmd_4
   1591              }
   1592              else
   1593              {
   1594                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \                     ??TIM1_CCxCmd_3:
   \   000055 7211 525C    BRES      L:0x525c, #0x0
   \   000059 20 3A        JRA       L:??TIM1_CCxCmd_4
   1595              }
   1596              
   1597            }
   1598            else if (TIM1_Channel == TIM1_CHANNEL_2)
   \                     ??TIM1_CCxCmd_2:
   \   00005B B6 ..        LD        A, S:?b9
   \   00005D A1 01        CP        A, #0x1
   \   00005F 26 10        JRNE      L:??TIM1_CCxCmd_5
   1599            {
   1600              /* Set or Reset the CC2E Bit */
   1601              if (NewState != DISABLE)
   \   000061 3D ..        TNZ       S:?b8
   \   000063 27 06        JREQ      L:??TIM1_CCxCmd_6
   1602              {
   1603                TIM1->CCER1 |= TIM1_CCER1_CC2E;
   \   000065 7218 525C    BSET      L:0x525c, #0x4
   \   000069 20 2A        JRA       L:??TIM1_CCxCmd_4
   1604              }
   1605              else
   1606              {
   1607                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2E);
   \                     ??TIM1_CCxCmd_6:
   \   00006B 7219 525C    BRES      L:0x525c, #0x4
   \   00006F 20 24        JRA       L:??TIM1_CCxCmd_4
   1608              }
   1609            }
   1610            else if (TIM1_Channel == TIM1_CHANNEL_3)
   \                     ??TIM1_CCxCmd_5:
   \   000071 B6 ..        LD        A, S:?b9
   \   000073 A1 02        CP        A, #0x2
   \   000075 26 10        JRNE      L:??TIM1_CCxCmd_7
   1611            {
   1612              /* Set or Reset the CC3E Bit */
   1613              if (NewState != DISABLE)
   \   000077 3D ..        TNZ       S:?b8
   \   000079 27 06        JREQ      L:??TIM1_CCxCmd_8
   1614              {
   1615                TIM1->CCER2 |= TIM1_CCER2_CC3E;
   \   00007B 7210 525D    BSET      L:0x525d, #0x0
   \   00007F 20 14        JRA       L:??TIM1_CCxCmd_4
   1616              }
   1617              else
   1618              {
   1619                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3E);
   \                     ??TIM1_CCxCmd_8:
   \   000081 7211 525D    BRES      L:0x525d, #0x0
   \   000085 20 0E        JRA       L:??TIM1_CCxCmd_4
   1620              }
   1621            }
   1622            else
   1623            {
   1624              /* Set or Reset the CC4E Bit */
   1625              if (NewState != DISABLE)
   \                     ??TIM1_CCxCmd_7:
   \   000087 3D ..        TNZ       S:?b8
   \   000089 27 06        JREQ      L:??TIM1_CCxCmd_9
   1626              {
   1627                TIM1->CCER2 |= TIM1_CCER2_CC4E;
   \   00008B 7218 525D    BSET      L:0x525d, #0x4
   \   00008F 20 04        JRA       L:??TIM1_CCxCmd_4
   1628              }
   1629              else
   1630              {
   1631                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4E);
   \                     ??TIM1_CCxCmd_9:
   \   000091 7219 525D    BRES      L:0x525d, #0x4
   1632              }
   1633            }
   1634          }
   \                     ??TIM1_CCxCmd_4:
   \   000095 AC ......    JPF       L:?epilogue_w4
   1635          
   1636          /**
   1637            * @brief  Enables or disables the TIM1 Capture Compare Channel xN (xN=1,..,3).
   1638            * @param   TIM1_Channel specifies the TIM1 Channel.
   1639            * This parameter can be one of the following values:
   1640            *                       - TIM1_CHANNEL_1: TIM1 Channel1
   1641            *                       - TIM1_CHANNEL_2: TIM1 Channel2
   1642            *                       - TIM1_CHANNEL_3: TIM1 Channel3
   1643            * @param   NewState specifies the TIM1 Channel CCxNE bit new state.
   1644            * This parameter can be: ENABLE or DISABLE.
   1645            * @retval None
   1646            */

   \                                 In section .far_func.text, align 1
   1647          void TIM1_CCxNCmd(TIM1_Channel_TypeDef TIM1_Channel, FunctionalState NewState)
   1648          {
   \                     TIM1_CCxNCmd:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
   \   000006 45 .. ..     MOV       S:?b8, S:?b0
   1649            /* Check the parameters */
   1650            assert_param(IS_TIM1_COMPLEMENTARY_CHANNEL_OK(TIM1_Channel));
   \   000009 3D ..        TNZ       S:?b9
   \   00000B 27 1B        JREQ      L:??TIM1_CCxNCmd_0
   \   00000D B6 ..        LD        A, S:?b9
   \   00000F A1 01        CP        A, #0x1
   \   000011 27 15        JREQ      L:??TIM1_CCxNCmd_0
   \   000013 B6 ..        LD        A, S:?b9
   \   000015 A1 02        CP        A, #0x2
   \   000017 27 0F        JREQ      L:??TIM1_CCxNCmd_0
   \   000019 AE 0672      LDW       X, #0x672
   \   00001C BF ..        LDW       S:?w1, X
   \   00001E 5F           CLRW      X
   \   00001F BF ..        LDW       S:?w0, X
   \   000021 AE ....      LDW       X, #?_0
   \   000024 8D ......    CALLF     assert_failed
   1651            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??TIM1_CCxNCmd_0:
   \   000028 3D ..        TNZ       S:?b8
   \   00002A 27 15        JREQ      L:??TIM1_CCxNCmd_1
   \   00002C B6 ..        LD        A, S:?b8
   \   00002E A1 01        CP        A, #0x1
   \   000030 27 0F        JREQ      L:??TIM1_CCxNCmd_1
   \   000032 AE 0673      LDW       X, #0x673
   \   000035 BF ..        LDW       S:?w1, X
   \   000037 5F           CLRW      X
   \   000038 BF ..        LDW       S:?w0, X
   \   00003A AE ....      LDW       X, #?_0
   \   00003D 8D ......    CALLF     assert_failed
   1652            
   1653            if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??TIM1_CCxNCmd_1:
   \   000041 3D ..        TNZ       S:?b9
   \   000043 26 10        JRNE      L:??TIM1_CCxNCmd_2
   1654            {
   1655              /* Set or Reset the CC1NE Bit */
   1656              if (NewState != DISABLE)
   \   000045 3D ..        TNZ       S:?b8
   \   000047 27 06        JREQ      L:??TIM1_CCxNCmd_3
   1657              {
   1658                TIM1->CCER1 |= TIM1_CCER1_CC1NE;
   \   000049 7214 525C    BSET      L:0x525c, #0x2
   \   00004D 20 2A        JRA       L:??TIM1_CCxNCmd_4
   1659              }
   1660              else
   1661              {
   1662                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1NE);
   \                     ??TIM1_CCxNCmd_3:
   \   00004F 7215 525C    BRES      L:0x525c, #0x2
   \   000053 20 24        JRA       L:??TIM1_CCxNCmd_4
   1663              }
   1664            }
   1665            else if (TIM1_Channel == TIM1_CHANNEL_2)
   \                     ??TIM1_CCxNCmd_2:
   \   000055 B6 ..        LD        A, S:?b9
   \   000057 A1 01        CP        A, #0x1
   \   000059 26 10        JRNE      L:??TIM1_CCxNCmd_5
   1666            {
   1667              /* Set or Reset the CC2NE Bit */
   1668              if (NewState != DISABLE)
   \   00005B 3D ..        TNZ       S:?b8
   \   00005D 27 06        JREQ      L:??TIM1_CCxNCmd_6
   1669              {
   1670                TIM1->CCER1 |= TIM1_CCER1_CC2NE;
   \   00005F 721C 525C    BSET      L:0x525c, #0x6
   \   000063 20 14        JRA       L:??TIM1_CCxNCmd_4
   1671              }
   1672              else
   1673              {
   1674                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2NE);
   \                     ??TIM1_CCxNCmd_6:
   \   000065 721D 525C    BRES      L:0x525c, #0x6
   \   000069 20 0E        JRA       L:??TIM1_CCxNCmd_4
   1675              }
   1676            }
   1677            else
   1678            {
   1679              /* Set or Reset the CC3NE Bit */
   1680              if (NewState != DISABLE)
   \                     ??TIM1_CCxNCmd_5:
   \   00006B 3D ..        TNZ       S:?b8
   \   00006D 27 06        JREQ      L:??TIM1_CCxNCmd_7
   1681              {
   1682                TIM1->CCER2 |= TIM1_CCER2_CC3NE;
   \   00006F 7214 525D    BSET      L:0x525d, #0x2
   \   000073 20 04        JRA       L:??TIM1_CCxNCmd_4
   1683              }
   1684              else
   1685              {
   1686                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3NE);
   \                     ??TIM1_CCxNCmd_7:
   \   000075 7215 525D    BRES      L:0x525d, #0x2
   1687              }
   1688            }
   1689          }
   \                     ??TIM1_CCxNCmd_4:
   \   000079 AC ......    JPF       L:?epilogue_w4
   1690          
   1691          /**
   1692            * @brief  Selects the TIM1 Output Compare Mode. This function disables the
   1693            * selected channel before changing the Output Compare Mode. User has to
   1694            * enable this channel using TIM1_CCxCmd and TIM1_CCxNCmd functions.
   1695            * @param   TIM1_Channel specifies the TIM1 Channel.
   1696            * This parameter can be one of the following values:
   1697            *                       - TIM1_CHANNEL_1: TIM1 Channel1
   1698            *                       - TIM1_CHANNEL_2: TIM1 Channel2
   1699            *                       - TIM1_CHANNEL_3: TIM1 Channel3
   1700            *                       - TIM1_CHANNEL_4: TIM1 Channel4
   1701            * @param   TIM1_OCMode specifies the TIM1 Output Compare Mode.
   1702            * This parameter can be one of the following values:
   1703            *                       - TIM1_OCMODE_TIMING
   1704            *                       - TIM1_OCMODE_ACTIVE
   1705            *                       - TIM1_OCMODE_TOGGLE
   1706            *                       - TIM1_OCMODE_PWM1
   1707            *                       - TIM1_OCMODE_PWM2
   1708            *                       - TIM1_FORCEDACTION_ACTIVE
   1709            *                       - TIM1_FORCEDACTION_INACTIVE
   1710            * @retval None
   1711            */

   \                                 In section .far_func.text, align 1
   1712          void TIM1_SelectOCxM(TIM1_Channel_TypeDef TIM1_Channel, TIM1_OCMode_TypeDef TIM1_OCMode)
   1713          {
   \                     TIM1_SelectOCxM:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b8, A
   \   000006 45 .. ..     MOV       S:?b9, S:?b0
   1714            /* Check the parameters */
   1715            assert_param(IS_TIM1_CHANNEL_OK(TIM1_Channel));
   \   000009 3D ..        TNZ       S:?b8
   \   00000B 27 21        JREQ      L:??TIM1_SelectOCxM_0
   \   00000D B6 ..        LD        A, S:?b8
   \   00000F A1 01        CP        A, #0x1
   \   000011 27 1B        JREQ      L:??TIM1_SelectOCxM_0
   \   000013 B6 ..        LD        A, S:?b8
   \   000015 A1 02        CP        A, #0x2
   \   000017 27 15        JREQ      L:??TIM1_SelectOCxM_0
   \   000019 B6 ..        LD        A, S:?b8
   \   00001B A1 03        CP        A, #0x3
   \   00001D 27 0F        JREQ      L:??TIM1_SelectOCxM_0
   \   00001F AE 06B3      LDW       X, #0x6b3
   \   000022 BF ..        LDW       S:?w1, X
   \   000024 5F           CLRW      X
   \   000025 BF ..        LDW       S:?w0, X
   \   000027 AE ....      LDW       X, #?_0
   \   00002A 8D ......    CALLF     assert_failed
   1716            assert_param(IS_TIM1_OCM_OK(TIM1_OCMode));
   \                     ??TIM1_SelectOCxM_0:
   \   00002E 3D ..        TNZ       S:?b9
   \   000030 27 39        JREQ      L:??TIM1_SelectOCxM_1
   \   000032 B6 ..        LD        A, S:?b9
   \   000034 A1 10        CP        A, #0x10
   \   000036 27 33        JREQ      L:??TIM1_SelectOCxM_1
   \   000038 B6 ..        LD        A, S:?b9
   \   00003A A1 20        CP        A, #0x20
   \   00003C 27 2D        JREQ      L:??TIM1_SelectOCxM_1
   \   00003E B6 ..        LD        A, S:?b9
   \   000040 A1 30        CP        A, #0x30
   \   000042 27 27        JREQ      L:??TIM1_SelectOCxM_1
   \   000044 B6 ..        LD        A, S:?b9
   \   000046 A1 60        CP        A, #0x60
   \   000048 27 21        JREQ      L:??TIM1_SelectOCxM_1
   \   00004A B6 ..        LD        A, S:?b9
   \   00004C A1 70        CP        A, #0x70
   \   00004E 27 1B        JREQ      L:??TIM1_SelectOCxM_1
   \   000050 B6 ..        LD        A, S:?b9
   \   000052 A1 50        CP        A, #0x50
   \   000054 27 15        JREQ      L:??TIM1_SelectOCxM_1
   \   000056 B6 ..        LD        A, S:?b9
   \   000058 A1 40        CP        A, #0x40
   \   00005A 27 0F        JREQ      L:??TIM1_SelectOCxM_1
   \   00005C AE 06B4      LDW       X, #0x6b4
   \   00005F BF ..        LDW       S:?w1, X
   \   000061 5F           CLRW      X
   \   000062 BF ..        LDW       S:?w0, X
   \   000064 AE ....      LDW       X, #?_0
   \   000067 8D ......    CALLF     assert_failed
   1717            
   1718            if (TIM1_Channel == TIM1_CHANNEL_1)
   \                     ??TIM1_SelectOCxM_1:
   \   00006B 3D ..        TNZ       S:?b8
   \   00006D 26 10        JRNE      L:??TIM1_SelectOCxM_2
   1719            {
   1720              /* Disable the Channel 1: Reset the CCE Bit */
   1721              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \   00006F 7211 525C    BRES      L:0x525c, #0x0
   1722              
   1723              /* Reset the Output Compare Bits & Set the Output Compare Mode */
   1724              TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) 
   1725                                      | (uint8_t)TIM1_OCMode);
   \   000073 C6 5258      LD        A, L:0x5258
   \   000076 A4 8F        AND       A, #0x8f
   \   000078 BA ..        OR        A, S:?b9
   \   00007A C7 5258      LD        L:0x5258, A
   \   00007D 20 3A        JRA       L:??TIM1_SelectOCxM_3
   1726            }
   1727            else if (TIM1_Channel == TIM1_CHANNEL_2)
   \                     ??TIM1_SelectOCxM_2:
   \   00007F B6 ..        LD        A, S:?b8
   \   000081 A1 01        CP        A, #0x1
   \   000083 26 10        JRNE      L:??TIM1_SelectOCxM_4
   1728            {
   1729              /* Disable the Channel 2: Reset the CCE Bit */
   1730              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2E);
   \   000085 7219 525C    BRES      L:0x525c, #0x4
   1731              
   1732              /* Reset the Output Compare Bits & Set the Output Compare Mode */
   1733              TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM))
   1734                                      | (uint8_t)TIM1_OCMode);
   \   000089 C6 5259      LD        A, L:0x5259
   \   00008C A4 8F        AND       A, #0x8f
   \   00008E BA ..        OR        A, S:?b9
   \   000090 C7 5259      LD        L:0x5259, A
   \   000093 20 24        JRA       L:??TIM1_SelectOCxM_3
   1735            }
   1736            else if (TIM1_Channel == TIM1_CHANNEL_3)
   \                     ??TIM1_SelectOCxM_4:
   \   000095 B6 ..        LD        A, S:?b8
   \   000097 A1 02        CP        A, #0x2
   \   000099 26 10        JRNE      L:??TIM1_SelectOCxM_5
   1737            {
   1738              /* Disable the Channel 3: Reset the CCE Bit */
   1739              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3E);
   \   00009B 7211 525D    BRES      L:0x525d, #0x0
   1740              
   1741              /* Reset the Output Compare Bits & Set the Output Compare Mode */
   1742              TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) 
   1743                                      | (uint8_t)TIM1_OCMode);
   \   00009F C6 525A      LD        A, L:0x525a
   \   0000A2 A4 8F        AND       A, #0x8f
   \   0000A4 BA ..        OR        A, S:?b9
   \   0000A6 C7 525A      LD        L:0x525a, A
   \   0000A9 20 0E        JRA       L:??TIM1_SelectOCxM_3
   1744            }
   1745            else
   1746            {
   1747              /* Disable the Channel 4: Reset the CCE Bit */
   1748              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4E);
   \                     ??TIM1_SelectOCxM_5:
   \   0000AB 7219 525D    BRES      L:0x525d, #0x4
   1749              
   1750              /* Reset the Output Compare Bits & Set the Output Compare Mode */
   1751              TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_OCM)) 
   1752                                      | (uint8_t)TIM1_OCMode);
   \   0000AF C6 525B      LD        A, L:0x525b
   \   0000B2 A4 8F        AND       A, #0x8f
   \   0000B4 BA ..        OR        A, S:?b9
   \   0000B6 C7 525B      LD        L:0x525b, A
   1753            }
   1754          }
   \                     ??TIM1_SelectOCxM_3:
   \   0000B9 AC ......    JPF       L:?epilogue_w4
   1755          
   1756          /**
   1757            * @brief  Sets the TIM1 Counter Register value.
   1758            * @param   Counter specifies the Counter register new value.
   1759            * This parameter is between 0x0000 and 0xFFFF.
   1760            * @retval None
   1761            */

   \                                 In section .far_func.text, align 1
   1762          void TIM1_SetCounter(uint16_t Counter)
   1763          {
   1764            /* Set the Counter Register value */
   1765            TIM1->CNTRH = (uint8_t)(Counter >> 8);
   \                     TIM1_SetCounter:
   \   000000 9E           LD        A, XH
   \   000001 C7 525E      LD        L:0x525e, A
   1766            TIM1->CNTRL = (uint8_t)(Counter);
   \   000004 9F           LD        A, XL
   \   000005 C7 525F      LD        L:0x525f, A
   1767          }
   \   000008 87           RETF
   1768          
   1769          /**
   1770            * @brief  Sets the TIM1 Autoreload Register value.
   1771            * @param   Autoreload specifies the Autoreload register new value.
   1772            * This parameter is between 0x0000 and 0xFFFF.
   1773            * @retval None
   1774            */

   \                                 In section .far_func.text, align 1
   1775          void TIM1_SetAutoreload(uint16_t Autoreload)
   1776          {
   1777            /* Set the Autoreload Register value */
   1778            TIM1->ARRH = (uint8_t)(Autoreload >> 8);
   \                     TIM1_SetAutoreload:
   \   000000 9E           LD        A, XH
   \   000001 C7 5262      LD        L:0x5262, A
   1779            TIM1->ARRL = (uint8_t)(Autoreload);
   \   000004 9F           LD        A, XL
   \   000005 C7 5263      LD        L:0x5263, A
   1780           }
   \   000008 87           RETF
   1781          
   1782          /**
   1783            * @brief  Sets the TIM1 Capture Compare1 Register value.
   1784            * @param   Compare1 specifies the Capture Compare1 register new value.
   1785            * This parameter is between 0x0000 and 0xFFFF.
   1786            * @retval None
   1787            */

   \                                 In section .far_func.text, align 1
   1788          void TIM1_SetCompare1(uint16_t Compare1)
   1789          {
   1790            /* Set the Capture Compare1 Register value */
   1791            TIM1->CCR1H = (uint8_t)(Compare1 >> 8);
   \                     TIM1_SetCompare1:
   \   000000 9E           LD        A, XH
   \   000001 C7 5265      LD        L:0x5265, A
   1792            TIM1->CCR1L = (uint8_t)(Compare1);
   \   000004 9F           LD        A, XL
   \   000005 C7 5266      LD        L:0x5266, A
   1793          }
   \   000008 87           RETF
   1794          
   1795          /**
   1796            * @brief  Sets the TIM1 Capture Compare2 Register value.
   1797            * @param   Compare2 specifies the Capture Compare2 register new value.
   1798            * This parameter is between 0x0000 and 0xFFFF.
   1799            * @retval None
   1800            */

   \                                 In section .far_func.text, align 1
   1801          void TIM1_SetCompare2(uint16_t Compare2)
   1802          {
   1803            /* Set the Capture Compare2 Register value */
   1804            TIM1->CCR2H = (uint8_t)(Compare2 >> 8);
   \                     TIM1_SetCompare2:
   \   000000 9E           LD        A, XH
   \   000001 C7 5267      LD        L:0x5267, A
   1805            TIM1->CCR2L = (uint8_t)(Compare2);
   \   000004 9F           LD        A, XL
   \   000005 C7 5268      LD        L:0x5268, A
   1806          }
   \   000008 87           RETF
   1807          
   1808          /**
   1809            * @brief  Sets the TIM1 Capture Compare3 Register value.
   1810            * @param   Compare3 specifies the Capture Compare3 register new value.
   1811            * This parameter is between 0x0000 and 0xFFFF.
   1812            * @retval None
   1813            */

   \                                 In section .far_func.text, align 1
   1814          void TIM1_SetCompare3(uint16_t Compare3)
   1815          {
   1816            /* Set the Capture Compare3 Register value */
   1817            TIM1->CCR3H = (uint8_t)(Compare3 >> 8);
   \                     TIM1_SetCompare3:
   \   000000 9E           LD        A, XH
   \   000001 C7 5269      LD        L:0x5269, A
   1818            TIM1->CCR3L = (uint8_t)(Compare3);
   \   000004 9F           LD        A, XL
   \   000005 C7 526A      LD        L:0x526a, A
   1819          }
   \   000008 87           RETF
   1820          
   1821          /**
   1822            * @brief  Sets the TIM1 Capture Compare4 Register value.
   1823            * @param   Compare4 specifies the Capture Compare4 register new value.
   1824            * This parameter is between 0x0000 and 0xFFFF.
   1825            * @retval None
   1826            */

   \                                 In section .far_func.text, align 1
   1827          void TIM1_SetCompare4(uint16_t Compare4)
   1828          {
   1829            /* Set the Capture Compare4 Register value */
   1830            TIM1->CCR4H = (uint8_t)(Compare4 >> 8);
   \                     TIM1_SetCompare4:
   \   000000 9E           LD        A, XH
   \   000001 C7 526B      LD        L:0x526b, A
   1831            TIM1->CCR4L = (uint8_t)(Compare4);
   \   000004 9F           LD        A, XL
   \   000005 C7 526C      LD        L:0x526c, A
   1832          }
   \   000008 87           RETF
   1833          
   1834          /**
   1835            * @brief  Sets the TIM1 Input Capture 1 prescaler.
   1836            * @param   TIM1_IC1Prescaler specifies the Input Capture prescaler new value
   1837            * This parameter can be one of the following values:
   1838            *                       - TIM1_ICPSC_DIV1: no prescaler
   1839            *                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
   1840            *                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
   1841            *                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
   1842            * @retval None
   1843            */

   \                                 In section .far_func.text, align 1
   1844          void TIM1_SetIC1Prescaler(TIM1_ICPSC_TypeDef TIM1_IC1Prescaler)
   1845          {
   \                     TIM1_SetIC1Prescaler:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1846            /* Check the parameters */
   1847            assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_IC1Prescaler));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 21        JREQ      L:??TIM1_SetIC1Prescaler_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 04        CP        A, #0x4
   \   00000D 27 1B        JREQ      L:??TIM1_SetIC1Prescaler_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 08        CP        A, #0x8
   \   000013 27 15        JREQ      L:??TIM1_SetIC1Prescaler_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 0C        CP        A, #0xc
   \   000019 27 0F        JREQ      L:??TIM1_SetIC1Prescaler_0
   \   00001B AE 0737      LDW       X, #0x737
   \   00001E BF ..        LDW       S:?w1, X
   \   000020 5F           CLRW      X
   \   000021 BF ..        LDW       S:?w0, X
   \   000023 AE ....      LDW       X, #?_0
   \   000026 8D ......    CALLF     assert_failed
   1848            
   1849            /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
   1850            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_ICxPSC)) 
   1851                                    | (uint8_t)TIM1_IC1Prescaler);
   \                     ??TIM1_SetIC1Prescaler_0:
   \   00002A C6 5258      LD        A, L:0x5258
   \   00002D A4 F3        AND       A, #0xf3
   \   00002F BA ..        OR        A, S:?b8
   \   000031 C7 5258      LD        L:0x5258, A
   1852          }
   \   000034 32 ....      POP       S:?b8
   \   000037 87           RETF
   1853          
   1854          /**
   1855            * @brief  Sets the TIM1 Input Capture 2 prescaler.
   1856            * @param   TIM1_IC2Prescaler specifies the Input Capture prescaler new value
   1857            * This parameter can be one of the following values:
   1858            *                       - TIM1_ICPSC_DIV1: no prescaler
   1859            *                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
   1860            *                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
   1861            *                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
   1862            * @retval None
   1863            */

   \                                 In section .far_func.text, align 1
   1864          void TIM1_SetIC2Prescaler(TIM1_ICPSC_TypeDef TIM1_IC2Prescaler)
   1865          {
   \                     TIM1_SetIC2Prescaler:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1866            
   1867            /* Check the parameters */
   1868            assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_IC2Prescaler));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 21        JREQ      L:??TIM1_SetIC2Prescaler_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 04        CP        A, #0x4
   \   00000D 27 1B        JREQ      L:??TIM1_SetIC2Prescaler_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 08        CP        A, #0x8
   \   000013 27 15        JREQ      L:??TIM1_SetIC2Prescaler_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 0C        CP        A, #0xc
   \   000019 27 0F        JREQ      L:??TIM1_SetIC2Prescaler_0
   \   00001B AE 074C      LDW       X, #0x74c
   \   00001E BF ..        LDW       S:?w1, X
   \   000020 5F           CLRW      X
   \   000021 BF ..        LDW       S:?w0, X
   \   000023 AE ....      LDW       X, #?_0
   \   000026 8D ......    CALLF     assert_failed
   1869            
   1870            /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
   1871            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_ICxPSC))
   1872                                    | (uint8_t)TIM1_IC2Prescaler);
   \                     ??TIM1_SetIC2Prescaler_0:
   \   00002A C6 5259      LD        A, L:0x5259
   \   00002D A4 F3        AND       A, #0xf3
   \   00002F BA ..        OR        A, S:?b8
   \   000031 C7 5259      LD        L:0x5259, A
   1873          }
   \   000034 32 ....      POP       S:?b8
   \   000037 87           RETF
   1874          
   1875          /**
   1876            * @brief  Sets the TIM1 Input Capture 3 prescaler.
   1877            * @param   TIM1_IC3Prescaler specifies the Input Capture prescaler new value
   1878            * This parameter can be one of the following values:
   1879            *                       - TIM1_ICPSC_DIV1: no prescaler
   1880            *                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
   1881            *                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
   1882            *                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
   1883            * @retval None
   1884            */

   \                                 In section .far_func.text, align 1
   1885          void TIM1_SetIC3Prescaler(TIM1_ICPSC_TypeDef TIM1_IC3Prescaler)
   1886          {
   \                     TIM1_SetIC3Prescaler:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1887            
   1888            /* Check the parameters */
   1889            assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_IC3Prescaler));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 21        JREQ      L:??TIM1_SetIC3Prescaler_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 04        CP        A, #0x4
   \   00000D 27 1B        JREQ      L:??TIM1_SetIC3Prescaler_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 08        CP        A, #0x8
   \   000013 27 15        JREQ      L:??TIM1_SetIC3Prescaler_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 0C        CP        A, #0xc
   \   000019 27 0F        JREQ      L:??TIM1_SetIC3Prescaler_0
   \   00001B AE 0761      LDW       X, #0x761
   \   00001E BF ..        LDW       S:?w1, X
   \   000020 5F           CLRW      X
   \   000021 BF ..        LDW       S:?w0, X
   \   000023 AE ....      LDW       X, #?_0
   \   000026 8D ......    CALLF     assert_failed
   1890            
   1891            /* Reset the IC1PSC Bits & Set the IC1PSC value */
   1892            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | 
   1893                                    (uint8_t)TIM1_IC3Prescaler);
   \                     ??TIM1_SetIC3Prescaler_0:
   \   00002A C6 525A      LD        A, L:0x525a
   \   00002D A4 F3        AND       A, #0xf3
   \   00002F BA ..        OR        A, S:?b8
   \   000031 C7 525A      LD        L:0x525a, A
   1894          }
   \   000034 32 ....      POP       S:?b8
   \   000037 87           RETF
   1895          
   1896          /**
   1897            * @brief  Sets the TIM1 Input Capture 4 prescaler.
   1898            * @param  TIM1_IC4Prescaler specifies the Input Capture prescaler new value
   1899            *         This parameter can be one of the following values:
   1900            *                       - TIM1_ICPSC_DIV1: no prescaler
   1901            *                       - TIM1_ICPSC_DIV2: capture is done once every 2 events
   1902            *                       - TIM1_ICPSC_DIV4: capture is done once every 4 events
   1903            *                       - TIM1_ICPSC_DIV8: capture is done once every 8 events
   1904            * @retval None
   1905            */

   \                                 In section .far_func.text, align 1
   1906          void TIM1_SetIC4Prescaler(TIM1_ICPSC_TypeDef TIM1_IC4Prescaler)
   1907          {
   \                     TIM1_SetIC4Prescaler:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   1908            
   1909            /* Check the parameters */
   1910            assert_param(IS_TIM1_IC_PRESCALER_OK(TIM1_IC4Prescaler));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 21        JREQ      L:??TIM1_SetIC4Prescaler_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 04        CP        A, #0x4
   \   00000D 27 1B        JREQ      L:??TIM1_SetIC4Prescaler_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 08        CP        A, #0x8
   \   000013 27 15        JREQ      L:??TIM1_SetIC4Prescaler_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 0C        CP        A, #0xc
   \   000019 27 0F        JREQ      L:??TIM1_SetIC4Prescaler_0
   \   00001B AE 0776      LDW       X, #0x776
   \   00001E BF ..        LDW       S:?w1, X
   \   000020 5F           CLRW      X
   \   000021 BF ..        LDW       S:?w0, X
   \   000023 AE ....      LDW       X, #?_0
   \   000026 8D ......    CALLF     assert_failed
   1911            
   1912            /* Reset the IC1PSC Bits &  Set the IC1PSC value */
   1913            TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_ICxPSC)) |
   1914                                    (uint8_t)TIM1_IC4Prescaler);
   \                     ??TIM1_SetIC4Prescaler_0:
   \   00002A C6 525B      LD        A, L:0x525b
   \   00002D A4 F3        AND       A, #0xf3
   \   00002F BA ..        OR        A, S:?b8
   \   000031 C7 525B      LD        L:0x525b, A
   1915          }
   \   000034 32 ....      POP       S:?b8
   \   000037 87           RETF
   1916          
   1917          /**
   1918            * @brief  Gets the TIM1 Input Capture 1 value.
   1919            * @param  None
   1920            * @retval Capture Compare 1 Register value.
   1921            */

   \                                 In section .far_func.text, align 1
   1922          uint16_t TIM1_GetCapture1(void)
   1923          {
   1924            /* Get the Capture 1 Register value */
   1925            
   1926            uint16_t tmpccr1 = 0;
   \                     TIM1_GetCapture1:
   \   000000 905F         CLRW      Y
   1927            uint8_t tmpccr1l=0, tmpccr1h=0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
   1928            
   1929            tmpccr1h = TIM1->CCR1H;
   \   000006 C6 5265      LD        A, L:0x5265
   \   000009 B7 ..        LD        S:?b0, A
   1930            tmpccr1l = TIM1->CCR1L;
   \   00000B C6 5266      LD        A, L:0x5266
   \   00000E B7 ..        LD        S:?b1, A
   1931            
   1932            tmpccr1 = (uint16_t)(tmpccr1l);
   \   000010 5F           CLRW      X
   \   000011 B6 ..        LD        A, S:?b1
   \   000013 97           LD        XL, A
   \   000014 9093         LDW       Y, X
   1933            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   \   000016 5F           CLRW      X
   \   000017 B6 ..        LD        A, S:?b0
   \   000019 97           LD        XL, A
   \   00001A 4F           CLR       A
   \   00001B 02           RLWA      X, A
   \   00001C BF ..        LDW       S:?w1, X
   \   00001E 9001         RRWA      Y, A
   \   000020 BA ..        OR        A, S:?b3
   \   000022 9001         RRWA      Y, A
   \   000024 BA ..        OR        A, S:?b2
   \   000026 9001         RRWA      Y, A
   1934            /* Get the Capture 1 Register value */
   1935            return (uint16_t)tmpccr1;
   \   000028 93           LDW       X, Y
   \   000029 87           RETF
   1936          }
   1937          
   1938          /**
   1939            * @brief  Gets the TIM1 Input Capture 2 value.
   1940            * @param  None
   1941            * @retval Capture Compare 2 Register value.
   1942            */

   \                                 In section .far_func.text, align 1
   1943          uint16_t TIM1_GetCapture2(void)
   1944          {
   1945            /* Get the Capture 2 Register value */
   1946            
   1947            uint16_t tmpccr2 = 0;
   \                     TIM1_GetCapture2:
   \   000000 905F         CLRW      Y
   1948            uint8_t tmpccr2l=0, tmpccr2h=0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
   1949            
   1950            tmpccr2h = TIM1->CCR2H;
   \   000006 C6 5267      LD        A, L:0x5267
   \   000009 B7 ..        LD        S:?b0, A
   1951            tmpccr2l = TIM1->CCR2L;
   \   00000B C6 5268      LD        A, L:0x5268
   \   00000E B7 ..        LD        S:?b1, A
   1952            
   1953            tmpccr2 = (uint16_t)(tmpccr2l);
   \   000010 5F           CLRW      X
   \   000011 B6 ..        LD        A, S:?b1
   \   000013 97           LD        XL, A
   \   000014 9093         LDW       Y, X
   1954            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   \   000016 5F           CLRW      X
   \   000017 B6 ..        LD        A, S:?b0
   \   000019 97           LD        XL, A
   \   00001A 4F           CLR       A
   \   00001B 02           RLWA      X, A
   \   00001C BF ..        LDW       S:?w1, X
   \   00001E 9001         RRWA      Y, A
   \   000020 BA ..        OR        A, S:?b3
   \   000022 9001         RRWA      Y, A
   \   000024 BA ..        OR        A, S:?b2
   \   000026 9001         RRWA      Y, A
   1955            /* Get the Capture 2 Register value */
   1956            return (uint16_t)tmpccr2;
   \   000028 93           LDW       X, Y
   \   000029 87           RETF
   1957          }
   1958          
   1959          /**
   1960            * @brief  Gets the TIM1 Input Capture 3 value.
   1961            * @param  None
   1962            * @retval Capture Compare 3 Register value.
   1963            */

   \                                 In section .far_func.text, align 1
   1964          uint16_t TIM1_GetCapture3(void)
   1965          {
   1966            /* Get the Capture 3 Register value */
   1967            uint16_t tmpccr3 = 0;
   \                     TIM1_GetCapture3:
   \   000000 905F         CLRW      Y
   1968            uint8_t tmpccr3l=0, tmpccr3h=0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
   1969            
   1970            tmpccr3h = TIM1->CCR3H;
   \   000006 C6 5269      LD        A, L:0x5269
   \   000009 B7 ..        LD        S:?b0, A
   1971            tmpccr3l = TIM1->CCR3L;
   \   00000B C6 526A      LD        A, L:0x526a
   \   00000E B7 ..        LD        S:?b1, A
   1972            
   1973            tmpccr3 = (uint16_t)(tmpccr3l);
   \   000010 5F           CLRW      X
   \   000011 B6 ..        LD        A, S:?b1
   \   000013 97           LD        XL, A
   \   000014 9093         LDW       Y, X
   1974            tmpccr3 |= (uint16_t)((uint16_t)tmpccr3h << 8);
   \   000016 5F           CLRW      X
   \   000017 B6 ..        LD        A, S:?b0
   \   000019 97           LD        XL, A
   \   00001A 4F           CLR       A
   \   00001B 02           RLWA      X, A
   \   00001C BF ..        LDW       S:?w1, X
   \   00001E 9001         RRWA      Y, A
   \   000020 BA ..        OR        A, S:?b3
   \   000022 9001         RRWA      Y, A
   \   000024 BA ..        OR        A, S:?b2
   \   000026 9001         RRWA      Y, A
   1975            /* Get the Capture 3 Register value */
   1976            return (uint16_t)tmpccr3;
   \   000028 93           LDW       X, Y
   \   000029 87           RETF
   1977          }
   1978          
   1979          /**
   1980            * @brief  Gets the TIM1 Input Capture 4 value.
   1981            * @param  None
   1982            * @retval Capture Compare 4 Register value.
   1983            */

   \                                 In section .far_func.text, align 1
   1984          uint16_t TIM1_GetCapture4(void)
   1985          {
   1986            /* Get the Capture 4 Register value */
   1987            uint16_t tmpccr4 = 0;
   \                     TIM1_GetCapture4:
   \   000000 905F         CLRW      Y
   1988            uint8_t tmpccr4l=0, tmpccr4h=0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
   1989            
   1990            tmpccr4h = TIM1->CCR4H;
   \   000006 C6 526B      LD        A, L:0x526b
   \   000009 B7 ..        LD        S:?b0, A
   1991            tmpccr4l = TIM1->CCR4L;
   \   00000B C6 526C      LD        A, L:0x526c
   \   00000E B7 ..        LD        S:?b1, A
   1992            
   1993            tmpccr4 = (uint16_t)(tmpccr4l);
   \   000010 5F           CLRW      X
   \   000011 B6 ..        LD        A, S:?b1
   \   000013 97           LD        XL, A
   \   000014 9093         LDW       Y, X
   1994            tmpccr4 |= (uint16_t)((uint16_t)tmpccr4h << 8);
   \   000016 5F           CLRW      X
   \   000017 B6 ..        LD        A, S:?b0
   \   000019 97           LD        XL, A
   \   00001A 4F           CLR       A
   \   00001B 02           RLWA      X, A
   \   00001C BF ..        LDW       S:?w1, X
   \   00001E 9001         RRWA      Y, A
   \   000020 BA ..        OR        A, S:?b3
   \   000022 9001         RRWA      Y, A
   \   000024 BA ..        OR        A, S:?b2
   \   000026 9001         RRWA      Y, A
   1995            /* Get the Capture 4 Register value */
   1996            return (uint16_t)tmpccr4;
   \   000028 93           LDW       X, Y
   \   000029 87           RETF
   1997          }
   1998          
   1999          /**
   2000            * @brief  Gets the TIM1 Counter value.
   2001            * @param  None
   2002            * @retval Counter Register value.
   2003            */

   \                                 In section .far_func.text, align 1
   2004          uint16_t TIM1_GetCounter(void)
   2005          {
   2006            uint16_t tmpcntr = 0;
   \                     TIM1_GetCounter:
   \   000000 905F         CLRW      Y
   2007            
   2008            tmpcntr = ((uint16_t)TIM1->CNTRH << 8);
   \   000002 C6 525E      LD        A, L:0x525e
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 4F           CLR       A
   \   000008 02           RLWA      X, A
   \   000009 9093         LDW       Y, X
   2009            
   2010            /* Get the Counter Register value */
   2011            return (uint16_t)(tmpcntr | (uint16_t)(TIM1->CNTRL));
   \   00000B C6 525F      LD        A, L:0x525f
   \   00000E 3F ..        CLR       S:?b0
   \   000010 B7 ..        LD        S:?b1, A
   \   000012 93           LDW       X, Y
   \   000013 01           RRWA      X, A
   \   000014 BA ..        OR        A, S:?b1
   \   000016 01           RRWA      X, A
   \   000017 BA ..        OR        A, S:?b0
   \   000019 01           RRWA      X, A
   \   00001A 87           RETF
   2012          }
   2013          
   2014          /**
   2015            * @brief  Gets the TIM1 Prescaler value.
   2016            * @param  None
   2017            * @retval Prescaler Register value.
   2018            */

   \                                 In section .far_func.text, align 1
   2019          uint16_t TIM1_GetPrescaler(void)
   2020          {
   2021            uint16_t temp = 0;
   \                     TIM1_GetPrescaler:
   \   000000 905F         CLRW      Y
   2022            
   2023            temp = ((uint16_t)TIM1->PSCRH << 8);
   \   000002 C6 5260      LD        A, L:0x5260
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 4F           CLR       A
   \   000008 02           RLWA      X, A
   \   000009 9093         LDW       Y, X
   2024            
   2025            /* Get the Prescaler Register value */
   2026            return (uint16_t)( temp | (uint16_t)(TIM1->PSCRL));
   \   00000B C6 5261      LD        A, L:0x5261
   \   00000E 3F ..        CLR       S:?b0
   \   000010 B7 ..        LD        S:?b1, A
   \   000012 93           LDW       X, Y
   \   000013 01           RRWA      X, A
   \   000014 BA ..        OR        A, S:?b1
   \   000016 01           RRWA      X, A
   \   000017 BA ..        OR        A, S:?b0
   \   000019 01           RRWA      X, A
   \   00001A 87           RETF
   2027          }
   2028          
   2029          /**
   2030            * @brief  Checks whether the specified TIM1 flag is set or not.
   2031            * @param  TIM1_FLAG specifies the flag to check.
   2032            *         This parameter can be one of the following values:
   2033            *                   - TIM1_FLAG_UPDATE: TIM1 update Flag
   2034            *                   - TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
   2035            *                   - TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
   2036            *                   - TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
   2037            *                   - TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
   2038            *                   - TIM1_FLAG_COM: TIM1 Commutation Flag
   2039            *                   - TIM1_FLAG_TRIGGER: TIM1 Trigger Flag
   2040            *                   - TIM1_FLAG_BREAK: TIM1 Break Flag
   2041            *                   - TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
   2042            *                   - TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
   2043            *                   - TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
   2044            *                   - TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
   2045            * @retval FlagStatus The new state of TIM1_FLAG (SET or RESET).
   2046            */

   \                                 In section .far_func.text, align 1
   2047          FlagStatus TIM1_GetFlagStatus(TIM1_FLAG_TypeDef TIM1_FLAG)
   2048          {
   \                     TIM1_GetFlagStatus:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 3B ....      PUSH      S:?b12
   \   000007 BF ..        LDW       S:?w4, X
   2049            FlagStatus bitstatus = RESET;
   \   000009 3F ..        CLR       S:?b10
   2050            uint8_t tim1_flag_l = 0, tim1_flag_h = 0;
   \   00000B 3F ..        CLR       S:?b12
   \   00000D 3F ..        CLR       S:?b11
   2051            
   2052            /* Check the parameters */
   2053            assert_param(IS_TIM1_GET_FLAG_OK(TIM1_FLAG));
   \   00000F BE ..        LDW       X, S:?w4
   \   000011 A3 0001      CPW       X, #0x1
   \   000014 27 5C        JREQ      L:??TIM1_GetFlagStatus_0
   \   000016 BE ..        LDW       X, S:?w4
   \   000018 A3 0002      CPW       X, #0x2
   \   00001B 27 55        JREQ      L:??TIM1_GetFlagStatus_0
   \   00001D BE ..        LDW       X, S:?w4
   \   00001F A3 0004      CPW       X, #0x4
   \   000022 27 4E        JREQ      L:??TIM1_GetFlagStatus_0
   \   000024 BE ..        LDW       X, S:?w4
   \   000026 A3 0008      CPW       X, #0x8
   \   000029 27 47        JREQ      L:??TIM1_GetFlagStatus_0
   \   00002B BE ..        LDW       X, S:?w4
   \   00002D A3 0010      CPW       X, #0x10
   \   000030 27 40        JREQ      L:??TIM1_GetFlagStatus_0
   \   000032 BE ..        LDW       X, S:?w4
   \   000034 A3 0020      CPW       X, #0x20
   \   000037 27 39        JREQ      L:??TIM1_GetFlagStatus_0
   \   000039 BE ..        LDW       X, S:?w4
   \   00003B A3 0040      CPW       X, #0x40
   \   00003E 27 32        JREQ      L:??TIM1_GetFlagStatus_0
   \   000040 BE ..        LDW       X, S:?w4
   \   000042 A3 0080      CPW       X, #0x80
   \   000045 27 2B        JREQ      L:??TIM1_GetFlagStatus_0
   \   000047 BE ..        LDW       X, S:?w4
   \   000049 A3 0200      CPW       X, #0x200
   \   00004C 27 24        JREQ      L:??TIM1_GetFlagStatus_0
   \   00004E BE ..        LDW       X, S:?w4
   \   000050 A3 0400      CPW       X, #0x400
   \   000053 27 1D        JREQ      L:??TIM1_GetFlagStatus_0
   \   000055 BE ..        LDW       X, S:?w4
   \   000057 A3 0800      CPW       X, #0x800
   \   00005A 27 16        JREQ      L:??TIM1_GetFlagStatus_0
   \   00005C BE ..        LDW       X, S:?w4
   \   00005E A3 1000      CPW       X, #0x1000
   \   000061 27 0F        JREQ      L:??TIM1_GetFlagStatus_0
   \   000063 AE 0805      LDW       X, #0x805
   \   000066 BF ..        LDW       S:?w1, X
   \   000068 5F           CLRW      X
   \   000069 BF ..        LDW       S:?w0, X
   \   00006B AE ....      LDW       X, #?_0
   \   00006E 8D ......    CALLF     assert_failed
   2054            
   2055            tim1_flag_l = (uint8_t)(TIM1->SR1 & (uint8_t)TIM1_FLAG);
   \                     ??TIM1_GetFlagStatus_0:
   \   000072 B6 ..        LD        A, S:?b9
   \   000074 C4 5255      AND       A, L:0x5255
   \   000077 B7 ..        LD        S:?b12, A
   2056            tim1_flag_h = (uint8_t)((uint16_t)TIM1_FLAG >> 8);
   \   000079 45 .. ..     MOV       S:?b11, S:?b8
   2057            
   2058            if ((tim1_flag_l | (uint8_t)(TIM1->SR2 & tim1_flag_h)) != 0)
   \   00007C C6 5256      LD        A, L:0x5256
   \   00007F B4 ..        AND       A, S:?b11
   \   000081 BA ..        OR        A, S:?b12
   \   000083 A1 00        CP        A, #0x0
   \   000085 27 06        JREQ      L:??TIM1_GetFlagStatus_1
   2059            {
   2060              bitstatus = SET;
   \   000087 A6 01        LD        A, #0x1
   \   000089 B7 ..        LD        S:?b10, A
   \   00008B 20 02        JRA       L:??TIM1_GetFlagStatus_2
   2061            }
   2062            else
   2063            {
   2064              bitstatus = RESET;
   \                     ??TIM1_GetFlagStatus_1:
   \   00008D 3F ..        CLR       S:?b10
   2065            }
   2066            return (FlagStatus)(bitstatus);
   \                     ??TIM1_GetFlagStatus_2:
   \   00008F B6 ..        LD        A, S:?b10
   \   000091 32 ....      POP       S:?b12
   \   000094 AC ......    JPF       L:?epilogue_l2
   2067          }
   2068          
   2069          /**
   2070            * @brief  Clears the TIM1s pending flags.
   2071            * @param  TIM1_FLAG specifies the flag to clear.
   2072            *         This parameter can be one of the following values:
   2073            *                       - TIM1_FLAG_UPDATE: TIM1 update Flag
   2074            *                       - TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
   2075            *                       - TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
   2076            *                       - TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
   2077            *                       - TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
   2078            *                       - TIM1_FLAG_COM: TIM1 Commutation Flag
   2079            *                       - TIM1_FLAG_TRIGGER: TIM1 Trigger Flag
   2080            *                       - TIM1_FLAG_BREAK: TIM1 Break Flag
   2081            *                       - TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
   2082            *                       - TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
   2083            *                       - TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
   2084            *                       - TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
   2085            * @retval None.
   2086            */

   \                                 In section .far_func.text, align 1
   2087          void TIM1_ClearFlag(TIM1_FLAG_TypeDef TIM1_FLAG)
   2088          {
   \                     TIM1_ClearFlag:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
   2089            /* Check the parameters */
   2090            assert_param(IS_TIM1_CLEAR_FLAG_OK(TIM1_FLAG));
   \   000006 BE ..        LDW       X, S:?w4
   \   000008 02           RLWA      X, A
   \   000009 A4 E1        AND       A, #0xe1
   \   00000B 02           RLWA      X, A
   \   00000C A4 00        AND       A, #0x0
   \   00000E 02           RLWA      X, A
   \   00000F 5D           TNZW      X
   \   000010 26 05        JRNE      L:??TIM1_ClearFlag_0
   \   000012 BE ..        LDW       X, S:?w4
   \   000014 5D           TNZW      X
   \   000015 26 0F        JRNE      L:??TIM1_ClearFlag_1
   \                     ??TIM1_ClearFlag_0:
   \   000017 AE 082A      LDW       X, #0x82a
   \   00001A BF ..        LDW       S:?w1, X
   \   00001C 5F           CLRW      X
   \   00001D BF ..        LDW       S:?w0, X
   \   00001F AE ....      LDW       X, #?_0
   \   000022 8D ......    CALLF     assert_failed
   2091            
   2092            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing 1 has no effect*/
   2093            TIM1->SR1 = (uint8_t)(~(uint8_t)(TIM1_FLAG));
   \                     ??TIM1_ClearFlag_1:
   \   000026 B6 ..        LD        A, S:?b9
   \   000028 43           CPL       A
   \   000029 C7 5255      LD        L:0x5255, A
   2094            TIM1->SR2 = (uint8_t)((uint8_t)(~((uint8_t)((uint16_t)TIM1_FLAG >> 8))) & 
   2095                                  (uint8_t)0x1E);
   \   00002C B6 ..        LD        A, S:?b8
   \   00002E 43           CPL       A
   \   00002F A4 1E        AND       A, #0x1e
   \   000031 C7 5256      LD        L:0x5256, A
   2096          }
   \   000034 AC ......    JPF       L:?epilogue_w4
   2097          
   2098          /**
   2099            * @brief  Checks whether the TIM1 interrupt has occurred or not.
   2100            * @param  TIM1_IT specifies the TIM1 interrupt source to check.
   2101            *         This parameter can be one of the following values:
   2102            *                       - TIM1_IT_UPDATE: TIM1 update Interrupt source
   2103            *                       - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
   2104            *                       - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
   2105            *                       - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
   2106            *                       - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
   2107            *                       - TIM1_IT_COM: TIM1 Commutation Interrupt source
   2108            *                       - TIM1_IT_TRIGGER: TIM1 Trigger Interrupt source
   2109            *                       - TIM1_IT_BREAK: TIM1 Break Interrupt source
   2110            * @retval ITStatus The new state of the TIM1_IT(SET or RESET).
   2111            */

   \                                 In section .far_func.text, align 1
   2112          ITStatus TIM1_GetITStatus(TIM1_IT_TypeDef TIM1_IT)
   2113          {
   \                     TIM1_GetITStatus:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 B7 ..        LD        S:?b11, A
   2114            ITStatus bitstatus = RESET;
   \   000006 3F ..        CLR       S:?b8
   2115            uint8_t TIM1_itStatus = 0, TIM1_itEnable = 0;
   \   000008 3F ..        CLR       S:?b9
   \   00000A 3F ..        CLR       S:?b10
   2116            
   2117            /* Check the parameters */
   2118            assert_param(IS_TIM1_GET_IT_OK(TIM1_IT));
   \   00000C B6 ..        LD        A, S:?b11
   \   00000E A1 01        CP        A, #0x1
   \   000010 27 39        JREQ      L:??TIM1_GetITStatus_0
   \   000012 B6 ..        LD        A, S:?b11
   \   000014 A1 02        CP        A, #0x2
   \   000016 27 33        JREQ      L:??TIM1_GetITStatus_0
   \   000018 B6 ..        LD        A, S:?b11
   \   00001A A1 04        CP        A, #0x4
   \   00001C 27 2D        JREQ      L:??TIM1_GetITStatus_0
   \   00001E B6 ..        LD        A, S:?b11
   \   000020 A1 08        CP        A, #0x8
   \   000022 27 27        JREQ      L:??TIM1_GetITStatus_0
   \   000024 B6 ..        LD        A, S:?b11
   \   000026 A1 10        CP        A, #0x10
   \   000028 27 21        JREQ      L:??TIM1_GetITStatus_0
   \   00002A B6 ..        LD        A, S:?b11
   \   00002C A1 20        CP        A, #0x20
   \   00002E 27 1B        JREQ      L:??TIM1_GetITStatus_0
   \   000030 B6 ..        LD        A, S:?b11
   \   000032 A1 40        CP        A, #0x40
   \   000034 27 15        JREQ      L:??TIM1_GetITStatus_0
   \   000036 B6 ..        LD        A, S:?b11
   \   000038 A1 80        CP        A, #0x80
   \   00003A 27 0F        JREQ      L:??TIM1_GetITStatus_0
   \   00003C AE 0846      LDW       X, #0x846
   \   00003F BF ..        LDW       S:?w1, X
   \   000041 5F           CLRW      X
   \   000042 BF ..        LDW       S:?w0, X
   \   000044 AE ....      LDW       X, #?_0
   \   000047 8D ......    CALLF     assert_failed
   2119            
   2120            TIM1_itStatus = (uint8_t)(TIM1->SR1 & (uint8_t)TIM1_IT);
   \                     ??TIM1_GetITStatus_0:
   \   00004B C6 5255      LD        A, L:0x5255
   \   00004E B4 ..        AND       A, S:?b11
   \   000050 B7 ..        LD        S:?b9, A
   2121            
   2122            TIM1_itEnable = (uint8_t)(TIM1->IER & (uint8_t)TIM1_IT);
   \   000052 C6 5254      LD        A, L:0x5254
   \   000055 B4 ..        AND       A, S:?b11
   \   000057 B7 ..        LD        S:?b10, A
   2123            
   2124            if ((TIM1_itStatus != (uint8_t)RESET ) && (TIM1_itEnable != (uint8_t)RESET ))
   \   000059 3D ..        TNZ       S:?b9
   \   00005B 27 0A        JREQ      L:??TIM1_GetITStatus_1
   \   00005D 3D ..        TNZ       S:?b10
   \   00005F 27 06        JREQ      L:??TIM1_GetITStatus_1
   2125            {
   2126              bitstatus = SET;
   \   000061 A6 01        LD        A, #0x1
   \   000063 B7 ..        LD        S:?b8, A
   \   000065 20 02        JRA       L:??TIM1_GetITStatus_2
   2127            }
   2128            else
   2129            {
   2130              bitstatus = RESET;
   \                     ??TIM1_GetITStatus_1:
   \   000067 3F ..        CLR       S:?b8
   2131            }
   2132            return (ITStatus)(bitstatus);
   \                     ??TIM1_GetITStatus_2:
   \   000069 B6 ..        LD        A, S:?b8
   \   00006B AC ......    JPF       L:?epilogue_l2
   2133          }
   2134          
   2135          /**
   2136            * @brief  Clears the TIM1's interrupt pending bits.
   2137            * @param  TIM1_IT specifies the pending bit to clear.
   2138            *         This parameter can be one of the following values:
   2139            *                       - TIM1_IT_UPDATE: TIM1 update Interrupt source
   2140            *                       - TIM1_IT_CC1: TIM1 Capture Compare 1 Interrupt source
   2141            *                       - TIM1_IT_CC2: TIM1 Capture Compare 2 Interrupt source
   2142            *                       - TIM1_IT_CC3: TIM1 Capture Compare 3 Interrupt source
   2143            *                       - TIM1_IT_CC4: TIM1 Capture Compare 4 Interrupt source
   2144            *                       - TIM1_IT_COM: TIM1 Commutation Interrupt source
   2145            *                       - TIM1_IT_TRIGGER: TIM1 Trigger Interrupt source
   2146            *                       - TIM1_IT_BREAK: TIM1 Break Interrupt source
   2147            * @retval None.
   2148            */

   \                                 In section .far_func.text, align 1
   2149          void TIM1_ClearITPendingBit(TIM1_IT_TypeDef TIM1_IT)
   2150          {
   \                     TIM1_ClearITPendingBit:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
   2151            /* Check the parameters */
   2152            assert_param(IS_TIM1_IT_OK(TIM1_IT));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 26 0F        JRNE      L:??TIM1_ClearITPendingBit_0
   \   000009 AE 0868      LDW       X, #0x868
   \   00000C BF ..        LDW       S:?w1, X
   \   00000E 5F           CLRW      X
   \   00000F BF ..        LDW       S:?w0, X
   \   000011 AE ....      LDW       X, #?_0
   \   000014 8D ......    CALLF     assert_failed
   2153            
   2154            /* Clear the IT pending Bit */
   2155            TIM1->SR1 = (uint8_t)(~(uint8_t)TIM1_IT);
   \                     ??TIM1_ClearITPendingBit_0:
   \   000018 B6 ..        LD        A, S:?b8
   \   00001A 43           CPL       A
   \   00001B C7 5255      LD        L:0x5255, A
   2156          }
   \   00001E 32 ....      POP       S:?b8
   \   000021 87           RETF
   2157          
   2158          /**
   2159            * @brief  Configure the TI1 as Input.
   2160            * @param  TIM1_ICPolarity  The Input Polarity.
   2161            *         This parameter can be one of the following values:
   2162            *                       - TIM1_ICPOLARITY_FALLING
   2163            *                       - TIM1_ICPOLARITY_RISING
   2164            * @param  TIM1_ICSelection specifies the input to be used.
   2165            *         This parameter can be one of the following values:
   2166            *                       - TIM1_ICSELECTION_DIRECTTI: TIM1 Input 1 is selected to
   2167            *                         be connected to IC1.
   2168            *                       - TIM1_ICSELECTION_INDIRECTTI: TIM1 Input 1 is selected to
   2169            *                         be connected to IC2.
   2170            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2171            *         This parameter must be a value between 0x00 and 0x0F.
   2172            * @retval None
   2173            */

   \                                 In section .far_func.text, align 1
   2174          static void TI1_Config(uint8_t TIM1_ICPolarity,
   2175                                 uint8_t TIM1_ICSelection,
   2176                                 uint8_t TIM1_ICFilter)
   2177          {
   \                     TI1_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2178            /* Disable the Channel 1: Reset the CCE Bit */
   2179            TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \   000002 7211 525C    BRES      L:0x525c, #0x0
   2180            
   2181            /* Select the Input and set the filter */
   2182            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~(uint8_t)( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF ))) | 
   2183                                    (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000006 B6 ..        LD        A, S:?b1
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 88           PUSH      A
   \   00000E C6 5258      LD        A, L:0x5258
   \   000011 A4 0C        AND       A, #0xc
   \   000013 B7 ..        LD        S:?b4, A
   \   000015 84           POP       A
   \   000016 BA ..        OR        A, S:?b4
   \   000018 C7 5258      LD        L:0x5258, A
   2184            
   2185            /* Select the Polarity */
   2186            if (TIM1_ICPolarity != TIM1_ICPOLARITY_RISING)
   \   00001B 3D ..        TNZ       S:?b2
   \   00001D 27 06        JREQ      L:??TI1_Config_0
   2187            {
   2188              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \   00001F 7212 525C    BSET      L:0x525c, #0x1
   \   000023 20 04        JRA       L:??TI1_Config_1
   2189            }
   2190            else
   2191            {
   2192              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TI1_Config_0:
   \   000025 7213 525C    BRES      L:0x525c, #0x1
   2193            }
   2194            
   2195            /* Set the CCE Bit */
   2196            TIM1->CCER1 |=  TIM1_CCER1_CC1E;
   \                     ??TI1_Config_1:
   \   000029 7210 525C    BSET      L:0x525c, #0x0
   2197          }
   \   00002D 87           RETF
   2198          
   2199          /**
   2200            * @brief  Configure the TI2 as Input.
   2201            * @param  TIM1_ICPolarity  The Input Polarity.
   2202            *         This parameter can be one of the following values:
   2203            *                       - TIM1_ICPOLARITY_FALLING
   2204            *                       - TIM1_ICPOLARITY_RISING
   2205            * @param  TIM1_ICSelection specifies the input to be used.
   2206            *         This parameter can be one of the following values:
   2207            *                       - TIM1_ICSELECTION_DIRECTTI: TIM1 Input 2 is selected to
   2208            *                         be connected to IC2.
   2209            *                       - TIM1_ICSELECTION_INDIRECTTI: TIM1 Input 2 is selected to
   2210            *                         be connected to IC1.
   2211            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2212            *         This parameter must be a value between 0x00 and 0x0F.
   2213            * @retval None
   2214            */

   \                                 In section .far_func.text, align 1
   2215          static void TI2_Config(uint8_t TIM1_ICPolarity,
   2216                                 uint8_t TIM1_ICSelection,
   2217                                 uint8_t TIM1_ICFilter)
   2218          {
   \                     TI2_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2219            /* Disable the Channel 2: Reset the CCE Bit */
   2220            TIM1->CCER1 &=  (uint8_t)(~TIM1_CCER1_CC2E);
   \   000002 7219 525C    BRES      L:0x525c, #0x4
   2221            
   2222            /* Select the Input and set the filter */
   2223            TIM1->CCMR2  = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~(uint8_t)( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF ))) 
   2224                                     | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000006 B6 ..        LD        A, S:?b1
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 88           PUSH      A
   \   00000E C6 5259      LD        A, L:0x5259
   \   000011 A4 0C        AND       A, #0xc
   \   000013 B7 ..        LD        S:?b4, A
   \   000015 84           POP       A
   \   000016 BA ..        OR        A, S:?b4
   \   000018 C7 5259      LD        L:0x5259, A
   2225            /* Select the Polarity */
   2226            if (TIM1_ICPolarity != TIM1_ICPOLARITY_RISING)
   \   00001B 3D ..        TNZ       S:?b2
   \   00001D 27 06        JREQ      L:??TI2_Config_0
   2227            {
   2228              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \   00001F 721A 525C    BSET      L:0x525c, #0x5
   \   000023 20 04        JRA       L:??TI2_Config_1
   2229            }
   2230            else
   2231            {
   2232              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TI2_Config_0:
   \   000025 721B 525C    BRES      L:0x525c, #0x5
   2233            }
   2234            /* Set the CCE Bit */
   2235            TIM1->CCER1 |=  TIM1_CCER1_CC2E;
   \                     ??TI2_Config_1:
   \   000029 7218 525C    BSET      L:0x525c, #0x4
   2236          }
   \   00002D 87           RETF
   2237          
   2238          /**
   2239            * @brief  Configure the TI3 as Input.
   2240            * @param  TIM1_ICPolarity  The Input Polarity.
   2241            *         This parameter can be one of the following values:
   2242            *                       - TIM1_ICPOLARITY_FALLING
   2243            *                       - TIM1_ICPOLARITY_RISING
   2244            * @param  TIM1_ICSelection specifies the input to be used.
   2245            *         This parameter can be one of the following values:
   2246            *                       - TIM1_ICSELECTION_DIRECTTI: TIM1 Input 3 is selected to
   2247            *                         be connected to IC3.
   2248            *                       - TIM1_ICSELECTION_INDIRECTTI: TIM1 Input 3 is selected to
   2249            *                         be connected to IC4.
   2250            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2251            *         This parameter must be a value between 0x00 and 0x0F.
   2252            * @retval None
   2253            */

   \                                 In section .far_func.text, align 1
   2254          static void TI3_Config(uint8_t TIM1_ICPolarity,
   2255                                 uint8_t TIM1_ICSelection,
   2256                                 uint8_t TIM1_ICFilter)
   2257          {
   \                     TI3_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2258            /* Disable the Channel 3: Reset the CCE Bit */
   2259            TIM1->CCER2 &=  (uint8_t)(~TIM1_CCER2_CC3E);
   \   000002 7211 525D    BRES      L:0x525d, #0x0
   2260            
   2261            /* Select the Input and set the filter */
   2262            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~(uint8_t)( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF))) 
   2263                                    | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000006 B6 ..        LD        A, S:?b1
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 88           PUSH      A
   \   00000E C6 525A      LD        A, L:0x525a
   \   000011 A4 0C        AND       A, #0xc
   \   000013 B7 ..        LD        S:?b4, A
   \   000015 84           POP       A
   \   000016 BA ..        OR        A, S:?b4
   \   000018 C7 525A      LD        L:0x525a, A
   2264            
   2265            /* Select the Polarity */
   2266            if (TIM1_ICPolarity != TIM1_ICPOLARITY_RISING)
   \   00001B 3D ..        TNZ       S:?b2
   \   00001D 27 06        JREQ      L:??TI3_Config_0
   2267            {
   2268              TIM1->CCER2 |= TIM1_CCER2_CC3P;
   \   00001F 7212 525D    BSET      L:0x525d, #0x1
   \   000023 20 04        JRA       L:??TI3_Config_1
   2269            }
   2270            else
   2271            {
   2272              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3P);
   \                     ??TI3_Config_0:
   \   000025 7213 525D    BRES      L:0x525d, #0x1
   2273            }
   2274            /* Set the CCE Bit */
   2275            TIM1->CCER2 |=  TIM1_CCER2_CC3E;
   \                     ??TI3_Config_1:
   \   000029 7210 525D    BSET      L:0x525d, #0x0
   2276          }
   \   00002D 87           RETF
   2277          
   2278          /**
   2279            * @brief  Configure the TI4 as Input.
   2280            * @param  TIM1_ICPolarity  The Input Polarity.
   2281            *         This parameter can be one of the following values:
   2282            *                       - TIM1_ICPOLARITY_FALLING
   2283            *                       - TIM1_ICPOLARITY_RISING
   2284            * @param  TIM1_ICSelection specifies the input to be used.
   2285            *         This parameter can be one of the following values:
   2286            *                       - TIM1_ICSELECTION_DIRECTTI: TIM1 Input 4 is selected to
   2287            *                         be connected to IC4.
   2288            *                       - TIM1_ICSELECTION_INDIRECTTI: TIM1 Input 4 is selected to
   2289            *                         be connected to IC3.
   2290            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2291            *         This parameter must be a value between 0x00 and 0x0F.
   2292            * @retval None
   2293            */

   \                                 In section .far_func.text, align 1
   2294          static void TI4_Config(uint8_t TIM1_ICPolarity,
   2295                                 uint8_t TIM1_ICSelection,
   2296                                 uint8_t TIM1_ICFilter)
   2297          {
   \                     TI4_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2298            /* Disable the Channel 4: Reset the CCE Bit */
   2299            TIM1->CCER2 &=  (uint8_t)(~TIM1_CCER2_CC4E);
   \   000002 7219 525D    BRES      L:0x525d, #0x4
   2300            
   2301            /* Select the Input and set the filter */
   2302            TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~(uint8_t)( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF )))
   2303                                    | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000006 B6 ..        LD        A, S:?b1
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 88           PUSH      A
   \   00000E C6 525B      LD        A, L:0x525b
   \   000011 A4 0C        AND       A, #0xc
   \   000013 B7 ..        LD        S:?b4, A
   \   000015 84           POP       A
   \   000016 BA ..        OR        A, S:?b4
   \   000018 C7 525B      LD        L:0x525b, A
   2304            
   2305            /* Select the Polarity */
   2306            if (TIM1_ICPolarity != TIM1_ICPOLARITY_RISING)
   \   00001B 3D ..        TNZ       S:?b2
   \   00001D 27 06        JREQ      L:??TI4_Config_0
   2307            {
   2308              TIM1->CCER2 |= TIM1_CCER2_CC4P;
   \   00001F 721A 525D    BSET      L:0x525d, #0x5
   \   000023 20 04        JRA       L:??TI4_Config_1
   2309            }
   2310            else
   2311            {
   2312              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4P);
   \                     ??TI4_Config_0:
   \   000025 721B 525D    BRES      L:0x525d, #0x5
   2313            }
   2314            
   2315            /* Set the CCE Bit */
   2316            TIM1->CCER2 |=  TIM1_CCER2_CC4E;
   \                     ??TI4_Config_1:
   \   000029 7218 525D    BSET      L:0x525d, #0x4
   2317          }
   \   00002D 87           RETF

   \                                 In section .near.rodata, align 1
   \                     ?_0:
   \   000000 2E 5C 4C 69  DC8 ".\\Lib\\C\\stm8s_tim1.c"
   \          62 5C 43 5C 
   2318          
   2319          
   2320          /**
   2321            * @}
   2322            */
   2323            
   2324          /**
   2325            * @}
   2326            */
   2327            
   2328          
   2329          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      21  ?_0
      46  TI1_Config
      46  TI2_Config
      46  TI3_Config
      46  TI4_Config
      48  TIM1_ARRPreloadConfig
     190  TIM1_BDTRConfig
      48  TIM1_CCPreloadControl
     153  TIM1_CCxCmd
     125  TIM1_CCxNCmd
      56  TIM1_ClearFlag
      34  TIM1_ClearITPendingBit
      48  TIM1_Cmd
      62  TIM1_CounterModeConfig
      48  TIM1_CtrlPWMOutputs
     153  TIM1_DeInit
     104  TIM1_ETRClockMode1Config
     100  TIM1_ETRClockMode2Config
      55  TIM1_ETRConfig
     163  TIM1_EncoderInterfaceConfig
      46  TIM1_ForcedOC1Config
      46  TIM1_ForcedOC2Config
      46  TIM1_ForcedOC3Config
      46  TIM1_ForcedOC4Config
      33  TIM1_GenerateEvent
      42  TIM1_GetCapture1
      42  TIM1_GetCapture2
      42  TIM1_GetCapture3
      42  TIM1_GetCapture4
      27  TIM1_GetCounter
     152  TIM1_GetFlagStatus
     111  TIM1_GetITStatus
      27  TIM1_GetPrescaler
     275  TIM1_ICInit
      80  TIM1_ITConfig
       9  TIM1_InternalClockConfig
      48  TIM1_OC1FastConfig
     337  TIM1_OC1Init
      48  TIM1_OC1NPolarityConfig
      48  TIM1_OC1PolarityConfig
      48  TIM1_OC1PreloadConfig
      48  TIM1_OC2FastConfig
     337  TIM1_OC2Init
      48  TIM1_OC2NPolarityConfig
      48  TIM1_OC2PolarityConfig
      48  TIM1_OC2PreloadConfig
      48  TIM1_OC3FastConfig
     337  TIM1_OC3Init
      48  TIM1_OC3NPolarityConfig
      48  TIM1_OC3PolarityConfig
      48  TIM1_OC3PreloadConfig
      48  TIM1_OC4FastConfig
     215  TIM1_OC4Init
      48  TIM1_OC4PolarityConfig
      48  TIM1_OC4PreloadConfig
     266  TIM1_PWMIConfig
      59  TIM1_PrescalerConfig
      48  TIM1_SelectCOM
      48  TIM1_SelectHallSensor
      68  TIM1_SelectInputTrigger
      48  TIM1_SelectMasterSlaveMode
     189  TIM1_SelectOCxM
      48  TIM1_SelectOnePulseMode
      74  TIM1_SelectOutputTrigger
      58  TIM1_SelectSlaveMode
       9  TIM1_SetAutoreload
       9  TIM1_SetCompare1
       9  TIM1_SetCompare2
       9  TIM1_SetCompare3
       9  TIM1_SetCompare4
       9  TIM1_SetCounter
      56  TIM1_SetIC1Prescaler
      56  TIM1_SetIC2Prescaler
      56  TIM1_SetIC3Prescaler
      56  TIM1_SetIC4Prescaler
     149  TIM1_TIxExternalClockConfig
     100  TIM1_TimeBaseInit
      48  TIM1_UpdateDisableConfig
      48  TIM1_UpdateRequestConfig

 
 6 112 bytes in section .far_func.text
    21 bytes in section .near.rodata
 
 6 112 bytes of CODE  memory
    21 bytes of CONST memory

Errors: none
Warnings: none
