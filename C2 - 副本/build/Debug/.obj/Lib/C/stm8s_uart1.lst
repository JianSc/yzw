###############################################################################
#
# IAR C/C++ Compiler V3.11.1.207 for STM8                 28/Jan/2024  21:49:10
# Copyright 2010-2019 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for STMicroelectronics STM8
#
#    Source file  =  .\Lib\C\stm8s_uart1.c
#    Command line =  
#        -f
#        c:\Users\Administrator\Desktop\新建文件夹\C\build\Debug\.obj\Lib\C\stm8s_uart1.args.txt
#        (--silent -lCN .\build\Debug\.obj\Lib\C\stm8s_uart1.lst -I "d:/Program
#        Files (x86)/IAR Systems/STM8" -I "d:/Program Files (x86)/IAR
#        Systems/STM8/stm8/lib" -I Lib/H -I Lib/C -I User -D STM8S003
#        --data_model medium --code_model medium --dlib_config dlstm8smn.h -e
#        --vregs 16 -On --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_cross_call --debug --dependencies=m + -o
#        .\build\Debug\.obj\Lib\C\stm8s_uart1.o .\Lib\C\stm8s_uart1.c)
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  .\build\Debug\.obj\Lib\C\stm8s_uart1.lst
#    Object file  =  .\build\Debug\.obj\Lib\C\stm8s_uart1.o
#
###############################################################################

c:\Users\Administrator\Desktop\新建文件夹\C\Lib\C\stm8s_uart1.c
      1          /**
      2            ********************************************************************************
      3            * @file    stm8s_uart1.c
      4            * @author  MCD Application Team
      5            * @version V2.3.0
      6            * @date    16-June-2017
      7            * @brief   This file contains all the functions for the UART1 peripheral.
      8             ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "stm8s_uart1.h"
     30          
     31          /** @addtogroup STM8S_StdPeriph_Driver
     32            * @{
     33            */
     34          
     35          /* Private typedef -----------------------------------------------------------*/
     36          /* Private define ------------------------------------------------------------*/
     37          /* Private macro -------------------------------------------------------------*/
     38          /* Private variables ---------------------------------------------------------*/
     39          /* Private function prototypes -----------------------------------------------*/
     40          /* Private functions ---------------------------------------------------------*/
     41          /* Public functions ----------------------------------------------------------*/
     42          
     43          /**
     44            * @addtogroup UART1_Public_Functions
     45            * @{
     46            */
     47          
     48          /**
     49            * @brief  Deinitializes the UART peripheral.
     50            * @param  None
     51            * @retval None
     52          	*/

   \                                 In section .far_func.text, align 1
     53          void UART1_DeInit(void)
     54          {
     55            /* Clear the Idle Line Detected bit in the status register by a read
     56            to the UART1_SR register followed by a Read to the UART1_DR register */
     57            (void)UART1->SR;
   \                     UART1_DeInit:
   \   000000 55 5230 .... MOV       S:?b0, L:0x5230
     58            (void)UART1->DR;
   \   000005 C6 5231      LD        A, L:0x5231
     59            
     60            UART1->BRR2 = UART1_BRR2_RESET_VALUE;  /* Set UART1_BRR2 to reset value 0x00 */
   \   000008 725F 5233    CLR       L:0x5233
     61            UART1->BRR1 = UART1_BRR1_RESET_VALUE;  /* Set UART1_BRR1 to reset value 0x00 */
   \   00000C 725F 5232    CLR       L:0x5232
     62            
     63            UART1->CR1 = UART1_CR1_RESET_VALUE;  /* Set UART1_CR1 to reset value 0x00 */
   \   000010 725F 5234    CLR       L:0x5234
     64            UART1->CR2 = UART1_CR2_RESET_VALUE;  /* Set UART1_CR2 to reset value 0x00 */
   \   000014 725F 5235    CLR       L:0x5235
     65            UART1->CR3 = UART1_CR3_RESET_VALUE;  /* Set UART1_CR3 to reset value 0x00 */
   \   000018 725F 5236    CLR       L:0x5236
     66            UART1->CR4 = UART1_CR4_RESET_VALUE;  /* Set UART1_CR4 to reset value 0x00 */
   \   00001C 725F 5237    CLR       L:0x5237
     67            UART1->CR5 = UART1_CR5_RESET_VALUE;  /* Set UART1_CR5 to reset value 0x00 */
   \   000020 725F 5238    CLR       L:0x5238
     68            
     69            UART1->GTR = UART1_GTR_RESET_VALUE;
   \   000024 725F 5239    CLR       L:0x5239
     70            UART1->PSCR = UART1_PSCR_RESET_VALUE;
   \   000028 725F 523A    CLR       L:0x523a
     71          }
   \   00002C 87           RETF
     72          
     73          /**
     74            * @brief  Initializes the UART1 according to the specified parameters.
     75            * @note   Configure in Push Pull or Open Drain mode the Tx pin by setting the
     76            *         correct I/O Port register according the product package and line
     77            *         configuration
     78            * @param  BaudRate: The baudrate.
     79            * @param  WordLength : This parameter can be any of the 
     80            *         @ref UART1_WordLength_TypeDef enumeration.
     81            * @param  StopBits: This parameter can be any of the 
     82            *         @ref UART1_StopBits_TypeDef enumeration.
     83            * @param  Parity: This parameter can be any of the 
     84            *         @ref UART1_Parity_TypeDef enumeration.
     85            * @param  SyncMode: This parameter can be any of the 
     86            *         @ref UART1_SyncMode_TypeDef values.
     87            * @param  Mode: This parameter can be any of the @ref UART1_Mode_TypeDef values
     88            * @retval None
     89            */

   \                                 In section .far_func.text, align 1
     90          void UART1_Init(uint32_t BaudRate, UART1_WordLength_TypeDef WordLength, 
     91                          UART1_StopBits_TypeDef StopBits, UART1_Parity_TypeDef Parity, 
     92                          UART1_SyncMode_TypeDef SyncMode, UART1_Mode_TypeDef Mode)
     93          {
   \                     UART1_Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 3B ....      PUSH      S:?b6
   \   00000B 52 09        SUB       SP, #0x9
   \   00000D 8D ......    CALLF     L:?mov_l2_l0
   \   000011 B7 ..        LD        S:?b15, A
   \   000013 45 .. ..     MOV       S:?b13, S:?b4
   \   000016 45 .. ..     MOV       S:?b14, S:?b5
   \   000019 45 .. ..     MOV       S:?b12, S:?b7
     94            uint32_t BaudRate_Mantissa = 0, BaudRate_Mantissa100 = 0;
   \   00001C 5F           CLRW      X
   \   00001D 1F 01        LDW       (0x1,SP), X
   \   00001F 5F           CLRW      X
   \   000020 1F 03        LDW       (0x3,SP), X
   \   000022 5F           CLRW      X
   \   000023 1F 06        LDW       (0x6,SP), X
   \   000025 5F           CLRW      X
   \   000026 1F 08        LDW       (0x8,SP), X
     95            
     96            /* Check the parameters */
     97            assert_param(IS_UART1_BAUDRATE_OK(BaudRate));
   \   000028 BE ..        LDW       X, S:?w4
   \   00002A A3 0009      CPW       X, #0x9
   \   00002D 26 05        JRNE      L:??UART1_Init_0
   \   00002F BE ..        LDW       X, S:?w5
   \   000031 A3 8969      CPW       X, #0x8969
   \                     ??UART1_Init_0:
   \   000034 25 0F        JRC       L:??UART1_Init_1
   \   000036 AE 0061      LDW       X, #0x61
   \   000039 BF ..        LDW       S:?w1, X
   \   00003B 5F           CLRW      X
   \   00003C BF ..        LDW       S:?w0, X
   \   00003E AE ....      LDW       X, #?_0
   \   000041 8D ......    CALLF     assert_failed
     98            assert_param(IS_UART1_WORDLENGTH_OK(WordLength));
   \                     ??UART1_Init_1:
   \   000045 3D ..        TNZ       S:?b15
   \   000047 27 15        JREQ      L:??UART1_Init_2
   \   000049 B6 ..        LD        A, S:?b15
   \   00004B A1 10        CP        A, #0x10
   \   00004D 27 0F        JREQ      L:??UART1_Init_2
   \   00004F AE 0062      LDW       X, #0x62
   \   000052 BF ..        LDW       S:?w1, X
   \   000054 5F           CLRW      X
   \   000055 BF ..        LDW       S:?w0, X
   \   000057 AE ....      LDW       X, #?_0
   \   00005A 8D ......    CALLF     assert_failed
     99            assert_param(IS_UART1_STOPBITS_OK(StopBits));
   \                     ??UART1_Init_2:
   \   00005E 3D ..        TNZ       S:?b13
   \   000060 27 21        JREQ      L:??UART1_Init_3
   \   000062 B6 ..        LD        A, S:?b13
   \   000064 A1 10        CP        A, #0x10
   \   000066 27 1B        JREQ      L:??UART1_Init_3
   \   000068 B6 ..        LD        A, S:?b13
   \   00006A A1 20        CP        A, #0x20
   \   00006C 27 15        JREQ      L:??UART1_Init_3
   \   00006E B6 ..        LD        A, S:?b13
   \   000070 A1 30        CP        A, #0x30
   \   000072 27 0F        JREQ      L:??UART1_Init_3
   \   000074 AE 0063      LDW       X, #0x63
   \   000077 BF ..        LDW       S:?w1, X
   \   000079 5F           CLRW      X
   \   00007A BF ..        LDW       S:?w0, X
   \   00007C AE ....      LDW       X, #?_0
   \   00007F 8D ......    CALLF     assert_failed
    100            assert_param(IS_UART1_PARITY_OK(Parity));
   \                     ??UART1_Init_3:
   \   000083 3D ..        TNZ       S:?b14
   \   000085 27 1B        JREQ      L:??UART1_Init_4
   \   000087 B6 ..        LD        A, S:?b14
   \   000089 A1 04        CP        A, #0x4
   \   00008B 27 15        JREQ      L:??UART1_Init_4
   \   00008D B6 ..        LD        A, S:?b14
   \   00008F A1 06        CP        A, #0x6
   \   000091 27 0F        JREQ      L:??UART1_Init_4
   \   000093 AE 0064      LDW       X, #0x64
   \   000096 BF ..        LDW       S:?w1, X
   \   000098 5F           CLRW      X
   \   000099 BF ..        LDW       S:?w0, X
   \   00009B AE ....      LDW       X, #?_0
   \   00009E 8D ......    CALLF     assert_failed
    101            assert_param(IS_UART1_MODE_OK((uint8_t)Mode));
   \                     ??UART1_Init_4:
   \   0000A2 B6 ..        LD        A, S:?b12
   \   0000A4 A1 08        CP        A, #0x8
   \   0000A6 27 3F        JREQ      L:??UART1_Init_5
   \   0000A8 B6 ..        LD        A, S:?b12
   \   0000AA A1 40        CP        A, #0x40
   \   0000AC 27 39        JREQ      L:??UART1_Init_5
   \   0000AE B6 ..        LD        A, S:?b12
   \   0000B0 A1 04        CP        A, #0x4
   \   0000B2 27 33        JREQ      L:??UART1_Init_5
   \   0000B4 B6 ..        LD        A, S:?b12
   \   0000B6 A1 80        CP        A, #0x80
   \   0000B8 27 2D        JREQ      L:??UART1_Init_5
   \   0000BA B6 ..        LD        A, S:?b12
   \   0000BC A1 0C        CP        A, #0xc
   \   0000BE 27 27        JREQ      L:??UART1_Init_5
   \   0000C0 B6 ..        LD        A, S:?b12
   \   0000C2 A1 0C        CP        A, #0xc
   \   0000C4 27 21        JREQ      L:??UART1_Init_5
   \   0000C6 B6 ..        LD        A, S:?b12
   \   0000C8 A1 44        CP        A, #0x44
   \   0000CA 27 1B        JREQ      L:??UART1_Init_5
   \   0000CC B6 ..        LD        A, S:?b12
   \   0000CE A1 C0        CP        A, #0xc0
   \   0000D0 27 15        JREQ      L:??UART1_Init_5
   \   0000D2 B6 ..        LD        A, S:?b12
   \   0000D4 A1 88        CP        A, #0x88
   \   0000D6 27 0F        JREQ      L:??UART1_Init_5
   \   0000D8 AE 0065      LDW       X, #0x65
   \   0000DB BF ..        LDW       S:?w1, X
   \   0000DD 5F           CLRW      X
   \   0000DE BF ..        LDW       S:?w0, X
   \   0000E0 AE ....      LDW       X, #?_0
   \   0000E3 8D ......    CALLF     assert_failed
    102            assert_param(IS_UART1_SYNCMODE_OK((uint8_t)SyncMode));
   \                     ??UART1_Init_5:
   \   0000E7 7B 0A        LD        A, (0xa,SP)
   \   0000E9 A4 88        AND       A, #0x88
   \   0000EB A1 88        CP        A, #0x88
   \   0000ED 27 18        JREQ      L:??UART1_Init_6
   \   0000EF 7B 0A        LD        A, (0xa,SP)
   \   0000F1 A4 44        AND       A, #0x44
   \   0000F3 A1 44        CP        A, #0x44
   \   0000F5 27 10        JREQ      L:??UART1_Init_6
   \   0000F7 7B 0A        LD        A, (0xa,SP)
   \   0000F9 A4 22        AND       A, #0x22
   \   0000FB A1 22        CP        A, #0x22
   \   0000FD 27 08        JREQ      L:??UART1_Init_6
   \   0000FF 7B 0A        LD        A, (0xa,SP)
   \   000101 A4 11        AND       A, #0x11
   \   000103 A1 11        CP        A, #0x11
   \   000105 26 0F        JRNE      L:??UART1_Init_7
   \                     ??UART1_Init_6:
   \   000107 AE 0066      LDW       X, #0x66
   \   00010A BF ..        LDW       S:?w1, X
   \   00010C 5F           CLRW      X
   \   00010D BF ..        LDW       S:?w0, X
   \   00010F AE ....      LDW       X, #?_0
   \   000112 8D ......    CALLF     assert_failed
    103            
    104            /* Clear the word length bit */
    105            UART1->CR1 &= (uint8_t)(~UART1_CR1_M);  
   \                     ??UART1_Init_7:
   \   000116 7219 5234    BRES      L:0x5234, #0x4
    106            
    107            /* Set the word length bit according to UART1_WordLength value */
    108            UART1->CR1 |= (uint8_t)WordLength;
   \   00011A C6 5234      LD        A, L:0x5234
   \   00011D BA ..        OR        A, S:?b15
   \   00011F C7 5234      LD        L:0x5234, A
    109            
    110            /* Clear the STOP bits */
    111            UART1->CR3 &= (uint8_t)(~UART1_CR3_STOP);  
   \   000122 C6 5236      LD        A, L:0x5236
   \   000125 A4 CF        AND       A, #0xcf
   \   000127 C7 5236      LD        L:0x5236, A
    112            /* Set the STOP bits number according to UART1_StopBits value  */
    113            UART1->CR3 |= (uint8_t)StopBits;  
   \   00012A C6 5236      LD        A, L:0x5236
   \   00012D BA ..        OR        A, S:?b13
   \   00012F C7 5236      LD        L:0x5236, A
    114            
    115            /* Clear the Parity Control bit */
    116            UART1->CR1 &= (uint8_t)(~(UART1_CR1_PCEN | UART1_CR1_PS  ));  
   \   000132 C6 5234      LD        A, L:0x5234
   \   000135 A4 F9        AND       A, #0xf9
   \   000137 C7 5234      LD        L:0x5234, A
    117            /* Set the Parity Control bit to UART1_Parity value */
    118            UART1->CR1 |= (uint8_t)Parity;  
   \   00013A C6 5234      LD        A, L:0x5234
   \   00013D BA ..        OR        A, S:?b14
   \   00013F C7 5234      LD        L:0x5234, A
    119            
    120            /* Clear the LSB mantissa of UART1DIV  */
    121            UART1->BRR1 &= (uint8_t)(~UART1_BRR1_DIVM);  
   \   000142 C6 5232      LD        A, L:0x5232
   \   000145 6B 05        LD        (0x5,SP), A
   \   000147 725F 5232    CLR       L:0x5232
    122            /* Clear the MSB mantissa of UART1DIV  */
    123            UART1->BRR2 &= (uint8_t)(~UART1_BRR2_DIVM);  
   \   00014B C6 5233      LD        A, L:0x5233
   \   00014E A4 0F        AND       A, #0xf
   \   000150 C7 5233      LD        L:0x5233, A
    124            /* Clear the Fraction bits of UART1DIV */
    125            UART1->BRR2 &= (uint8_t)(~UART1_BRR2_DIVF);  
   \   000153 C6 5233      LD        A, L:0x5233
   \   000156 A4 F0        AND       A, #0xf0
   \   000158 C7 5233      LD        L:0x5233, A
    126            
    127            /* Set the UART1 BaudRates in BRR1 and BRR2 registers according to UART1_BaudRate value */
    128            BaudRate_Mantissa    = ((uint32_t)CLK_GetClockFreq() / (BaudRate << 4));
   \   00015B 8D ......    CALLF     L:?mov_l0_l2
   \   00015F A6 04        LD        A, #0x4
   \   000161 8D ......    CALLF     L:?sll32_l0_l0_a
   \   000165 8D ......    CALLF     L:?push_l0
   \   000169 8D ......    CALLF     CLK_GetClockFreq
   \   00016D 8D ......    CALLF     L:?pop_l1
   \   000171 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   000175 AE 0001      LDW       X, #0x1
   \   000178 8D ......    CALLF     L:?load32_xsp_l0
    129            BaudRate_Mantissa100 = (((uint32_t)CLK_GetClockFreq() * 100) / (BaudRate << 4));
   \   00017C 8D ......    CALLF     L:?mov_l0_l2
   \   000180 A6 04        LD        A, #0x4
   \   000182 8D ......    CALLF     L:?sll32_l0_l0_a
   \   000186 8D ......    CALLF     L:?push_l0
   \   00018A 8D ......    CALLF     CLK_GetClockFreq
   \   00018E AE 0064      LDW       X, #0x64
   \   000191 BF ..        LDW       S:?w3, X
   \   000193 5F           CLRW      X
   \   000194 BF ..        LDW       S:?w2, X
   \   000196 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   00019A 8D ......    CALLF     L:?pop_l1
   \   00019E 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   0001A2 AE 0006      LDW       X, #0x6
   \   0001A5 8D ......    CALLF     L:?load32_xsp_l0
    130            /* Set the fraction of UART1DIV  */
    131            UART1->BRR2 |= (uint8_t)((uint8_t)(((BaudRate_Mantissa100 - (BaudRate_Mantissa * 100)) << 4) / 100) & (uint8_t)0x0F); 
   \   0001A9 AE 0064      LDW       X, #0x64
   \   0001AC BF ..        LDW       S:?w3, X
   \   0001AE 5F           CLRW      X
   \   0001AF BF ..        LDW       S:?w2, X
   \   0001B1 8D ......    CALLF     L:?load32_l0_dbsp
   \   0001B5 01           DC8       0x1
   \   0001B6 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   0001BA 8D ......    CALLF     L:?mov_l1_l0
   \   0001BE 8D ......    CALLF     L:?load32_l0_dbsp
   \   0001C2 06           DC8       0x6
   \   0001C3 8D ......    CALLF     L:?sub32_l0_l0_l1
   \   0001C7 A6 04        LD        A, #0x4
   \   0001C9 8D ......    CALLF     L:?sll32_l0_l0_a
   \   0001CD 8D ......    CALLF     L:?udiv32_l0_l0_dl
   \   0001D1 00000064     DC32      0x64
   \   0001D5 B6 ..        LD        A, S:?b3
   \   0001D7 A4 0F        AND       A, #0xf
   \   0001D9 CA 5233      OR        A, L:0x5233
   \   0001DC C7 5233      LD        L:0x5233, A
    132            /* Set the MSB mantissa of UART1DIV  */
    133            UART1->BRR2 |= (uint8_t)((BaudRate_Mantissa >> 4) & (uint8_t)0xF0); 
   \   0001DF 1E 03        LDW       X, (0x3,SP)
   \   0001E1 54           SRLW      X
   \   0001E2 54           SRLW      X
   \   0001E3 54           SRLW      X
   \   0001E4 54           SRLW      X
   \   0001E5 9F           LD        A, XL
   \   0001E6 A4 F0        AND       A, #0xf0
   \   0001E8 CA 5233      OR        A, L:0x5233
   \   0001EB C7 5233      LD        L:0x5233, A
    134            /* Set the LSB mantissa of UART1DIV  */
    135            UART1->BRR1 |= (uint8_t)BaudRate_Mantissa;           
   \   0001EE 1E 03        LDW       X, (0x3,SP)
   \   0001F0 9F           LD        A, XL
   \   0001F1 CA 5232      OR        A, L:0x5232
   \   0001F4 C7 5232      LD        L:0x5232, A
    136            
    137            /* Disable the Transmitter and Receiver before setting the LBCL, CPOL and CPHA bits */
    138            UART1->CR2 &= (uint8_t)~(UART1_CR2_TEN | UART1_CR2_REN); 
   \   0001F7 C6 5235      LD        A, L:0x5235
   \   0001FA A4 F3        AND       A, #0xf3
   \   0001FC C7 5235      LD        L:0x5235, A
    139            /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
    140            UART1->CR3 &= (uint8_t)~(UART1_CR3_CPOL | UART1_CR3_CPHA | UART1_CR3_LBCL); 
   \   0001FF C6 5236      LD        A, L:0x5236
   \   000202 A4 F8        AND       A, #0xf8
   \   000204 C7 5236      LD        L:0x5236, A
    141            /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
    142            UART1->CR3 |= (uint8_t)((uint8_t)SyncMode & (uint8_t)(UART1_CR3_CPOL | 
    143                                                                  UART1_CR3_CPHA | UART1_CR3_LBCL));  
   \   000207 7B 0A        LD        A, (0xa,SP)
   \   000209 A4 07        AND       A, #0x7
   \   00020B CA 5236      OR        A, L:0x5236
   \   00020E C7 5236      LD        L:0x5236, A
    144            
    145            if ((uint8_t)(Mode & UART1_MODE_TX_ENABLE))
   \   000211 B6 ..        LD        A, S:?b12
   \   000213 A4 04        AND       A, #0x4
   \   000215 A1 00        CP        A, #0x0
   \   000217 27 06        JREQ      L:??UART1_Init_8
    146            {
    147              /* Set the Transmitter Enable bit */
    148              UART1->CR2 |= (uint8_t)UART1_CR2_TEN;  
   \   000219 7216 5235    BSET      L:0x5235, #0x3
   \   00021D 20 04        JRA       L:??UART1_Init_9
    149            }
    150            else
    151            {
    152              /* Clear the Transmitter Disable bit */
    153              UART1->CR2 &= (uint8_t)(~UART1_CR2_TEN);  
   \                     ??UART1_Init_8:
   \   00021F 7217 5235    BRES      L:0x5235, #0x3
    154            }
    155            if ((uint8_t)(Mode & UART1_MODE_RX_ENABLE))
   \                     ??UART1_Init_9:
   \   000223 B6 ..        LD        A, S:?b12
   \   000225 A4 08        AND       A, #0x8
   \   000227 A1 00        CP        A, #0x0
   \   000229 27 06        JREQ      L:??UART1_Init_10
    156            {
    157              /* Set the Receiver Enable bit */
    158              UART1->CR2 |= (uint8_t)UART1_CR2_REN;  
   \   00022B 7214 5235    BSET      L:0x5235, #0x2
   \   00022F 20 04        JRA       L:??UART1_Init_11
    159            }
    160            else
    161            {
    162              /* Clear the Receiver Disable bit */
    163              UART1->CR2 &= (uint8_t)(~UART1_CR2_REN);  
   \                     ??UART1_Init_10:
   \   000231 7215 5235    BRES      L:0x5235, #0x2
    164            }
    165            /* Set the Clock Enable bit, lock Polarity, lock Phase and Last Bit Clock 
    166            pulse bits according to UART1_Mode value */
    167            if ((uint8_t)(SyncMode & UART1_SYNCMODE_CLOCK_DISABLE))
   \                     ??UART1_Init_11:
   \   000235 7B 0A        LD        A, (0xa,SP)
   \   000237 A4 80        AND       A, #0x80
   \   000239 A1 00        CP        A, #0x0
   \   00023B 27 06        JREQ      L:??UART1_Init_12
    168            {
    169              /* Clear the Clock Enable bit */
    170              UART1->CR3 &= (uint8_t)(~UART1_CR3_CKEN); 
   \   00023D 7217 5236    BRES      L:0x5236, #0x3
   \   000241 20 0A        JRA       L:??UART1_Init_13
    171            }
    172            else
    173            {
    174              UART1->CR3 |= (uint8_t)((uint8_t)SyncMode & UART1_CR3_CKEN);
   \                     ??UART1_Init_12:
   \   000243 7B 0A        LD        A, (0xa,SP)
   \   000245 A4 08        AND       A, #0x8
   \   000247 CA 5236      OR        A, L:0x5236
   \   00024A C7 5236      LD        L:0x5236, A
    175            }
    176          }
   \                     ??UART1_Init_13:
   \   00024D 5B 0A        ADD       SP, #0xa
   \   00024F AC ......    JPF       L:?epilogue_l2_l3
    177          
    178          /**
    179            * @brief  Enable the UART1 peripheral.
    180            * @param  NewState : The new state of the UART Communication.
    181            *         This parameter can be any of the @ref FunctionalState enumeration.
    182            * @retval None
    183            */

   \                                 In section .far_func.text, align 1
    184          void UART1_Cmd(FunctionalState NewState)
    185          {
    186            if (NewState != DISABLE)
   \                     UART1_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 06        JREQ      L:??UART1_Cmd_0
    187            {
    188              /* UART1 Enable */
    189              UART1->CR1 &= (uint8_t)(~UART1_CR1_UARTD); 
   \   000003 721B 5234    BRES      L:0x5234, #0x5
   \   000007 20 04        JRA       L:??UART1_Cmd_1
    190            }
    191            else
    192            {
    193              /* UART Disable */
    194              UART1->CR1 |= UART1_CR1_UARTD;  
   \                     ??UART1_Cmd_0:
   \   000009 721A 5234    BSET      L:0x5234, #0x5
    195            }
    196          }
   \                     ??UART1_Cmd_1:
   \   00000D 87           RETF
    197          
    198          /**
    199            * @brief  Enables or disables the specified USART interrupts.
    200            * @param  UART1_IT specifies the USART interrupt sources to be enabled or disabled.
    201            *         This parameter can be one of the following values:
    202            *         - UART1_IT_TXE:  Transmit Data Register empty interrupt
    203            *         - UART1_IT_TC:   Transmission complete interrupt
    204            *         - UART1_IT_RXNE_OR: Receive Data register not empty and Overrun interrupt
    205            *         - UART1_IT_IDLE: Idle line detection interrupt
    206            *         - USRT1_IT_ERR:  Error interrupt
    207            * @param  NewState new state of the specified USART interrupts.
    208            *         This parameter can be: ENABLE or DISABLE.
    209            * @retval None
    210            */

   \                                 In section .far_func.text, align 1
    211          void UART1_ITConfig(UART1_IT_TypeDef UART1_IT, FunctionalState NewState)
    212          {
   \                     UART1_ITConfig:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 3B ....      PUSH      S:?b12
   \   000007 BF ..        LDW       S:?w4, X
   \   000009 B7 ..        LD        S:?b10, A
    213            uint8_t uartreg = 0, itpos = 0x00;
   \   00000B 3F ..        CLR       S:?b11
   \   00000D 3F ..        CLR       S:?b12
    214            
    215            /* Check the parameters */
    216            assert_param(IS_UART1_CONFIG_IT_OK(UART1_IT));
   \   00000F BE ..        LDW       X, S:?w4
   \   000011 A3 0100      CPW       X, #0x100
   \   000014 27 32        JREQ      L:??UART1_ITConfig_0
   \   000016 BE ..        LDW       X, S:?w4
   \   000018 A3 0277      CPW       X, #0x277
   \   00001B 27 2B        JREQ      L:??UART1_ITConfig_0
   \   00001D BE ..        LDW       X, S:?w4
   \   00001F A3 0266      CPW       X, #0x266
   \   000022 27 24        JREQ      L:??UART1_ITConfig_0
   \   000024 BE ..        LDW       X, S:?w4
   \   000026 A3 0205      CPW       X, #0x205
   \   000029 27 1D        JREQ      L:??UART1_ITConfig_0
   \   00002B BE ..        LDW       X, S:?w4
   \   00002D A3 0244      CPW       X, #0x244
   \   000030 27 16        JREQ      L:??UART1_ITConfig_0
   \   000032 BE ..        LDW       X, S:?w4
   \   000034 A3 0346      CPW       X, #0x346
   \   000037 27 0F        JREQ      L:??UART1_ITConfig_0
   \   000039 AE 00D8      LDW       X, #0xd8
   \   00003C BF ..        LDW       S:?w1, X
   \   00003E 5F           CLRW      X
   \   00003F BF ..        LDW       S:?w0, X
   \   000041 AE ....      LDW       X, #?_0
   \   000044 8D ......    CALLF     assert_failed
    217            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??UART1_ITConfig_0:
   \   000048 3D ..        TNZ       S:?b10
   \   00004A 27 15        JREQ      L:??UART1_ITConfig_1
   \   00004C B6 ..        LD        A, S:?b10
   \   00004E A1 01        CP        A, #0x1
   \   000050 27 0F        JREQ      L:??UART1_ITConfig_1
   \   000052 AE 00D9      LDW       X, #0xd9
   \   000055 BF ..        LDW       S:?w1, X
   \   000057 5F           CLRW      X
   \   000058 BF ..        LDW       S:?w0, X
   \   00005A AE ....      LDW       X, #?_0
   \   00005D 8D ......    CALLF     assert_failed
    218            
    219            /* Get the UART1 register index */
    220            uartreg = (uint8_t)((uint16_t)UART1_IT >> 0x08);
   \                     ??UART1_ITConfig_1:
   \   000061 45 .. ..     MOV       S:?b11, S:?b8
    221            /* Get the UART1 IT index */
    222            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART1_IT & (uint8_t)0x0F));
   \   000064 B6 ..        LD        A, S:?b9
   \   000066 A4 0F        AND       A, #0xf
   \   000068 5F           CLRW      X
   \   000069 5C           INCW      X
   \   00006A 8D ......    CALLF     L:?sll16_x_x_a
   \   00006E 9F           LD        A, XL
   \   00006F B7 ..        LD        S:?b12, A
    223            
    224            if (NewState != DISABLE)
   \   000071 3D ..        TNZ       S:?b10
   \   000073 27 2A        JREQ      L:??UART1_ITConfig_2
    225            {
    226              /**< Enable the Interrupt bits according to UART1_IT mask */
    227              if (uartreg == 0x01)
   \   000075 B6 ..        LD        A, S:?b11
   \   000077 A1 01        CP        A, #0x1
   \   000079 26 0A        JRNE      L:??UART1_ITConfig_3
    228              {
    229                UART1->CR1 |= itpos;
   \   00007B C6 5234      LD        A, L:0x5234
   \   00007E BA ..        OR        A, S:?b12
   \   000080 C7 5234      LD        L:0x5234, A
   \   000083 20 45        JRA       L:??UART1_ITConfig_4
    230              }
    231              else if (uartreg == 0x02)
   \                     ??UART1_ITConfig_3:
   \   000085 B6 ..        LD        A, S:?b11
   \   000087 A1 02        CP        A, #0x2
   \   000089 26 0A        JRNE      L:??UART1_ITConfig_5
    232              {
    233                UART1->CR2 |= itpos;
   \   00008B C6 5235      LD        A, L:0x5235
   \   00008E BA ..        OR        A, S:?b12
   \   000090 C7 5235      LD        L:0x5235, A
   \   000093 20 35        JRA       L:??UART1_ITConfig_4
    234              }
    235              else
    236              {
    237                UART1->CR4 |= itpos;
   \                     ??UART1_ITConfig_5:
   \   000095 C6 5237      LD        A, L:0x5237
   \   000098 BA ..        OR        A, S:?b12
   \   00009A C7 5237      LD        L:0x5237, A
   \   00009D 20 2B        JRA       L:??UART1_ITConfig_4
    238              }
    239            }
    240            else
    241            {
    242              /**< Disable the interrupt bits according to UART1_IT mask */
    243              if (uartreg == 0x01)
   \                     ??UART1_ITConfig_2:
   \   00009F B6 ..        LD        A, S:?b11
   \   0000A1 A1 01        CP        A, #0x1
   \   0000A3 26 0B        JRNE      L:??UART1_ITConfig_6
    244              {
    245                UART1->CR1 &= (uint8_t)(~itpos);
   \   0000A5 B6 ..        LD        A, S:?b12
   \   0000A7 43           CPL       A
   \   0000A8 C4 5234      AND       A, L:0x5234
   \   0000AB C7 5234      LD        L:0x5234, A
   \   0000AE 20 1A        JRA       L:??UART1_ITConfig_4
    246              }
    247              else if (uartreg == 0x02)
   \                     ??UART1_ITConfig_6:
   \   0000B0 B6 ..        LD        A, S:?b11
   \   0000B2 A1 02        CP        A, #0x2
   \   0000B4 26 0B        JRNE      L:??UART1_ITConfig_7
    248              {
    249                UART1->CR2 &= (uint8_t)(~itpos);
   \   0000B6 B6 ..        LD        A, S:?b12
   \   0000B8 43           CPL       A
   \   0000B9 C4 5235      AND       A, L:0x5235
   \   0000BC C7 5235      LD        L:0x5235, A
   \   0000BF 20 09        JRA       L:??UART1_ITConfig_4
    250              }
    251              else
    252              {
    253                UART1->CR4 &= (uint8_t)(~itpos);
   \                     ??UART1_ITConfig_7:
   \   0000C1 B6 ..        LD        A, S:?b12
   \   0000C3 43           CPL       A
   \   0000C4 C4 5237      AND       A, L:0x5237
   \   0000C7 C7 5237      LD        L:0x5237, A
    254              }
    255            }
    256            
    257          }
   \                     ??UART1_ITConfig_4:
   \   0000CA 32 ....      POP       S:?b12
   \   0000CD AC ......    JPF       L:?epilogue_l2
    258          
    259          /**
    260            * @brief  Enables or disables the UARTs Half Duplex communication.
    261            * @param  NewState new state of the UART Communication.
    262            *         This parameter can be: ENABLE or DISABLE.
    263            * @retval None
    264            */

   \                                 In section .far_func.text, align 1
    265          void UART1_HalfDuplexCmd(FunctionalState NewState)
    266          {
   \                     UART1_HalfDuplexCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    267            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??UART1_HalfDuplexCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??UART1_HalfDuplexCmd_0
   \   00000F AE 010B      LDW       X, #0x10b
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    268            
    269            if (NewState != DISABLE)
   \                     ??UART1_HalfDuplexCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??UART1_HalfDuplexCmd_1
    270            {
    271              UART1->CR5 |= UART1_CR5_HDSEL;  /**< UART1 Half Duplex Enable  */
   \   000022 7216 5238    BSET      L:0x5238, #0x3
   \   000026 20 04        JRA       L:??UART1_HalfDuplexCmd_2
    272            }
    273            else
    274            {
    275              UART1->CR5 &= (uint8_t)~UART1_CR5_HDSEL; /**< UART1 Half Duplex Disable */
   \                     ??UART1_HalfDuplexCmd_1:
   \   000028 7217 5238    BRES      L:0x5238, #0x3
    276            }
    277          }
   \                     ??UART1_HalfDuplexCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    278          
    279          /**
    280            * @brief  Configures the UARTs IrDA interface.
    281            * @param  UART1_IrDAMode specifies the IrDA mode.
    282            *         This parameter can be any of the @ref UART1_IrDAMode_TypeDef values.
    283            * @retval None
    284            */

   \                                 In section .far_func.text, align 1
    285          void UART1_IrDAConfig(UART1_IrDAMode_TypeDef UART1_IrDAMode)
    286          {
   \                     UART1_IrDAConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    287            assert_param(IS_UART1_IRDAMODE_OK(UART1_IrDAMode));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 01        CP        A, #0x1
   \   000009 27 13        JREQ      L:??UART1_IrDAConfig_0
   \   00000B 3D ..        TNZ       S:?b8
   \   00000D 27 0F        JREQ      L:??UART1_IrDAConfig_0
   \   00000F AE 011F      LDW       X, #0x11f
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    288            
    289            if (UART1_IrDAMode != UART1_IRDAMODE_NORMAL)
   \                     ??UART1_IrDAConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??UART1_IrDAConfig_1
    290            {
    291              UART1->CR5 |= UART1_CR5_IRLP;
   \   000022 7214 5238    BSET      L:0x5238, #0x2
   \   000026 20 04        JRA       L:??UART1_IrDAConfig_2
    292            }
    293            else
    294            {
    295              UART1->CR5 &= ((uint8_t)~UART1_CR5_IRLP);
   \                     ??UART1_IrDAConfig_1:
   \   000028 7215 5238    BRES      L:0x5238, #0x2
    296            }
    297          }
   \                     ??UART1_IrDAConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    298          
    299          /**
    300            * @brief  Enables or disables the UARTs IrDA interface.
    301            * @param  NewState new state of the IrDA mode.
    302            *         This parameter can be: ENABLE or DISABLE.
    303            * @retval None
    304            */

   \                                 In section .far_func.text, align 1
    305          void UART1_IrDACmd(FunctionalState NewState)
    306          {
   \                     UART1_IrDACmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    307            /* Check parameters */
    308            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??UART1_IrDACmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??UART1_IrDACmd_0
   \   00000F AE 0134      LDW       X, #0x134
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    309            
    310            if (NewState != DISABLE)
   \                     ??UART1_IrDACmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??UART1_IrDACmd_1
    311            {
    312              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    313              UART1->CR5 |= UART1_CR5_IREN;
   \   000022 7212 5238    BSET      L:0x5238, #0x1
   \   000026 20 04        JRA       L:??UART1_IrDACmd_2
    314            }
    315            else
    316            {
    317              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    318              UART1->CR5 &= ((uint8_t)~UART1_CR5_IREN);
   \                     ??UART1_IrDACmd_1:
   \   000028 7213 5238    BRES      L:0x5238, #0x1
    319            }
    320          }
   \                     ??UART1_IrDACmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    321          
    322          /**
    323            * @brief  Sets the UART1 LIN Break detection length.
    324            * @param  UART1_LINBreakDetectionLength specifies the LIN break detection length.
    325            *         This parameter can be any of the
    326            *         @ref UART1_LINBreakDetectionLength_TypeDef values.
    327            * @retval None
    328            */

   \                                 In section .far_func.text, align 1
    329          void UART1_LINBreakDetectionConfig(UART1_LINBreakDetectionLength_TypeDef UART1_LINBreakDetectionLength)
    330          {
   \                     UART1_LINBreakDetectionConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    331            assert_param(IS_UART1_LINBREAKDETECTIONLENGTH_OK(UART1_LINBreakDetectionLength));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??UART1_LINBreakDetectionConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??UART1_LINBreakDetectionConfig_0
   \   00000F AE 014B      LDW       X, #0x14b
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    332            
    333            if (UART1_LINBreakDetectionLength != UART1_LINBREAKDETECTIONLENGTH_10BITS)
   \                     ??UART1_LINBreakDetectionConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??UART1_LINBreakDetectionConfig_1
    334            {
    335              UART1->CR4 |= UART1_CR4_LBDL;
   \   000022 721A 5237    BSET      L:0x5237, #0x5
   \   000026 20 04        JRA       L:??UART1_LINBreakDetectionConfig_2
    336            }
    337            else
    338            {
    339              UART1->CR4 &= ((uint8_t)~UART1_CR4_LBDL);
   \                     ??UART1_LINBreakDetectionConfig_1:
   \   000028 721B 5237    BRES      L:0x5237, #0x5
    340            }
    341          }
   \                     ??UART1_LINBreakDetectionConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    342          
    343          /**
    344            * @brief  Enables or disables the UART1s LIN mode.
    345            * @param  NewState is new state of the UART1 LIN mode.
    346            *         This parameter can be: ENABLE or DISABLE.
    347            * @retval None
    348            */

   \                                 In section .far_func.text, align 1
    349          void UART1_LINCmd(FunctionalState NewState)
    350          {
   \                     UART1_LINCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    351            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??UART1_LINCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??UART1_LINCmd_0
   \   00000F AE 015F      LDW       X, #0x15f
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    352            
    353            if (NewState != DISABLE)
   \                     ??UART1_LINCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??UART1_LINCmd_1
    354            {
    355              /* Enable the LIN mode by setting the LINE bit in the CR2 register */
    356              UART1->CR3 |= UART1_CR3_LINEN;
   \   000022 721C 5236    BSET      L:0x5236, #0x6
   \   000026 20 04        JRA       L:??UART1_LINCmd_2
    357            }
    358            else
    359            {
    360              /* Disable the LIN mode by clearing the LINE bit in the CR2 register */
    361              UART1->CR3 &= ((uint8_t)~UART1_CR3_LINEN);
   \                     ??UART1_LINCmd_1:
   \   000028 721D 5236    BRES      L:0x5236, #0x6
    362            }
    363          }
   \                     ??UART1_LINCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    364          
    365          /**
    366            * @brief  Enables or disables the UART1 Smart Card mode.
    367            * @param  NewState: new state of the Smart Card mode.
    368            * This parameter can be: ENABLE or DISABLE.
    369            * @retval None
    370            */

   \                                 In section .far_func.text, align 1
    371          void UART1_SmartCardCmd(FunctionalState NewState)
    372          {
   \                     UART1_SmartCardCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    373            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??UART1_SmartCardCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??UART1_SmartCardCmd_0
   \   00000F AE 0175      LDW       X, #0x175
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    374            
    375            if (NewState != DISABLE)
   \                     ??UART1_SmartCardCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??UART1_SmartCardCmd_1
    376            {
    377              /* Enable the SC mode by setting the SCEN bit in the CR5 register */
    378              UART1->CR5 |= UART1_CR5_SCEN;
   \   000022 721A 5238    BSET      L:0x5238, #0x5
   \   000026 20 04        JRA       L:??UART1_SmartCardCmd_2
    379            }
    380            else
    381            {
    382              /* Disable the SC mode by clearing the SCEN bit in the CR5 register */
    383              UART1->CR5 &= ((uint8_t)(~UART1_CR5_SCEN));
   \                     ??UART1_SmartCardCmd_1:
   \   000028 721B 5238    BRES      L:0x5238, #0x5
    384            }
    385          }
   \                     ??UART1_SmartCardCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    386          
    387          /**
    388            * @brief  Enables or disables NACK transmission.
    389            * @note   This function is valid only for UART1 because is related to SmartCard mode.
    390            * @param  NewState: new state of the Smart Card mode.
    391            *         This parameter can be: ENABLE or DISABLE.
    392            * @retval None
    393            */

   \                                 In section .far_func.text, align 1
    394          void UART1_SmartCardNACKCmd(FunctionalState NewState)
    395          {
   \                     UART1_SmartCardNACKCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    396            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??UART1_SmartCardNACKCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??UART1_SmartCardNACKCmd_0
   \   00000F AE 018C      LDW       X, #0x18c
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    397            
    398            if (NewState != DISABLE)
   \                     ??UART1_SmartCardNACKCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??UART1_SmartCardNACKCmd_1
    399            {
    400              /* Enable the NACK transmission by setting the NACK bit in the CR5 register */
    401              UART1->CR5 |= UART1_CR5_NACK;
   \   000022 7218 5238    BSET      L:0x5238, #0x4
   \   000026 20 04        JRA       L:??UART1_SmartCardNACKCmd_2
    402            }
    403            else
    404            {
    405              /* Disable the NACK transmission by clearing the NACK bit in the CR5 register */
    406              UART1->CR5 &= ((uint8_t)~(UART1_CR5_NACK));
   \                     ??UART1_SmartCardNACKCmd_1:
   \   000028 7219 5238    BRES      L:0x5238, #0x4
    407            }
    408          }
   \                     ??UART1_SmartCardNACKCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    409          
    410          /**
    411            * @brief  Selects the UART1 WakeUp method.
    412            * @param  UART1_WakeUp: specifies the UART1 wakeup method.
    413            *         This parameter can be any of the @ref UART1_WakeUp_TypeDef values.
    414            * @retval None
    415            */

   \                                 In section .far_func.text, align 1
    416          void UART1_WakeUpConfig(UART1_WakeUp_TypeDef UART1_WakeUp)
    417          {
   \                     UART1_WakeUpConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    418            assert_param(IS_UART1_WAKEUP_OK(UART1_WakeUp));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??UART1_WakeUpConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 08        CP        A, #0x8
   \   00000D 27 0F        JREQ      L:??UART1_WakeUpConfig_0
   \   00000F AE 01A2      LDW       X, #0x1a2
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    419            
    420            UART1->CR1 &= ((uint8_t)~UART1_CR1_WAKE);
   \                     ??UART1_WakeUpConfig_0:
   \   00001E 7217 5234    BRES      L:0x5234, #0x3
    421            UART1->CR1 |= (uint8_t)UART1_WakeUp;
   \   000022 C6 5234      LD        A, L:0x5234
   \   000025 BA ..        OR        A, S:?b8
   \   000027 C7 5234      LD        L:0x5234, A
    422          }
   \   00002A 32 ....      POP       S:?b8
   \   00002D 87           RETF
    423          
    424          /**
    425            * @brief  Determines if the UART1 is in mute mode or not.
    426            * @param  NewState: new state of the UART1 mode.
    427            *         This parameter can be: ENABLE or DISABLE.
    428            * @retval None
    429            */

   \                                 In section .far_func.text, align 1
    430          void UART1_ReceiverWakeUpCmd(FunctionalState NewState)
    431          {
   \                     UART1_ReceiverWakeUpCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    432            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??UART1_ReceiverWakeUpCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??UART1_ReceiverWakeUpCmd_0
   \   00000F AE 01B0      LDW       X, #0x1b0
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    433            
    434            if (NewState != DISABLE)
   \                     ??UART1_ReceiverWakeUpCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??UART1_ReceiverWakeUpCmd_1
    435            {
    436              /* Enable the mute mode UART1 by setting the RWU bit in the CR2 register */
    437              UART1->CR2 |= UART1_CR2_RWU;
   \   000022 7212 5235    BSET      L:0x5235, #0x1
   \   000026 20 04        JRA       L:??UART1_ReceiverWakeUpCmd_2
    438            }
    439            else
    440            {
    441              /* Disable the mute mode UART1 by clearing the RWU bit in the CR1 register */
    442              UART1->CR2 &= ((uint8_t)~UART1_CR2_RWU);
   \                     ??UART1_ReceiverWakeUpCmd_1:
   \   000028 7213 5235    BRES      L:0x5235, #0x1
    443            }
    444          }
   \                     ??UART1_ReceiverWakeUpCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    445          
    446          /**
    447            * @brief  Returns the most recent received data by the UART1 peripheral.
    448            * @param  None
    449            * @retval The received data.
    450            */

   \                                 In section .far_func.text, align 1
    451          uint8_t UART1_ReceiveData8(void)
    452          {
    453            return ((uint8_t)UART1->DR);
   \                     UART1_ReceiveData8:
   \   000000 C6 5231      LD        A, L:0x5231
   \   000003 87           RETF
    454          }
    455          
    456          /**
    457            * @brief  Returns the most recent received data by the UART1 peripheral.
    458            * @param  None
    459            * @retval The received data.
    460            */

   \                                 In section .far_func.text, align 1
    461          uint16_t UART1_ReceiveData9(void)
    462          {
    463            uint16_t temp = 0;
   \                     UART1_ReceiveData9:
   \   000000 3F ..        CLR       S:?b1
   \   000002 3F ..        CLR       S:?b0
    464            
    465            temp = (uint16_t)(((uint16_t)( (uint16_t)UART1->CR1 & (uint16_t)UART1_CR1_R8)) << 1);
   \   000004 C6 5234      LD        A, L:0x5234
   \   000007 5F           CLRW      X
   \   000008 97           LD        XL, A
   \   000009 58           SLLW      X
   \   00000A 02           RLWA      X, A
   \   00000B A4 01        AND       A, #0x1
   \   00000D 02           RLWA      X, A
   \   00000E A4 00        AND       A, #0x0
   \   000010 02           RLWA      X, A
   \   000011 BF ..        LDW       S:?w0, X
    466            return (uint16_t)( (((uint16_t) UART1->DR) | temp ) & ((uint16_t)0x01FF));
   \   000013 C6 5231      LD        A, L:0x5231
   \   000016 5F           CLRW      X
   \   000017 97           LD        XL, A
   \   000018 01           RRWA      X, A
   \   000019 BA ..        OR        A, S:?b1
   \   00001B 01           RRWA      X, A
   \   00001C BA ..        OR        A, S:?b0
   \   00001E 01           RRWA      X, A
   \   00001F 02           RLWA      X, A
   \   000020 A4 01        AND       A, #0x1
   \   000022 02           RLWA      X, A
   \   000023 A4 FF        AND       A, #0xff
   \   000025 02           RLWA      X, A
   \   000026 87           RETF
    467          }
    468          
    469          /**
    470            * @brief  Transmits 8 bit data through the UART1 peripheral.
    471            * @param  Data: The data to transmit.
    472            * @retval None
    473            */

   \                                 In section .far_func.text, align 1
    474          void UART1_SendData8(uint8_t Data)
    475          {
    476            /* Transmit Data */
    477            UART1->DR = Data;
   \                     UART1_SendData8:
   \   000000 C7 5231      LD        L:0x5231, A
    478          }
   \   000003 87           RETF
    479          
    480          /**
    481            * @brief  Transmits 9 bit data through the UART peripheral.
    482            * @param  Data : The data to transmit.
    483            *         This parameter should be lower than 0x1FF.
    484            * @retval None
    485            */

   \                                 In section .far_func.text, align 1
    486          void UART1_SendData9(uint16_t Data)
    487          {
   \                     UART1_SendData9:
   \   000000 9093         LDW       Y, X
    488            /**< Clear the transmit data bit 8 [8]  */
    489            UART1->CR1 &= ((uint8_t)~UART1_CR1_T8);
   \   000002 721D 5234    BRES      L:0x5234, #0x6
    490            /**< Write the transmit data bit [8]  */
    491            UART1->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & UART1_CR1_T8);
   \   000006 93           LDW       X, Y
   \   000007 54           SRLW      X
   \   000008 54           SRLW      X
   \   000009 9F           LD        A, XL
   \   00000A A4 40        AND       A, #0x40
   \   00000C CA 5234      OR        A, L:0x5234
   \   00000F C7 5234      LD        L:0x5234, A
    492            /**< Write the transmit data bit [0:7] */
    493            UART1->DR   = (uint8_t)(Data);
   \   000012 909F         LD        A, YL
   \   000014 C7 5231      LD        L:0x5231, A
    494          }
   \   000017 87           RETF
    495          
    496          /**
    497            * @brief  Transmits break characters.
    498            * @param  None
    499            * @retval None
    500            */

   \                                 In section .far_func.text, align 1
    501          void UART1_SendBreak(void)
    502          {
    503            UART1->CR2 |= UART1_CR2_SBK;
   \                     UART1_SendBreak:
   \   000000 7210 5235    BSET      L:0x5235, #0x0
    504          }
   \   000004 87           RETF
    505          
    506          /**
    507            * @brief  Sets the address of the UART1 node.
    508            * @param  UART1_Address: Indicates the address of the UART1 node.
    509            * @retval None
    510            */

   \                                 In section .far_func.text, align 1
    511          void UART1_SetAddress(uint8_t UART1_Address)
    512          {
   \                     UART1_SetAddress:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    513            /*assert_param for UART1_Address*/
    514            assert_param(IS_UART1_ADDRESS_OK(UART1_Address));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 10        CP        A, #0x10
   \   000009 25 0F        JRC       L:??UART1_SetAddress_0
   \   00000B AE 0202      LDW       X, #0x202
   \   00000E BF ..        LDW       S:?w1, X
   \   000010 5F           CLRW      X
   \   000011 BF ..        LDW       S:?w0, X
   \   000013 AE ....      LDW       X, #?_0
   \   000016 8D ......    CALLF     assert_failed
    515            
    516            /* Clear the UART1 address */
    517            UART1->CR4 &= ((uint8_t)~UART1_CR4_ADD);
   \                     ??UART1_SetAddress_0:
   \   00001A C6 5237      LD        A, L:0x5237
   \   00001D A4 F0        AND       A, #0xf0
   \   00001F C7 5237      LD        L:0x5237, A
    518            /* Set the UART1 address node */
    519            UART1->CR4 |= UART1_Address;
   \   000022 C6 5237      LD        A, L:0x5237
   \   000025 BA ..        OR        A, S:?b8
   \   000027 C7 5237      LD        L:0x5237, A
    520          }
   \   00002A 32 ....      POP       S:?b8
   \   00002D 87           RETF
    521          
    522          /**
    523            * @brief  Sets the specified UART guard time.
    524            * @note   SmartCard Mode should be Enabled
    525            * @param  UART1_GuardTime: specifies the guard time.
    526            * @retval None
    527            */

   \                                 In section .far_func.text, align 1
    528          void UART1_SetGuardTime(uint8_t UART1_GuardTime)
    529          {
    530            /* Set the UART1 guard time */
    531            UART1->GTR = UART1_GuardTime;
   \                     UART1_SetGuardTime:
   \   000000 C7 5239      LD        L:0x5239, A
    532          }
   \   000003 87           RETF
    533          
    534          /**
    535            * @brief  Sets the system clock prescaler.
    536            * @note   IrDA Low Power mode or smartcard mode should be enabled
    537            * @note   This function is related to SmartCard and IrDa mode.
    538            * @param  UART1_Prescaler: specifies the prescaler clock.
    539            *         This parameter can be one of the following values:
    540            *         @par IrDA Low Power Mode
    541            *         The clock source is divided by the value given in the register (8 bits)
    542            *         - 0000 0000 Reserved
    543            *         - 0000 0001 divides the clock source by 1
    544            *         - 0000 0010 divides the clock source by 2
    545            *         - ...
    546            *        @par Smart Card Mode
    547            *        The clock source is divided by the value given in the register
    548            *        (5 significant bits) multiplied by 2
    549            *         - 0 0000 Reserved
    550            *         - 0 0001 divides the clock source by 2
    551            *         - 0 0010 divides the clock source by 4
    552            *         - 0 0011 divides the clock source by 6
    553            *         - ...
    554            * @retval None
    555            */

   \                                 In section .far_func.text, align 1
    556          void UART1_SetPrescaler(uint8_t UART1_Prescaler)
    557          {
    558            /* Load the UART1 prescaler value*/
    559            UART1->PSCR = UART1_Prescaler;
   \                     UART1_SetPrescaler:
   \   000000 C7 523A      LD        L:0x523a, A
    560          }
   \   000003 87           RETF
    561          
    562          /**
    563            * @brief  Checks whether the specified UART1 flag is set or not.
    564            * @param  UART1_FLAG specifies the flag to check.
    565            *         This parameter can be any of the @ref UART1_Flag_TypeDef enumeration.
    566            * @retval FlagStatus (SET or RESET)
    567            */

   \                                 In section .far_func.text, align 1
    568          FlagStatus UART1_GetFlagStatus(UART1_Flag_TypeDef UART1_FLAG)
    569          {
   \                     UART1_GetFlagStatus:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
    570            FlagStatus status = RESET;
   \   000009 3F ..        CLR       S:?b10
    571            
    572            /* Check parameters */
    573            assert_param(IS_UART1_FLAG_OK(UART1_FLAG));
   \   00000B BE ..        LDW       X, S:?w4
   \   00000D A3 0080      CPW       X, #0x80
   \   000010 27 4E        JREQ      L:??UART1_GetFlagStatus_0
   \   000012 BE ..        LDW       X, S:?w4
   \   000014 A3 0040      CPW       X, #0x40
   \   000017 27 47        JREQ      L:??UART1_GetFlagStatus_0
   \   000019 BE ..        LDW       X, S:?w4
   \   00001B A3 0020      CPW       X, #0x20
   \   00001E 27 40        JREQ      L:??UART1_GetFlagStatus_0
   \   000020 BE ..        LDW       X, S:?w4
   \   000022 A3 0010      CPW       X, #0x10
   \   000025 27 39        JREQ      L:??UART1_GetFlagStatus_0
   \   000027 BE ..        LDW       X, S:?w4
   \   000029 A3 0008      CPW       X, #0x8
   \   00002C 27 32        JREQ      L:??UART1_GetFlagStatus_0
   \   00002E BE ..        LDW       X, S:?w4
   \   000030 A3 0004      CPW       X, #0x4
   \   000033 27 2B        JREQ      L:??UART1_GetFlagStatus_0
   \   000035 BE ..        LDW       X, S:?w4
   \   000037 A3 0002      CPW       X, #0x2
   \   00003A 27 24        JREQ      L:??UART1_GetFlagStatus_0
   \   00003C BE ..        LDW       X, S:?w4
   \   00003E A3 0001      CPW       X, #0x1
   \   000041 27 1D        JREQ      L:??UART1_GetFlagStatus_0
   \   000043 BE ..        LDW       X, S:?w4
   \   000045 A3 0101      CPW       X, #0x101
   \   000048 27 16        JREQ      L:??UART1_GetFlagStatus_0
   \   00004A BE ..        LDW       X, S:?w4
   \   00004C A3 0210      CPW       X, #0x210
   \   00004F 27 0F        JREQ      L:??UART1_GetFlagStatus_0
   \   000051 AE 023D      LDW       X, #0x23d
   \   000054 BF ..        LDW       S:?w1, X
   \   000056 5F           CLRW      X
   \   000057 BF ..        LDW       S:?w0, X
   \   000059 AE ....      LDW       X, #?_0
   \   00005C 8D ......    CALLF     assert_failed
    574            
    575            
    576            /* Check the status of the specified UART1 flag*/
    577            if (UART1_FLAG == UART1_FLAG_LBDF)
   \                     ??UART1_GetFlagStatus_0:
   \   000060 BE ..        LDW       X, S:?w4
   \   000062 A3 0210      CPW       X, #0x210
   \   000065 26 13        JRNE      L:??UART1_GetFlagStatus_1
    578            {
    579              if ((UART1->CR4 & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
   \   000067 B6 ..        LD        A, S:?b9
   \   000069 C4 5237      AND       A, L:0x5237
   \   00006C A1 00        CP        A, #0x0
   \   00006E 27 06        JREQ      L:??UART1_GetFlagStatus_2
    580              {
    581                /* UART1_FLAG is set*/
    582                status = SET;
   \   000070 A6 01        LD        A, #0x1
   \   000072 B7 ..        LD        S:?b10, A
   \   000074 20 2F        JRA       L:??UART1_GetFlagStatus_3
    583              }
    584              else
    585              {
    586                /* UART1_FLAG is reset*/
    587                status = RESET;
   \                     ??UART1_GetFlagStatus_2:
   \   000076 3F ..        CLR       S:?b10
   \   000078 20 2B        JRA       L:??UART1_GetFlagStatus_3
    588              }
    589            }
    590            else if (UART1_FLAG == UART1_FLAG_SBK)
   \                     ??UART1_GetFlagStatus_1:
   \   00007A BE ..        LDW       X, S:?w4
   \   00007C A3 0101      CPW       X, #0x101
   \   00007F 26 13        JRNE      L:??UART1_GetFlagStatus_4
    591            {
    592              if ((UART1->CR2 & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
   \   000081 B6 ..        LD        A, S:?b9
   \   000083 C4 5235      AND       A, L:0x5235
   \   000086 A1 00        CP        A, #0x0
   \   000088 27 06        JREQ      L:??UART1_GetFlagStatus_5
    593              {
    594                /* UART1_FLAG is set*/
    595                status = SET;
   \   00008A A6 01        LD        A, #0x1
   \   00008C B7 ..        LD        S:?b10, A
   \   00008E 20 15        JRA       L:??UART1_GetFlagStatus_3
    596              }
    597              else
    598              {
    599                /* UART1_FLAG is reset*/
    600                status = RESET;
   \                     ??UART1_GetFlagStatus_5:
   \   000090 3F ..        CLR       S:?b10
   \   000092 20 11        JRA       L:??UART1_GetFlagStatus_3
    601              }
    602            }
    603            else
    604            {
    605              if ((UART1->SR & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
   \                     ??UART1_GetFlagStatus_4:
   \   000094 B6 ..        LD        A, S:?b9
   \   000096 C4 5230      AND       A, L:0x5230
   \   000099 A1 00        CP        A, #0x0
   \   00009B 27 06        JREQ      L:??UART1_GetFlagStatus_6
    606              {
    607                /* UART1_FLAG is set*/
    608                status = SET;
   \   00009D A6 01        LD        A, #0x1
   \   00009F B7 ..        LD        S:?b10, A
   \   0000A1 20 02        JRA       L:??UART1_GetFlagStatus_3
    609              }
    610              else
    611              {
    612                /* UART1_FLAG is reset*/
    613                status = RESET;
   \                     ??UART1_GetFlagStatus_6:
   \   0000A3 3F ..        CLR       S:?b10
    614              }
    615            }
    616            /* Return the UART1_FLAG status*/
    617            return status;
   \                     ??UART1_GetFlagStatus_3:
   \   0000A5 B6 ..        LD        A, S:?b10
   \   0000A7 32 ....      POP       S:?b10
   \   0000AA AC ......    JPF       L:?epilogue_w4
    618          }
    619          
    620          /**
    621            * @brief  Clears the UART1 flags.
    622            * @param  UART1_FLAG specifies the flag to clear
    623            *         This parameter can be any combination of the following values:
    624            *         - UART1_FLAG_LBDF: LIN Break detection flag.
    625            *         - UART1_FLAG_RXNE: Receive data register not empty flag.
    626            * @note
    627            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    628            *         OR (OverRun error) and IDLE (Idle line detected) flags are 
    629            *         cleared by software sequence: a read operation to UART1_SR register
    630            *         (UART1_GetFlagStatus())followed by a read operation to UART1_DR 
    631            *         register(UART1_ReceiveData8() or UART1_ReceiveData9()).
    632            *           
    633            *         - RXNE flag can be also cleared by a read to the UART1_DR register
    634            *         (UART1_ReceiveData8()or UART1_ReceiveData9()).
    635            *           
    636            *         - TC flag can be also cleared by software sequence: a read operation
    637            *         to UART1_SR register (UART1_GetFlagStatus()) followed by a write 
    638            *         operation to UART1_DR register (UART1_SendData8() or UART1_SendData9()).
    639            *           
    640            *         - TXE flag is cleared only by a write to the UART1_DR register 
    641            *         (UART1_SendData8() or UART1_SendData9()).
    642            *           
    643            *         - SBK flag is cleared during the stop bit of break.
    644            * @retval None
    645            */

   \                                 In section .far_func.text, align 1
    646          void UART1_ClearFlag(UART1_Flag_TypeDef UART1_FLAG)
    647          {
   \                     UART1_ClearFlag:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
    648            assert_param(IS_UART1_CLEAR_FLAG_OK(UART1_FLAG));
   \   000006 BE ..        LDW       X, S:?w4
   \   000008 A3 0020      CPW       X, #0x20
   \   00000B 27 16        JREQ      L:??UART1_ClearFlag_0
   \   00000D BE ..        LDW       X, S:?w4
   \   00000F A3 0210      CPW       X, #0x210
   \   000012 27 0F        JREQ      L:??UART1_ClearFlag_0
   \   000014 AE 0288      LDW       X, #0x288
   \   000017 BF ..        LDW       S:?w1, X
   \   000019 5F           CLRW      X
   \   00001A BF ..        LDW       S:?w0, X
   \   00001C AE ....      LDW       X, #?_0
   \   00001F 8D ......    CALLF     assert_failed
    649            
    650            /* Clear the Receive Register Not Empty flag */
    651            if (UART1_FLAG == UART1_FLAG_RXNE)
   \                     ??UART1_ClearFlag_0:
   \   000023 BE ..        LDW       X, S:?w4
   \   000025 A3 0020      CPW       X, #0x20
   \   000028 26 06        JRNE      L:??UART1_ClearFlag_1
    652            {
    653              UART1->SR = (uint8_t)~(UART1_SR_RXNE);
   \   00002A 35 DF 5230   MOV       L:0x5230, #0xdf
   \   00002E 20 04        JRA       L:??UART1_ClearFlag_2
    654            }
    655            /* Clear the LIN Break Detection flag */
    656            else
    657            {
    658              UART1->CR4 &= (uint8_t)~(UART1_CR4_LBDF);
   \                     ??UART1_ClearFlag_1:
   \   000030 7219 5237    BRES      L:0x5237, #0x4
    659            }
    660          }
   \                     ??UART1_ClearFlag_2:
   \   000034 AC ......    JPF       L:?epilogue_w4
    661          
    662          /**
    663            * @brief  Checks whether the specified UART1 interrupt has occurred or not.
    664            * @param  UART1_IT: Specifies the UART1 interrupt pending bit to check.
    665            *         This parameter can be one of the following values:
    666            *         - UART1_IT_LBDF:  LIN Break detection interrupt
    667            *         - UART1_IT_TXE:  Transmit Data Register empty interrupt
    668            *         - UART1_IT_TC:   Transmission complete interrupt
    669            *         - UART1_IT_RXNE: Receive Data register not empty interrupt
    670            *         - UART1_IT_IDLE: Idle line detection interrupt
    671            *         - UART1_IT_OR:  OverRun Error interrupt
    672            *         - UART1_IT_PE:   Parity Error interrupt
    673            * @retval The new state of UART1_IT (SET or RESET).
    674            */

   \                                 In section .far_func.text, align 1
    675          ITStatus UART1_GetITStatus(UART1_IT_TypeDef UART1_IT)
    676          {
   \                     UART1_GetITStatus:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 3B ....      PUSH      S:?b14
   \   00000B BF ..        LDW       S:?w4, X
    677            ITStatus pendingbitstatus = RESET;
   \   00000D 3F ..        CLR       S:?b12
    678            uint8_t itpos = 0;
   \   00000F 3F ..        CLR       S:?b14
    679            uint8_t itmask1 = 0;
   \   000011 3F ..        CLR       S:?b11
    680            uint8_t itmask2 = 0;
   \   000013 3F ..        CLR       S:?b13
    681            uint8_t enablestatus = 0;
   \   000015 3F ..        CLR       S:?b10
    682            
    683            /* Check parameters */
    684            assert_param(IS_UART1_GET_IT_OK(UART1_IT));
   \   000017 BE ..        LDW       X, S:?w4
   \   000019 A3 0277      CPW       X, #0x277
   \   00001C 27 39        JREQ      L:??UART1_GetITStatus_0
   \   00001E BE ..        LDW       X, S:?w4
   \   000020 A3 0266      CPW       X, #0x266
   \   000023 27 32        JREQ      L:??UART1_GetITStatus_0
   \   000025 BE ..        LDW       X, S:?w4
   \   000027 A3 0255      CPW       X, #0x255
   \   00002A 27 2B        JREQ      L:??UART1_GetITStatus_0
   \   00002C BE ..        LDW       X, S:?w4
   \   00002E A3 0244      CPW       X, #0x244
   \   000031 27 24        JREQ      L:??UART1_GetITStatus_0
   \   000033 BE ..        LDW       X, S:?w4
   \   000035 A3 0235      CPW       X, #0x235
   \   000038 27 1D        JREQ      L:??UART1_GetITStatus_0
   \   00003A BE ..        LDW       X, S:?w4
   \   00003C A3 0346      CPW       X, #0x346
   \   00003F 27 16        JREQ      L:??UART1_GetITStatus_0
   \   000041 BE ..        LDW       X, S:?w4
   \   000043 A3 0100      CPW       X, #0x100
   \   000046 27 0F        JREQ      L:??UART1_GetITStatus_0
   \   000048 AE 02AC      LDW       X, #0x2ac
   \   00004B BF ..        LDW       S:?w1, X
   \   00004D 5F           CLRW      X
   \   00004E BF ..        LDW       S:?w0, X
   \   000050 AE ....      LDW       X, #?_0
   \   000053 8D ......    CALLF     assert_failed
    685            
    686            /* Get the UART1 IT index */
    687            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART1_IT & (uint8_t)0x0F));
   \                     ??UART1_GetITStatus_0:
   \   000057 B6 ..        LD        A, S:?b9
   \   000059 A4 0F        AND       A, #0xf
   \   00005B 5F           CLRW      X
   \   00005C 5C           INCW      X
   \   00005D 8D ......    CALLF     L:?sll16_x_x_a
   \   000061 9F           LD        A, XL
   \   000062 B7 ..        LD        S:?b14, A
    688            /* Get the UART1 IT index */
    689            itmask1 = (uint8_t)((uint8_t)UART1_IT >> (uint8_t)4);
   \   000064 B6 ..        LD        A, S:?b9
   \   000066 4E           SWAP      A
   \   000067 A4 0F        AND       A, #0xf
   \   000069 B7 ..        LD        S:?b11, A
    690            /* Set the IT mask*/
    691            itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \   00006B 5F           CLRW      X
   \   00006C 5C           INCW      X
   \   00006D B6 ..        LD        A, S:?b11
   \   00006F 8D ......    CALLF     L:?sll16_x_x_a
   \   000073 9F           LD        A, XL
   \   000074 B7 ..        LD        S:?b13, A
    692            
    693            
    694            /* Check the status of the specified UART1 pending bit*/
    695            if (UART1_IT == UART1_IT_PE)
   \   000076 BE ..        LDW       X, S:?w4
   \   000078 A3 0100      CPW       X, #0x100
   \   00007B 26 1E        JRNE      L:??UART1_GetITStatus_1
    696            {
    697              /* Get the UART1_IT enable bit status*/
    698              enablestatus = (uint8_t)((uint8_t)UART1->CR1 & itmask2);
   \   00007D C6 5234      LD        A, L:0x5234
   \   000080 B4 ..        AND       A, S:?b13
   \   000082 B7 ..        LD        S:?b10, A
    699              /* Check the status of the specified UART1 interrupt*/
    700              
    701              if (((UART1->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   000084 C6 5230      LD        A, L:0x5230
   \   000087 B4 ..        AND       A, S:?b14
   \   000089 A1 00        CP        A, #0x0
   \   00008B 27 0A        JREQ      L:??UART1_GetITStatus_2
   \   00008D 3D ..        TNZ       S:?b10
   \   00008F 27 06        JREQ      L:??UART1_GetITStatus_2
    702              {
    703                /* Interrupt occurred*/
    704                pendingbitstatus = SET;
   \   000091 A6 01        LD        A, #0x1
   \   000093 B7 ..        LD        S:?b12, A
   \   000095 20 45        JRA       L:??UART1_GetITStatus_3
    705              }
    706              else
    707              {
    708                /* Interrupt not occurred*/
    709                pendingbitstatus = RESET;
   \                     ??UART1_GetITStatus_2:
   \   000097 3F ..        CLR       S:?b12
   \   000099 20 41        JRA       L:??UART1_GetITStatus_3
    710              }
    711            }
    712            
    713            else if (UART1_IT == UART1_IT_LBDF)
   \                     ??UART1_GetITStatus_1:
   \   00009B BE ..        LDW       X, S:?w4
   \   00009D A3 0346      CPW       X, #0x346
   \   0000A0 26 1E        JRNE      L:??UART1_GetITStatus_4
    714            {
    715              /* Get the UART1_IT enable bit status*/
    716              enablestatus = (uint8_t)((uint8_t)UART1->CR4 & itmask2);
   \   0000A2 C6 5237      LD        A, L:0x5237
   \   0000A5 B4 ..        AND       A, S:?b13
   \   0000A7 B7 ..        LD        S:?b10, A
    717              /* Check the status of the specified UART1 interrupt*/
    718              if (((UART1->CR4 & itpos) != (uint8_t)0x00) && enablestatus)
   \   0000A9 C6 5237      LD        A, L:0x5237
   \   0000AC B4 ..        AND       A, S:?b14
   \   0000AE A1 00        CP        A, #0x0
   \   0000B0 27 0A        JREQ      L:??UART1_GetITStatus_5
   \   0000B2 3D ..        TNZ       S:?b10
   \   0000B4 27 06        JREQ      L:??UART1_GetITStatus_5
    719              {
    720                /* Interrupt occurred*/
    721                pendingbitstatus = SET;
   \   0000B6 A6 01        LD        A, #0x1
   \   0000B8 B7 ..        LD        S:?b12, A
   \   0000BA 20 20        JRA       L:??UART1_GetITStatus_3
    722              }
    723              else
    724              {
    725                /* Interrupt not occurred*/
    726                pendingbitstatus = RESET;
   \                     ??UART1_GetITStatus_5:
   \   0000BC 3F ..        CLR       S:?b12
   \   0000BE 20 1C        JRA       L:??UART1_GetITStatus_3
    727              }
    728            }
    729            else
    730            {
    731              /* Get the UART1_IT enable bit status*/
    732              enablestatus = (uint8_t)((uint8_t)UART1->CR2 & itmask2);
   \                     ??UART1_GetITStatus_4:
   \   0000C0 C6 5235      LD        A, L:0x5235
   \   0000C3 B4 ..        AND       A, S:?b13
   \   0000C5 B7 ..        LD        S:?b10, A
    733              /* Check the status of the specified UART1 interrupt*/
    734              if (((UART1->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   0000C7 C6 5230      LD        A, L:0x5230
   \   0000CA B4 ..        AND       A, S:?b14
   \   0000CC A1 00        CP        A, #0x0
   \   0000CE 27 0A        JREQ      L:??UART1_GetITStatus_6
   \   0000D0 3D ..        TNZ       S:?b10
   \   0000D2 27 06        JREQ      L:??UART1_GetITStatus_6
    735              {
    736                /* Interrupt occurred*/
    737                pendingbitstatus = SET;
   \   0000D4 A6 01        LD        A, #0x1
   \   0000D6 B7 ..        LD        S:?b12, A
   \   0000D8 20 02        JRA       L:??UART1_GetITStatus_3
    738              }
    739              else
    740              {
    741                /* Interrupt not occurred*/
    742                pendingbitstatus = RESET;
   \                     ??UART1_GetITStatus_6:
   \   0000DA 3F ..        CLR       S:?b12
    743              }
    744            }
    745            
    746            /* Return the UART1_IT status*/
    747            return  pendingbitstatus;
   \                     ??UART1_GetITStatus_3:
   \   0000DC B6 ..        LD        A, S:?b12
   \   0000DE 32 ....      POP       S:?b14
   \   0000E1 AC ......    JPF       L:?epilogue_l2_w6
    748          }
    749          
    750          /**
    751            * @brief  Clears the UART1 pending flags.
    752            * @param  UART1_IT specifies the pending bit to clear
    753            *         This parameter can be one of the following values:
    754            *         - UART1_IT_LBDF:  LIN Break detection interrupt
    755            *         - UART1_IT_RXNE: Receive Data register not empty interrupt.
    756            * @note
    757            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    758            *           OR (OverRun error) and IDLE (Idle line detected) pending bits are 
    759            *           cleared by software sequence: a read operation to UART1_SR register
    760            *           (UART1_GetITStatus()) followed by a read operation to UART1_DR register
    761            *           (UART1_ReceiveData8() or UART1_ReceiveData9()).
    762            *   
    763            *         - RXNE pending bit can be also cleared by a read to the UART1_DR register
    764            *           (UART1_ReceiveData8() or UART1_ReceiveData9()).
    765            * 
    766            *         - TC (Transmit complete) pending bit can be cleared by software 
    767            *           sequence: a read operation to UART1_SR register (UART1_GetITStatus())
    768            *           followed by a write operation to UART1_DR register (UART1_SendData8()
    769            *           or UART1_SendData9()).
    770            *             
    771            *         - TXE pending bit is cleared only by a write to the UART1_DR register
    772            *           (UART1_SendData8() or UART1_SendData9()).
    773            * @retval None
    774            */

   \                                 In section .far_func.text, align 1
    775          void UART1_ClearITPendingBit(UART1_IT_TypeDef UART1_IT)
    776          {
   \                     UART1_ClearITPendingBit:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
    777            assert_param(IS_UART1_CLEAR_IT_OK(UART1_IT));
   \   000006 BE ..        LDW       X, S:?w4
   \   000008 A3 0255      CPW       X, #0x255
   \   00000B 27 16        JREQ      L:??UART1_ClearITPendingBit_0
   \   00000D BE ..        LDW       X, S:?w4
   \   00000F A3 0346      CPW       X, #0x346
   \   000012 27 0F        JREQ      L:??UART1_ClearITPendingBit_0
   \   000014 AE 0309      LDW       X, #0x309
   \   000017 BF ..        LDW       S:?w1, X
   \   000019 5F           CLRW      X
   \   00001A BF ..        LDW       S:?w0, X
   \   00001C AE ....      LDW       X, #?_0
   \   00001F 8D ......    CALLF     assert_failed
    778            
    779            /* Clear the Receive Register Not Empty pending bit */
    780            if (UART1_IT == UART1_IT_RXNE)
   \                     ??UART1_ClearITPendingBit_0:
   \   000023 BE ..        LDW       X, S:?w4
   \   000025 A3 0255      CPW       X, #0x255
   \   000028 26 06        JRNE      L:??UART1_ClearITPendingBit_1
    781            {
    782              UART1->SR = (uint8_t)~(UART1_SR_RXNE);
   \   00002A 35 DF 5230   MOV       L:0x5230, #0xdf
   \   00002E 20 04        JRA       L:??UART1_ClearITPendingBit_2
    783            }
    784            /* Clear the LIN Break Detection pending bit */
    785            else
    786            {
    787              UART1->CR4 &= (uint8_t)~(UART1_CR4_LBDF);
   \                     ??UART1_ClearITPendingBit_1:
   \   000030 7219 5237    BRES      L:0x5237, #0x4
    788            }
    789          }
   \                     ??UART1_ClearITPendingBit_2:
   \   000034 AC ......    JPF       L:?epilogue_w4

   \                                 In section .near.rodata, align 1
   \                     ?_0:
   \   000000 2E 5C 4C 69  DC8 ".\\Lib\\C\\stm8s_uart1.c"
   \          62 5C 43 5C 
    790          
    791          /**
    792            * @}
    793            */
    794            
    795          /**
    796            * @}
    797            */
    798            
    799          
    800          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      22  ?_0
      56  UART1_ClearFlag
      56  UART1_ClearITPendingBit
      14  UART1_Cmd
      45  UART1_DeInit
     174  UART1_GetFlagStatus
     229  UART1_GetITStatus
      48  UART1_HalfDuplexCmd
     209  UART1_ITConfig
     595  UART1_Init
      48  UART1_IrDACmd
      48  UART1_IrDAConfig
      48  UART1_LINBreakDetectionConfig
      48  UART1_LINCmd
       4  UART1_ReceiveData8
      39  UART1_ReceiveData9
      48  UART1_ReceiverWakeUpCmd
       5  UART1_SendBreak
       4  UART1_SendData8
      24  UART1_SendData9
      46  UART1_SetAddress
       4  UART1_SetGuardTime
       4  UART1_SetPrescaler
      48  UART1_SmartCardCmd
      48  UART1_SmartCardNACKCmd
      46  UART1_WakeUpConfig

 
 1 938 bytes in section .far_func.text
    22 bytes in section .near.rodata
 
 1 938 bytes of CODE  memory
    22 bytes of CONST memory

Errors: none
Warnings: none
