###############################################################################
#
# IAR C/C++ Compiler V3.11.1.207 for STM8                 28/Jan/2024  21:49:09
# Copyright 2010-2019 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for STMicroelectronics STM8
#
#    Source file  =  .\Lib\C\stm8s_adc1.c
#    Command line =  
#        -f
#        c:\Users\Administrator\Desktop\新建文件夹\C\build\Debug\.obj\Lib\C\stm8s_adc1.args.txt
#        (--silent -lCN .\build\Debug\.obj\Lib\C\stm8s_adc1.lst -I "d:/Program
#        Files (x86)/IAR Systems/STM8" -I "d:/Program Files (x86)/IAR
#        Systems/STM8/stm8/lib" -I Lib/H -I Lib/C -I User -D STM8S003
#        --data_model medium --code_model medium --dlib_config dlstm8smn.h -e
#        --vregs 16 -On --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_cross_call --debug --dependencies=m + -o
#        .\build\Debug\.obj\Lib\C\stm8s_adc1.o .\Lib\C\stm8s_adc1.c)
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  .\build\Debug\.obj\Lib\C\stm8s_adc1.lst
#    Object file  =  .\build\Debug\.obj\Lib\C\stm8s_adc1.o
#
###############################################################################

c:\Users\Administrator\Desktop\新建文件夹\C\Lib\C\stm8s_adc1.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_adc1.c
      4            * @author  MCD Application Team
      5            * @version V2.3.0
      6            * @date    16-June-2017
      7            * @brief   This file contains all the functions/macros for the ADC1 peripheral.
      8             ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "stm8s_adc1.h"
     30          
     31          /** @addtogroup STM8S_StdPeriph_Driver
     32            * @{
     33            */
     34          /* Private typedef -----------------------------------------------------------*/
     35          /* Private define ------------------------------------------------------------*/
     36          /* Private macro -------------------------------------------------------------*/
     37          /* Private variables ---------------------------------------------------------*/
     38          /* Private function prototypes -----------------------------------------------*/
     39          /* Private functions ---------------------------------------------------------*/
     40          /* Public functions ----------------------------------------------------------*/
     41          
     42          /**
     43            * @addtogroup ADC1_Public_Functions
     44            * @{
     45            */
     46          
     47          /**
     48            * @brief  Deinitializes the ADC1 peripheral registers to their default reset values.
     49            * @param  None
     50            * @retval None
     51            */

   \                                 In section .far_func.text, align 1
     52          void ADC1_DeInit(void)
     53          {
     54            ADC1->CSR  = ADC1_CSR_RESET_VALUE;
   \                     ADC1_DeInit:
   \   000000 725F 5400    CLR       L:0x5400
     55            ADC1->CR1  = ADC1_CR1_RESET_VALUE;
   \   000004 725F 5401    CLR       L:0x5401
     56            ADC1->CR2  = ADC1_CR2_RESET_VALUE;
   \   000008 725F 5402    CLR       L:0x5402
     57            ADC1->CR3  = ADC1_CR3_RESET_VALUE;
   \   00000C 725F 5403    CLR       L:0x5403
     58            ADC1->TDRH = ADC1_TDRH_RESET_VALUE;
   \   000010 725F 5406    CLR       L:0x5406
     59            ADC1->TDRL = ADC1_TDRL_RESET_VALUE;
   \   000014 725F 5407    CLR       L:0x5407
     60            ADC1->HTRH = ADC1_HTRH_RESET_VALUE;
   \   000018 35 FF 5408   MOV       L:0x5408, #0xff
     61            ADC1->HTRL = ADC1_HTRL_RESET_VALUE;
   \   00001C 35 03 5409   MOV       L:0x5409, #0x3
     62            ADC1->LTRH = ADC1_LTRH_RESET_VALUE;
   \   000020 725F 540A    CLR       L:0x540a
     63            ADC1->LTRL = ADC1_LTRL_RESET_VALUE;
   \   000024 725F 540B    CLR       L:0x540b
     64            ADC1->AWCRH = ADC1_AWCRH_RESET_VALUE;
   \   000028 725F 540E    CLR       L:0x540e
     65            ADC1->AWCRL = ADC1_AWCRL_RESET_VALUE;
   \   00002C 725F 540F    CLR       L:0x540f
     66          }
   \   000030 87           RETF
     67          
     68          /**
     69            * @brief  Initializes the ADC1 peripheral according to the specified parameters
     70            * @param   ADC1_ConversionMode: specifies the conversion mode
     71            * can be one of the values of @ref ADC1_ConvMode_TypeDef.
     72            * @param   ADC1_Channel: specifies the channel to convert
     73            * can be one of the values of @ref ADC1_Channel_TypeDef.
     74            * @param   ADC1_PrescalerSelection: specifies the ADC1 prescaler
     75            * can be one of the values of @ref ADC1_PresSel_TypeDef.
     76            * @param   ADC1_ExtTrigger: specifies the external trigger
     77            * can be one of the values of @ref ADC1_ExtTrig_TypeDef.
     78            * @param   ADC1_ExtTriggerState: specifies the external trigger new state
     79            * can be one of the values of @ref FunctionalState.
     80            * @param   ADC1_Align: specifies the converted data alignment
     81            * can be one of the values of @ref ADC1_Align_TypeDef.
     82            * @param   ADC1_SchmittTriggerChannel: specifies the schmitt trigger channel
     83            * can be one of the values of @ref ADC1_SchmittTrigg_TypeDef.
     84            * @param   ADC1_SchmittTriggerState: specifies the schmitt trigger state
     85            * can be one of the values of @ref FunctionalState.
     86            * @retval None
     87            */

   \                                 In section .far_func.text, align 1
     88          void ADC1_Init(ADC1_ConvMode_TypeDef ADC1_ConversionMode, ADC1_Channel_TypeDef ADC1_Channel, ADC1_PresSel_TypeDef ADC1_PrescalerSelection, ADC1_ExtTrig_TypeDef ADC1_ExtTrigger, FunctionalState ADC1_ExtTriggerState, ADC1_Align_TypeDef ADC1_Align, ADC1_SchmittTrigg_TypeDef ADC1_SchmittTriggerChannel, FunctionalState ADC1_SchmittTriggerState)
     89          {
   \                     ADC1_Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 B7 ..        LD        S:?b15, A
   \   00000A 45 .. ..     MOV       S:?b8, S:?b0
   \   00000D 45 .. ..     MOV       S:?b9, S:?b1
   \   000010 45 .. ..     MOV       S:?b14, S:?b2
   \   000013 45 .. ..     MOV       S:?b13, S:?b3
   \   000016 45 .. ..     MOV       S:?b12, S:?b4
   \   000019 45 .. ..     MOV       S:?b10, S:?b5
   \   00001C 45 .. ..     MOV       S:?b11, S:?b6
     90            /* Check the parameters */
     91            assert_param(IS_ADC1_CONVERSIONMODE_OK(ADC1_ConversionMode));
   \   00001F 3D ..        TNZ       S:?b15
   \   000021 27 15        JREQ      L:??ADC1_Init_0
   \   000023 B6 ..        LD        A, S:?b15
   \   000025 A1 01        CP        A, #0x1
   \   000027 27 0F        JREQ      L:??ADC1_Init_0
   \   000029 AE 005B      LDW       X, #0x5b
   \   00002C BF ..        LDW       S:?w1, X
   \   00002E 5F           CLRW      X
   \   00002F BF ..        LDW       S:?w0, X
   \   000031 AE ....      LDW       X, #?_0
   \   000034 8D ......    CALLF     assert_failed
     92            assert_param(IS_ADC1_CHANNEL_OK(ADC1_Channel));
   \                     ??ADC1_Init_0:
   \   000038 3D ..        TNZ       S:?b8
   \   00003A 27 4B        JREQ      L:??ADC1_Init_1
   \   00003C B6 ..        LD        A, S:?b8
   \   00003E A1 01        CP        A, #0x1
   \   000040 27 45        JREQ      L:??ADC1_Init_1
   \   000042 B6 ..        LD        A, S:?b8
   \   000044 A1 02        CP        A, #0x2
   \   000046 27 3F        JREQ      L:??ADC1_Init_1
   \   000048 B6 ..        LD        A, S:?b8
   \   00004A A1 03        CP        A, #0x3
   \   00004C 27 39        JREQ      L:??ADC1_Init_1
   \   00004E B6 ..        LD        A, S:?b8
   \   000050 A1 04        CP        A, #0x4
   \   000052 27 33        JREQ      L:??ADC1_Init_1
   \   000054 B6 ..        LD        A, S:?b8
   \   000056 A1 05        CP        A, #0x5
   \   000058 27 2D        JREQ      L:??ADC1_Init_1
   \   00005A B6 ..        LD        A, S:?b8
   \   00005C A1 06        CP        A, #0x6
   \   00005E 27 27        JREQ      L:??ADC1_Init_1
   \   000060 B6 ..        LD        A, S:?b8
   \   000062 A1 07        CP        A, #0x7
   \   000064 27 21        JREQ      L:??ADC1_Init_1
   \   000066 B6 ..        LD        A, S:?b8
   \   000068 A1 08        CP        A, #0x8
   \   00006A 27 1B        JREQ      L:??ADC1_Init_1
   \   00006C B6 ..        LD        A, S:?b8
   \   00006E A1 0C        CP        A, #0xc
   \   000070 27 15        JREQ      L:??ADC1_Init_1
   \   000072 B6 ..        LD        A, S:?b8
   \   000074 A1 09        CP        A, #0x9
   \   000076 27 0F        JREQ      L:??ADC1_Init_1
   \   000078 AE 005C      LDW       X, #0x5c
   \   00007B BF ..        LDW       S:?w1, X
   \   00007D 5F           CLRW      X
   \   00007E BF ..        LDW       S:?w0, X
   \   000080 AE ....      LDW       X, #?_0
   \   000083 8D ......    CALLF     assert_failed
     93            assert_param(IS_ADC1_PRESSEL_OK(ADC1_PrescalerSelection));
   \                     ??ADC1_Init_1:
   \   000087 3D ..        TNZ       S:?b9
   \   000089 27 39        JREQ      L:??ADC1_Init_2
   \   00008B B6 ..        LD        A, S:?b9
   \   00008D A1 10        CP        A, #0x10
   \   00008F 27 33        JREQ      L:??ADC1_Init_2
   \   000091 B6 ..        LD        A, S:?b9
   \   000093 A1 20        CP        A, #0x20
   \   000095 27 2D        JREQ      L:??ADC1_Init_2
   \   000097 B6 ..        LD        A, S:?b9
   \   000099 A1 30        CP        A, #0x30
   \   00009B 27 27        JREQ      L:??ADC1_Init_2
   \   00009D B6 ..        LD        A, S:?b9
   \   00009F A1 40        CP        A, #0x40
   \   0000A1 27 21        JREQ      L:??ADC1_Init_2
   \   0000A3 B6 ..        LD        A, S:?b9
   \   0000A5 A1 50        CP        A, #0x50
   \   0000A7 27 1B        JREQ      L:??ADC1_Init_2
   \   0000A9 B6 ..        LD        A, S:?b9
   \   0000AB A1 60        CP        A, #0x60
   \   0000AD 27 15        JREQ      L:??ADC1_Init_2
   \   0000AF B6 ..        LD        A, S:?b9
   \   0000B1 A1 70        CP        A, #0x70
   \   0000B3 27 0F        JREQ      L:??ADC1_Init_2
   \   0000B5 AE 005D      LDW       X, #0x5d
   \   0000B8 BF ..        LDW       S:?w1, X
   \   0000BA 5F           CLRW      X
   \   0000BB BF ..        LDW       S:?w0, X
   \   0000BD AE ....      LDW       X, #?_0
   \   0000C0 8D ......    CALLF     assert_failed
     94            assert_param(IS_ADC1_EXTTRIG_OK(ADC1_ExtTrigger));
   \                     ??ADC1_Init_2:
   \   0000C4 3D ..        TNZ       S:?b14
   \   0000C6 27 15        JREQ      L:??ADC1_Init_3
   \   0000C8 B6 ..        LD        A, S:?b14
   \   0000CA A1 10        CP        A, #0x10
   \   0000CC 27 0F        JREQ      L:??ADC1_Init_3
   \   0000CE AE 005E      LDW       X, #0x5e
   \   0000D1 BF ..        LDW       S:?w1, X
   \   0000D3 5F           CLRW      X
   \   0000D4 BF ..        LDW       S:?w0, X
   \   0000D6 AE ....      LDW       X, #?_0
   \   0000D9 8D ......    CALLF     assert_failed
     95            assert_param(IS_FUNCTIONALSTATE_OK(((ADC1_ExtTriggerState))));
   \                     ??ADC1_Init_3:
   \   0000DD 3D ..        TNZ       S:?b13
   \   0000DF 27 15        JREQ      L:??ADC1_Init_4
   \   0000E1 B6 ..        LD        A, S:?b13
   \   0000E3 A1 01        CP        A, #0x1
   \   0000E5 27 0F        JREQ      L:??ADC1_Init_4
   \   0000E7 AE 005F      LDW       X, #0x5f
   \   0000EA BF ..        LDW       S:?w1, X
   \   0000EC 5F           CLRW      X
   \   0000ED BF ..        LDW       S:?w0, X
   \   0000EF AE ....      LDW       X, #?_0
   \   0000F2 8D ......    CALLF     assert_failed
     96            assert_param(IS_ADC1_ALIGN_OK(ADC1_Align));
   \                     ??ADC1_Init_4:
   \   0000F6 3D ..        TNZ       S:?b12
   \   0000F8 27 15        JREQ      L:??ADC1_Init_5
   \   0000FA B6 ..        LD        A, S:?b12
   \   0000FC A1 08        CP        A, #0x8
   \   0000FE 27 0F        JREQ      L:??ADC1_Init_5
   \   000100 AE 0060      LDW       X, #0x60
   \   000103 BF ..        LDW       S:?w1, X
   \   000105 5F           CLRW      X
   \   000106 BF ..        LDW       S:?w0, X
   \   000108 AE ....      LDW       X, #?_0
   \   00010B 8D ......    CALLF     assert_failed
     97            assert_param(IS_ADC1_SCHMITTTRIG_OK(ADC1_SchmittTriggerChannel));
   \                     ??ADC1_Init_5:
   \   00010F 3D ..        TNZ       S:?b10
   \   000111 27 51        JREQ      L:??ADC1_Init_6
   \   000113 B6 ..        LD        A, S:?b10
   \   000115 A1 01        CP        A, #0x1
   \   000117 27 4B        JREQ      L:??ADC1_Init_6
   \   000119 B6 ..        LD        A, S:?b10
   \   00011B A1 02        CP        A, #0x2
   \   00011D 27 45        JREQ      L:??ADC1_Init_6
   \   00011F B6 ..        LD        A, S:?b10
   \   000121 A1 03        CP        A, #0x3
   \   000123 27 3F        JREQ      L:??ADC1_Init_6
   \   000125 B6 ..        LD        A, S:?b10
   \   000127 A1 04        CP        A, #0x4
   \   000129 27 39        JREQ      L:??ADC1_Init_6
   \   00012B B6 ..        LD        A, S:?b10
   \   00012D A1 05        CP        A, #0x5
   \   00012F 27 33        JREQ      L:??ADC1_Init_6
   \   000131 B6 ..        LD        A, S:?b10
   \   000133 A1 06        CP        A, #0x6
   \   000135 27 2D        JREQ      L:??ADC1_Init_6
   \   000137 B6 ..        LD        A, S:?b10
   \   000139 A1 07        CP        A, #0x7
   \   00013B 27 27        JREQ      L:??ADC1_Init_6
   \   00013D B6 ..        LD        A, S:?b10
   \   00013F A1 08        CP        A, #0x8
   \   000141 27 21        JREQ      L:??ADC1_Init_6
   \   000143 B6 ..        LD        A, S:?b10
   \   000145 A1 0C        CP        A, #0xc
   \   000147 27 1B        JREQ      L:??ADC1_Init_6
   \   000149 B6 ..        LD        A, S:?b10
   \   00014B A1 FF        CP        A, #0xff
   \   00014D 27 15        JREQ      L:??ADC1_Init_6
   \   00014F B6 ..        LD        A, S:?b10
   \   000151 A1 09        CP        A, #0x9
   \   000153 27 0F        JREQ      L:??ADC1_Init_6
   \   000155 AE 0061      LDW       X, #0x61
   \   000158 BF ..        LDW       S:?w1, X
   \   00015A 5F           CLRW      X
   \   00015B BF ..        LDW       S:?w0, X
   \   00015D AE ....      LDW       X, #?_0
   \   000160 8D ......    CALLF     assert_failed
     98            assert_param(IS_FUNCTIONALSTATE_OK(ADC1_SchmittTriggerState));
   \                     ??ADC1_Init_6:
   \   000164 3D ..        TNZ       S:?b11
   \   000166 27 15        JREQ      L:??ADC1_Init_7
   \   000168 B6 ..        LD        A, S:?b11
   \   00016A A1 01        CP        A, #0x1
   \   00016C 27 0F        JREQ      L:??ADC1_Init_7
   \   00016E AE 0062      LDW       X, #0x62
   \   000171 BF ..        LDW       S:?w1, X
   \   000173 5F           CLRW      X
   \   000174 BF ..        LDW       S:?w0, X
   \   000176 AE ....      LDW       X, #?_0
   \   000179 8D ......    CALLF     assert_failed
     99            
    100            /*-----------------CR1 & CSR configuration --------------------*/
    101            /* Configure the conversion mode and the channel to convert
    102            respectively according to ADC1_ConversionMode & ADC1_Channel values  &  ADC1_Align values */
    103            ADC1_ConversionConfig(ADC1_ConversionMode, ADC1_Channel, ADC1_Align);
   \                     ??ADC1_Init_7:
   \   00017D 45 .. ..     MOV       S:?b1, S:?b12
   \   000180 45 .. ..     MOV       S:?b0, S:?b8
   \   000183 B6 ..        LD        A, S:?b15
   \   000185 8D ......    CALLF     ADC1_ConversionConfig
    104            /* Select the prescaler division factor according to ADC1_PrescalerSelection values */
    105            ADC1_PrescalerConfig(ADC1_PrescalerSelection);
   \   000189 B6 ..        LD        A, S:?b9
   \   00018B 8D ......    CALLF     ADC1_PrescalerConfig
    106            
    107            /*-----------------CR2 configuration --------------------*/
    108            /* Configure the external trigger state and event respectively
    109            according to NewState, ADC1_ExtTrigger */
    110            ADC1_ExternalTriggerConfig(ADC1_ExtTrigger, ADC1_ExtTriggerState);
   \   00018F 45 .. ..     MOV       S:?b0, S:?b13
   \   000192 B6 ..        LD        A, S:?b14
   \   000194 8D ......    CALLF     ADC1_ExternalTriggerConfig
    111            
    112            /*------------------TDR configuration ---------------------------*/
    113            /* Configure the schmitt trigger channel and state respectively
    114            according to ADC1_SchmittTriggerChannel & ADC1_SchmittTriggerNewState  values */
    115            ADC1_SchmittTriggerConfig(ADC1_SchmittTriggerChannel, ADC1_SchmittTriggerState);
   \   000198 45 .. ..     MOV       S:?b0, S:?b11
   \   00019B B6 ..        LD        A, S:?b10
   \   00019D 8D ......    CALLF     ADC1_SchmittTriggerConfig
    116            
    117            /* Enable the ADC1 peripheral */
    118            ADC1->CR1 |= ADC1_CR1_ADON;
   \   0001A1 7210 5401    BSET      L:0x5401, #0x0
    119          }
   \   0001A5 AC ......    JPF       L:?epilogue_l2_l3
    120          
    121          /**
    122            * @brief  Enables or Disables the ADC1 peripheral.
    123            * @param  NewState: specifies the peripheral enabled or disabled state.
    124            * @retval None
    125            */

   \                                 In section .far_func.text, align 1
    126          void ADC1_Cmd(FunctionalState NewState)
    127          {
   \                     ADC1_Cmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    128            /* Check the parameters */
    129            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??ADC1_Cmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??ADC1_Cmd_0
   \   00000F AE 0081      LDW       X, #0x81
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    130            
    131            if (NewState != DISABLE)
   \                     ??ADC1_Cmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??ADC1_Cmd_1
    132            {
    133              ADC1->CR1 |= ADC1_CR1_ADON;
   \   000022 7210 5401    BSET      L:0x5401, #0x0
   \   000026 20 04        JRA       L:??ADC1_Cmd_2
    134            }
    135            else /* NewState == DISABLE */
    136            {
    137              ADC1->CR1 &= (uint8_t)(~ADC1_CR1_ADON);
   \                     ??ADC1_Cmd_1:
   \   000028 7211 5401    BRES      L:0x5401, #0x0
    138            }
    139          }
   \                     ??ADC1_Cmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    140          
    141          /**
    142            * @brief  Enables or Disables the ADC1 scan mode.
    143            * @param  NewState: specifies the selected mode enabled or disabled state.
    144            * @retval None
    145            */

   \                                 In section .far_func.text, align 1
    146          void ADC1_ScanModeCmd(FunctionalState NewState)
    147          {
   \                     ADC1_ScanModeCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    148            /* Check the parameters */
    149            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??ADC1_ScanModeCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??ADC1_ScanModeCmd_0
   \   00000F AE 0095      LDW       X, #0x95
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    150            
    151            if (NewState != DISABLE)
   \                     ??ADC1_ScanModeCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??ADC1_ScanModeCmd_1
    152            {
    153              ADC1->CR2 |= ADC1_CR2_SCAN;
   \   000022 7212 5402    BSET      L:0x5402, #0x1
   \   000026 20 04        JRA       L:??ADC1_ScanModeCmd_2
    154            }
    155            else /* NewState == DISABLE */
    156            {
    157              ADC1->CR2 &= (uint8_t)(~ADC1_CR2_SCAN);
   \                     ??ADC1_ScanModeCmd_1:
   \   000028 7213 5402    BRES      L:0x5402, #0x1
    158            }
    159          }
   \                     ??ADC1_ScanModeCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    160          
    161          /**
    162            * @brief  Enables or Disables the ADC1 data store into the Data Buffer registers rather than in the Data Register
    163            * @param   NewState: specifies the selected mode enabled or disabled state.
    164            * @retval None
    165            */

   \                                 In section .far_func.text, align 1
    166          void ADC1_DataBufferCmd(FunctionalState NewState)
    167          {
   \                     ADC1_DataBufferCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    168            /* Check the parameters */
    169            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??ADC1_DataBufferCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??ADC1_DataBufferCmd_0
   \   00000F AE 00A9      LDW       X, #0xa9
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    170            
    171            if (NewState != DISABLE)
   \                     ??ADC1_DataBufferCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??ADC1_DataBufferCmd_1
    172            {
    173              ADC1->CR3 |= ADC1_CR3_DBUF;
   \   000022 721E 5403    BSET      L:0x5403, #0x7
   \   000026 20 04        JRA       L:??ADC1_DataBufferCmd_2
    174            }
    175            else /* NewState == DISABLE */
    176            {
    177              ADC1->CR3 &= (uint8_t)(~ADC1_CR3_DBUF);
   \                     ??ADC1_DataBufferCmd_1:
   \   000028 721F 5403    BRES      L:0x5403, #0x7
    178            }
    179          }
   \                     ??ADC1_DataBufferCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    180          
    181          /**
    182            * @brief  Enables or disables the ADC1 interrupt.
    183            * @param   ADC1_IT specifies the name of the interrupt to enable or disable.
    184            * This parameter can be one of the following values:
    185            *    - ADC1_IT_AWDITEN : Analog WDG interrupt enable
    186            *    - ADC1_IT_EOCITEN  : EOC iterrupt enable
    187            * @param   NewState specifies the state of the interrupt to apply.
    188            * @retval None
    189            */

   \                                 In section .far_func.text, align 1
    190          void ADC1_ITConfig(ADC1_IT_TypeDef ADC1_IT, FunctionalState NewState)
    191          {
   \                     ADC1_ITConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
   \   000009 B7 ..        LD        S:?b10, A
    192            /* Check the parameters */
    193            assert_param(IS_ADC1_IT_OK(ADC1_IT));
   \   00000B BE ..        LDW       X, S:?w4
   \   00000D A3 0020      CPW       X, #0x20
   \   000010 27 16        JREQ      L:??ADC1_ITConfig_0
   \   000012 BE ..        LDW       X, S:?w4
   \   000014 A3 0010      CPW       X, #0x10
   \   000017 27 0F        JREQ      L:??ADC1_ITConfig_0
   \   000019 AE 00C1      LDW       X, #0xc1
   \   00001C BF ..        LDW       S:?w1, X
   \   00001E 5F           CLRW      X
   \   00001F BF ..        LDW       S:?w0, X
   \   000021 AE ....      LDW       X, #?_0
   \   000024 8D ......    CALLF     assert_failed
    194            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??ADC1_ITConfig_0:
   \   000028 3D ..        TNZ       S:?b10
   \   00002A 27 15        JREQ      L:??ADC1_ITConfig_1
   \   00002C B6 ..        LD        A, S:?b10
   \   00002E A1 01        CP        A, #0x1
   \   000030 27 0F        JREQ      L:??ADC1_ITConfig_1
   \   000032 AE 00C2      LDW       X, #0xc2
   \   000035 BF ..        LDW       S:?w1, X
   \   000037 5F           CLRW      X
   \   000038 BF ..        LDW       S:?w0, X
   \   00003A AE ....      LDW       X, #?_0
   \   00003D 8D ......    CALLF     assert_failed
    195            
    196            if (NewState != DISABLE)
   \                     ??ADC1_ITConfig_1:
   \   000041 3D ..        TNZ       S:?b10
   \   000043 27 0A        JREQ      L:??ADC1_ITConfig_2
    197            {
    198              /* Enable the ADC1 interrupts */
    199              ADC1->CSR |= (uint8_t)ADC1_IT;
   \   000045 B6 ..        LD        A, S:?b9
   \   000047 CA 5400      OR        A, L:0x5400
   \   00004A C7 5400      LD        L:0x5400, A
   \   00004D 20 09        JRA       L:??ADC1_ITConfig_3
    200            }
    201            else  /* NewState == DISABLE */
    202            {
    203              /* Disable the ADC1 interrupts */
    204              ADC1->CSR &= (uint8_t)((uint16_t)~(uint16_t)ADC1_IT);
   \                     ??ADC1_ITConfig_2:
   \   00004F B6 ..        LD        A, S:?b9
   \   000051 43           CPL       A
   \   000052 C4 5400      AND       A, L:0x5400
   \   000055 C7 5400      LD        L:0x5400, A
    205            }
    206          }
   \                     ??ADC1_ITConfig_3:
   \   000058 32 ....      POP       S:?b10
   \   00005B AC ......    JPF       L:?epilogue_w4
    207          
    208          /**
    209            * @brief  Configure the ADC1 prescaler division factor.
    210            * @param   ADC1_Prescaler: the selected precaler.
    211            * It can be one of the values of @ref ADC1_PresSel_TypeDef.
    212            * @retval None
    213            */

   \                                 In section .far_func.text, align 1
    214          void ADC1_PrescalerConfig(ADC1_PresSel_TypeDef ADC1_Prescaler)
    215          {
   \                     ADC1_PrescalerConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    216            /* Check the parameter */
    217            assert_param(IS_ADC1_PRESSEL_OK(ADC1_Prescaler));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 39        JREQ      L:??ADC1_PrescalerConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 10        CP        A, #0x10
   \   00000D 27 33        JREQ      L:??ADC1_PrescalerConfig_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 20        CP        A, #0x20
   \   000013 27 2D        JREQ      L:??ADC1_PrescalerConfig_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 30        CP        A, #0x30
   \   000019 27 27        JREQ      L:??ADC1_PrescalerConfig_0
   \   00001B B6 ..        LD        A, S:?b8
   \   00001D A1 40        CP        A, #0x40
   \   00001F 27 21        JREQ      L:??ADC1_PrescalerConfig_0
   \   000021 B6 ..        LD        A, S:?b8
   \   000023 A1 50        CP        A, #0x50
   \   000025 27 1B        JREQ      L:??ADC1_PrescalerConfig_0
   \   000027 B6 ..        LD        A, S:?b8
   \   000029 A1 60        CP        A, #0x60
   \   00002B 27 15        JREQ      L:??ADC1_PrescalerConfig_0
   \   00002D B6 ..        LD        A, S:?b8
   \   00002F A1 70        CP        A, #0x70
   \   000031 27 0F        JREQ      L:??ADC1_PrescalerConfig_0
   \   000033 AE 00D9      LDW       X, #0xd9
   \   000036 BF ..        LDW       S:?w1, X
   \   000038 5F           CLRW      X
   \   000039 BF ..        LDW       S:?w0, X
   \   00003B AE ....      LDW       X, #?_0
   \   00003E 8D ......    CALLF     assert_failed
    218            
    219            /* Clear the SPSEL bits */
    220            ADC1->CR1 &= (uint8_t)(~ADC1_CR1_SPSEL);
   \                     ??ADC1_PrescalerConfig_0:
   \   000042 C6 5401      LD        A, L:0x5401
   \   000045 A4 8F        AND       A, #0x8f
   \   000047 C7 5401      LD        L:0x5401, A
    221            /* Select the prescaler division factor according to ADC1_PrescalerSelection values */
    222            ADC1->CR1 |= (uint8_t)(ADC1_Prescaler);
   \   00004A C6 5401      LD        A, L:0x5401
   \   00004D BA ..        OR        A, S:?b8
   \   00004F C7 5401      LD        L:0x5401, A
    223          }
   \   000052 32 ....      POP       S:?b8
   \   000055 87           RETF
    224          
    225          /**
    226            * @brief  Enables or disables the ADC1 Schmitt Trigger on a selected channel.
    227            * @param   ADC1_SchmittTriggerChannel specifies the desired Channel.
    228            * It can be set of the values of @ref ADC1_SchmittTrigg_TypeDef.
    229            * @param   NewState specifies Channel new status.
    230            * can have one of the values of @ref FunctionalState.
    231            * @retval None
    232            */

   \                                 In section .far_func.text, align 1
    233          void ADC1_SchmittTriggerConfig(ADC1_SchmittTrigg_TypeDef ADC1_SchmittTriggerChannel, FunctionalState NewState)
    234          {
   \                     ADC1_SchmittTriggerConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
   \   000006 45 .. ..     MOV       S:?b8, S:?b0
    235            /* Check the parameters */
    236            assert_param(IS_ADC1_SCHMITTTRIG_OK(ADC1_SchmittTriggerChannel));
   \   000009 3D ..        TNZ       S:?b9
   \   00000B 27 51        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   00000D B6 ..        LD        A, S:?b9
   \   00000F A1 01        CP        A, #0x1
   \   000011 27 4B        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   000013 B6 ..        LD        A, S:?b9
   \   000015 A1 02        CP        A, #0x2
   \   000017 27 45        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   000019 B6 ..        LD        A, S:?b9
   \   00001B A1 03        CP        A, #0x3
   \   00001D 27 3F        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   00001F B6 ..        LD        A, S:?b9
   \   000021 A1 04        CP        A, #0x4
   \   000023 27 39        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   000025 B6 ..        LD        A, S:?b9
   \   000027 A1 05        CP        A, #0x5
   \   000029 27 33        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   00002B B6 ..        LD        A, S:?b9
   \   00002D A1 06        CP        A, #0x6
   \   00002F 27 2D        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   000031 B6 ..        LD        A, S:?b9
   \   000033 A1 07        CP        A, #0x7
   \   000035 27 27        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   000037 B6 ..        LD        A, S:?b9
   \   000039 A1 08        CP        A, #0x8
   \   00003B 27 21        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   00003D B6 ..        LD        A, S:?b9
   \   00003F A1 0C        CP        A, #0xc
   \   000041 27 1B        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   000043 B6 ..        LD        A, S:?b9
   \   000045 A1 FF        CP        A, #0xff
   \   000047 27 15        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   000049 B6 ..        LD        A, S:?b9
   \   00004B A1 09        CP        A, #0x9
   \   00004D 27 0F        JREQ      L:??ADC1_SchmittTriggerConfig_0
   \   00004F AE 00EC      LDW       X, #0xec
   \   000052 BF ..        LDW       S:?w1, X
   \   000054 5F           CLRW      X
   \   000055 BF ..        LDW       S:?w0, X
   \   000057 AE ....      LDW       X, #?_0
   \   00005A 8D ......    CALLF     assert_failed
    237            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??ADC1_SchmittTriggerConfig_0:
   \   00005E 3D ..        TNZ       S:?b8
   \   000060 27 15        JREQ      L:??ADC1_SchmittTriggerConfig_1
   \   000062 B6 ..        LD        A, S:?b8
   \   000064 A1 01        CP        A, #0x1
   \   000066 27 0F        JREQ      L:??ADC1_SchmittTriggerConfig_1
   \   000068 AE 00ED      LDW       X, #0xed
   \   00006B BF ..        LDW       S:?w1, X
   \   00006D 5F           CLRW      X
   \   00006E BF ..        LDW       S:?w0, X
   \   000070 AE ....      LDW       X, #?_0
   \   000073 8D ......    CALLF     assert_failed
    238            
    239            if (ADC1_SchmittTriggerChannel == ADC1_SCHMITTTRIG_ALL)
   \                     ??ADC1_SchmittTriggerConfig_1:
   \   000077 B6 ..        LD        A, S:?b9
   \   000079 A1 FF        CP        A, #0xff
   \   00007B 26 28        JRNE      L:??ADC1_SchmittTriggerConfig_2
    240            {
    241              if (NewState != DISABLE)
   \   00007D 3D ..        TNZ       S:?b8
   \   00007F 27 12        JREQ      L:??ADC1_SchmittTriggerConfig_3
    242              {
    243                ADC1->TDRL &= (uint8_t)0x0;
   \   000081 55 5407 .... MOV       S:?b0, L:0x5407
   \   000086 725F 5407    CLR       L:0x5407
    244                ADC1->TDRH &= (uint8_t)0x0;
   \   00008A C6 5406      LD        A, L:0x5406
   \   00008D 725F 5406    CLR       L:0x5406
   \   000091 20 68        JRA       L:??ADC1_SchmittTriggerConfig_4
    245              }
    246              else /* NewState == DISABLE */
    247              {
    248                ADC1->TDRL |= (uint8_t)0xFF;
   \                     ??ADC1_SchmittTriggerConfig_3:
   \   000093 55 5407 .... MOV       S:?b0, L:0x5407
   \   000098 35 FF 5407   MOV       L:0x5407, #0xff
    249                ADC1->TDRH |= (uint8_t)0xFF;
   \   00009C C6 5406      LD        A, L:0x5406
   \   00009F 35 FF 5406   MOV       L:0x5406, #0xff
   \   0000A3 20 56        JRA       L:??ADC1_SchmittTriggerConfig_4
    250              }
    251            }
    252            else if (ADC1_SchmittTriggerChannel < ADC1_SCHMITTTRIG_CHANNEL8)
   \                     ??ADC1_SchmittTriggerConfig_2:
   \   0000A5 B6 ..        LD        A, S:?b9
   \   0000A7 A1 08        CP        A, #0x8
   \   0000A9 24 27        JRNC      L:??ADC1_SchmittTriggerConfig_5
    253            {
    254              if (NewState != DISABLE)
   \   0000AB 3D ..        TNZ       S:?b8
   \   0000AD 27 12        JREQ      L:??ADC1_SchmittTriggerConfig_6
    255              {
    256                ADC1->TDRL &= (uint8_t)(~(uint8_t)((uint8_t)0x01 << (uint8_t)ADC1_SchmittTriggerChannel));
   \   0000AF 5F           CLRW      X
   \   0000B0 5C           INCW      X
   \   0000B1 B6 ..        LD        A, S:?b9
   \   0000B3 8D ......    CALLF     L:?sll16_x_x_a
   \   0000B7 9F           LD        A, XL
   \   0000B8 43           CPL       A
   \   0000B9 C4 5407      AND       A, L:0x5407
   \   0000BC C7 5407      LD        L:0x5407, A
   \   0000BF 20 3A        JRA       L:??ADC1_SchmittTriggerConfig_4
    257              }
    258              else /* NewState == DISABLE */
    259              {
    260                ADC1->TDRL |= (uint8_t)((uint8_t)0x01 << (uint8_t)ADC1_SchmittTriggerChannel);
   \                     ??ADC1_SchmittTriggerConfig_6:
   \   0000C1 5F           CLRW      X
   \   0000C2 5C           INCW      X
   \   0000C3 B6 ..        LD        A, S:?b9
   \   0000C5 8D ......    CALLF     L:?sll16_x_x_a
   \   0000C9 9F           LD        A, XL
   \   0000CA CA 5407      OR        A, L:0x5407
   \   0000CD C7 5407      LD        L:0x5407, A
   \   0000D0 20 29        JRA       L:??ADC1_SchmittTriggerConfig_4
    261              }
    262            }
    263            else /* ADC1_SchmittTriggerChannel >= ADC1_SCHMITTTRIG_CHANNEL8 */
    264            {
    265              if (NewState != DISABLE)
   \                     ??ADC1_SchmittTriggerConfig_5:
   \   0000D2 3D ..        TNZ       S:?b8
   \   0000D4 27 14        JREQ      L:??ADC1_SchmittTriggerConfig_7
    266              {
    267                ADC1->TDRH &= (uint8_t)(~(uint8_t)((uint8_t)0x01 << ((uint8_t)ADC1_SchmittTriggerChannel - (uint8_t)8)));
   \   0000D6 B6 ..        LD        A, S:?b9
   \   0000D8 AB F8        ADD       A, #0xf8
   \   0000DA 5F           CLRW      X
   \   0000DB 5C           INCW      X
   \   0000DC 8D ......    CALLF     L:?sll16_x_x_a
   \   0000E0 9F           LD        A, XL
   \   0000E1 43           CPL       A
   \   0000E2 C4 5406      AND       A, L:0x5406
   \   0000E5 C7 5406      LD        L:0x5406, A
   \   0000E8 20 11        JRA       L:??ADC1_SchmittTriggerConfig_4
    268              }
    269              else /* NewState == DISABLE */
    270              {
    271                ADC1->TDRH |= (uint8_t)((uint8_t)0x01 << ((uint8_t)ADC1_SchmittTriggerChannel - (uint8_t)8));
   \                     ??ADC1_SchmittTriggerConfig_7:
   \   0000EA B6 ..        LD        A, S:?b9
   \   0000EC AB F8        ADD       A, #0xf8
   \   0000EE 5F           CLRW      X
   \   0000EF 5C           INCW      X
   \   0000F0 8D ......    CALLF     L:?sll16_x_x_a
   \   0000F4 9F           LD        A, XL
   \   0000F5 CA 5406      OR        A, L:0x5406
   \   0000F8 C7 5406      LD        L:0x5406, A
    272              }
    273            }
    274          }
   \                     ??ADC1_SchmittTriggerConfig_4:
   \   0000FB AC ......    JPF       L:?epilogue_w4
    275          
    276          /**
    277            * @brief  Configure the ADC1 conversion on selected channel.
    278            * @param   ADC1_ConversionMode Specifies the conversion type.
    279            * It can be set of the values of @ref ADC1_ConvMode_TypeDef
    280            * @param   ADC1_Channel specifies the ADC1 Channel.
    281            * It can be set of the values of @ref ADC1_Channel_TypeDef
    282            * @param   ADC1_Align specifies the converted data alignment.
    283            * It can be set of the values of @ref ADC1_Align_TypeDef
    284            * @retval None
    285            */

   \                                 In section .far_func.text, align 1
    286          void ADC1_ConversionConfig(ADC1_ConvMode_TypeDef ADC1_ConversionMode, ADC1_Channel_TypeDef ADC1_Channel, ADC1_Align_TypeDef ADC1_Align)
    287          {
   \                     ADC1_ConversionConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b8, A
   \   000009 45 .. ..     MOV       S:?b10, S:?b0
   \   00000C 45 .. ..     MOV       S:?b9, S:?b1
    288            /* Check the parameters */
    289            assert_param(IS_ADC1_CONVERSIONMODE_OK(ADC1_ConversionMode));
   \   00000F 3D ..        TNZ       S:?b8
   \   000011 27 15        JREQ      L:??ADC1_ConversionConfig_0
   \   000013 B6 ..        LD        A, S:?b8
   \   000015 A1 01        CP        A, #0x1
   \   000017 27 0F        JREQ      L:??ADC1_ConversionConfig_0
   \   000019 AE 0121      LDW       X, #0x121
   \   00001C BF ..        LDW       S:?w1, X
   \   00001E 5F           CLRW      X
   \   00001F BF ..        LDW       S:?w0, X
   \   000021 AE ....      LDW       X, #?_0
   \   000024 8D ......    CALLF     assert_failed
    290            assert_param(IS_ADC1_CHANNEL_OK(ADC1_Channel));
   \                     ??ADC1_ConversionConfig_0:
   \   000028 3D ..        TNZ       S:?b10
   \   00002A 27 4B        JREQ      L:??ADC1_ConversionConfig_1
   \   00002C B6 ..        LD        A, S:?b10
   \   00002E A1 01        CP        A, #0x1
   \   000030 27 45        JREQ      L:??ADC1_ConversionConfig_1
   \   000032 B6 ..        LD        A, S:?b10
   \   000034 A1 02        CP        A, #0x2
   \   000036 27 3F        JREQ      L:??ADC1_ConversionConfig_1
   \   000038 B6 ..        LD        A, S:?b10
   \   00003A A1 03        CP        A, #0x3
   \   00003C 27 39        JREQ      L:??ADC1_ConversionConfig_1
   \   00003E B6 ..        LD        A, S:?b10
   \   000040 A1 04        CP        A, #0x4
   \   000042 27 33        JREQ      L:??ADC1_ConversionConfig_1
   \   000044 B6 ..        LD        A, S:?b10
   \   000046 A1 05        CP        A, #0x5
   \   000048 27 2D        JREQ      L:??ADC1_ConversionConfig_1
   \   00004A B6 ..        LD        A, S:?b10
   \   00004C A1 06        CP        A, #0x6
   \   00004E 27 27        JREQ      L:??ADC1_ConversionConfig_1
   \   000050 B6 ..        LD        A, S:?b10
   \   000052 A1 07        CP        A, #0x7
   \   000054 27 21        JREQ      L:??ADC1_ConversionConfig_1
   \   000056 B6 ..        LD        A, S:?b10
   \   000058 A1 08        CP        A, #0x8
   \   00005A 27 1B        JREQ      L:??ADC1_ConversionConfig_1
   \   00005C B6 ..        LD        A, S:?b10
   \   00005E A1 0C        CP        A, #0xc
   \   000060 27 15        JREQ      L:??ADC1_ConversionConfig_1
   \   000062 B6 ..        LD        A, S:?b10
   \   000064 A1 09        CP        A, #0x9
   \   000066 27 0F        JREQ      L:??ADC1_ConversionConfig_1
   \   000068 AE 0122      LDW       X, #0x122
   \   00006B BF ..        LDW       S:?w1, X
   \   00006D 5F           CLRW      X
   \   00006E BF ..        LDW       S:?w0, X
   \   000070 AE ....      LDW       X, #?_0
   \   000073 8D ......    CALLF     assert_failed
    291            assert_param(IS_ADC1_ALIGN_OK(ADC1_Align));
   \                     ??ADC1_ConversionConfig_1:
   \   000077 3D ..        TNZ       S:?b9
   \   000079 27 15        JREQ      L:??ADC1_ConversionConfig_2
   \   00007B B6 ..        LD        A, S:?b9
   \   00007D A1 08        CP        A, #0x8
   \   00007F 27 0F        JREQ      L:??ADC1_ConversionConfig_2
   \   000081 AE 0123      LDW       X, #0x123
   \   000084 BF ..        LDW       S:?w1, X
   \   000086 5F           CLRW      X
   \   000087 BF ..        LDW       S:?w0, X
   \   000089 AE ....      LDW       X, #?_0
   \   00008C 8D ......    CALLF     assert_failed
    292            
    293            /* Clear the align bit */
    294            ADC1->CR2 &= (uint8_t)(~ADC1_CR2_ALIGN);
   \                     ??ADC1_ConversionConfig_2:
   \   000090 7217 5402    BRES      L:0x5402, #0x3
    295            /* Configure the data alignment */
    296            ADC1->CR2 |= (uint8_t)(ADC1_Align);
   \   000094 C6 5402      LD        A, L:0x5402
   \   000097 BA ..        OR        A, S:?b9
   \   000099 C7 5402      LD        L:0x5402, A
    297            
    298            if (ADC1_ConversionMode == ADC1_CONVERSIONMODE_CONTINUOUS)
   \   00009C B6 ..        LD        A, S:?b8
   \   00009E A1 01        CP        A, #0x1
   \   0000A0 26 06        JRNE      L:??ADC1_ConversionConfig_3
    299            {
    300              /* Set the continuous conversion mode */
    301              ADC1->CR1 |= ADC1_CR1_CONT;
   \   0000A2 7212 5401    BSET      L:0x5401, #0x1
   \   0000A6 20 04        JRA       L:??ADC1_ConversionConfig_4
    302            }
    303            else /* ADC1_ConversionMode == ADC1_CONVERSIONMODE_SINGLE */
    304            {
    305              /* Set the single conversion mode */
    306              ADC1->CR1 &= (uint8_t)(~ADC1_CR1_CONT);
   \                     ??ADC1_ConversionConfig_3:
   \   0000A8 7213 5401    BRES      L:0x5401, #0x1
    307            }
    308            
    309            /* Clear the ADC1 channels */
    310            ADC1->CSR &= (uint8_t)(~ADC1_CSR_CH);
   \                     ??ADC1_ConversionConfig_4:
   \   0000AC C6 5400      LD        A, L:0x5400
   \   0000AF A4 F0        AND       A, #0xf0
   \   0000B1 C7 5400      LD        L:0x5400, A
    311            /* Select the ADC1 channel */
    312            ADC1->CSR |= (uint8_t)(ADC1_Channel);
   \   0000B4 C6 5400      LD        A, L:0x5400
   \   0000B7 BA ..        OR        A, S:?b10
   \   0000B9 C7 5400      LD        L:0x5400, A
    313          }
   \   0000BC 32 ....      POP       S:?b10
   \   0000BF AC ......    JPF       L:?epilogue_w4
    314          
    315          /**
    316            * @brief  Configure the ADC1 conversion on external trigger event.
    317            * @par Full description:
    318            * The selected external trigger event can be enabled or disabled.
    319            * @param   ADC1_ExtTrigger to select the External trigger event.
    320            * can have one of the values of @ref ADC1_ExtTrig_TypeDef.
    321            * @param   NewState to enable/disable the selected external trigger
    322            * can have one of the values of @ref FunctionalState.
    323            * @retval None
    324            */

   \                                 In section .far_func.text, align 1
    325          void ADC1_ExternalTriggerConfig(ADC1_ExtTrig_TypeDef ADC1_ExtTrigger, FunctionalState NewState)
    326          {
   \                     ADC1_ExternalTriggerConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
   \   000006 45 .. ..     MOV       S:?b8, S:?b0
    327            /* Check the parameters */
    328            assert_param(IS_ADC1_EXTTRIG_OK(ADC1_ExtTrigger));
   \   000009 3D ..        TNZ       S:?b9
   \   00000B 27 15        JREQ      L:??ADC1_ExternalTriggerConfig_0
   \   00000D B6 ..        LD        A, S:?b9
   \   00000F A1 10        CP        A, #0x10
   \   000011 27 0F        JREQ      L:??ADC1_ExternalTriggerConfig_0
   \   000013 AE 0148      LDW       X, #0x148
   \   000016 BF ..        LDW       S:?w1, X
   \   000018 5F           CLRW      X
   \   000019 BF ..        LDW       S:?w0, X
   \   00001B AE ....      LDW       X, #?_0
   \   00001E 8D ......    CALLF     assert_failed
    329            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??ADC1_ExternalTriggerConfig_0:
   \   000022 3D ..        TNZ       S:?b8
   \   000024 27 15        JREQ      L:??ADC1_ExternalTriggerConfig_1
   \   000026 B6 ..        LD        A, S:?b8
   \   000028 A1 01        CP        A, #0x1
   \   00002A 27 0F        JREQ      L:??ADC1_ExternalTriggerConfig_1
   \   00002C AE 0149      LDW       X, #0x149
   \   00002F BF ..        LDW       S:?w1, X
   \   000031 5F           CLRW      X
   \   000032 BF ..        LDW       S:?w0, X
   \   000034 AE ....      LDW       X, #?_0
   \   000037 8D ......    CALLF     assert_failed
    330            
    331            /* Clear the external trigger selection bits */
    332            ADC1->CR2 &= (uint8_t)(~ADC1_CR2_EXTSEL);
   \                     ??ADC1_ExternalTriggerConfig_1:
   \   00003B C6 5402      LD        A, L:0x5402
   \   00003E A4 CF        AND       A, #0xcf
   \   000040 C7 5402      LD        L:0x5402, A
    333            
    334            if (NewState != DISABLE)
   \   000043 3D ..        TNZ       S:?b8
   \   000045 27 06        JREQ      L:??ADC1_ExternalTriggerConfig_2
    335            {
    336              /* Enable the selected external Trigger */
    337              ADC1->CR2 |= (uint8_t)(ADC1_CR2_EXTTRIG);
   \   000047 721C 5402    BSET      L:0x5402, #0x6
   \   00004B 20 04        JRA       L:??ADC1_ExternalTriggerConfig_3
    338            }
    339            else /* NewState == DISABLE */
    340            {
    341              /* Disable the selected external trigger */
    342              ADC1->CR2 &= (uint8_t)(~ADC1_CR2_EXTTRIG);
   \                     ??ADC1_ExternalTriggerConfig_2:
   \   00004D 721D 5402    BRES      L:0x5402, #0x6
    343            }
    344            
    345            /* Set the selected external trigger */
    346            ADC1->CR2 |= (uint8_t)(ADC1_ExtTrigger);
   \                     ??ADC1_ExternalTriggerConfig_3:
   \   000051 C6 5402      LD        A, L:0x5402
   \   000054 BA ..        OR        A, S:?b9
   \   000056 C7 5402      LD        L:0x5402, A
    347          }
   \   000059 AC ......    JPF       L:?epilogue_w4
    348          
    349          /**
    350            * @brief  Start ADC1 conversion
    351            * @par Full description:
    352            * This function  triggers the start of conversion, after ADC1 configuration.
    353            * @param  None
    354            * @retval None
    355            * @par Required preconditions:
    356            * Enable the ADC1 peripheral before calling this function
    357            */

   \                                 In section .far_func.text, align 1
    358          void ADC1_StartConversion(void)
    359          {
    360            ADC1->CR1 |= ADC1_CR1_ADON;
   \                     ADC1_StartConversion:
   \   000000 7210 5401    BSET      L:0x5401, #0x0
    361          }
   \   000004 87           RETF
    362          
    363          /**
    364            * @brief  Get one sample of measured signal.
    365            * @param  None
    366            * @retval ConversionValue:  value of the measured signal.
    367            * @par Required preconditions:
    368            * ADC1 conversion finished.
    369            */

   \                                 In section .far_func.text, align 1
    370          uint16_t ADC1_GetConversionValue(void)
    371          {
    372            uint16_t temph = 0;
   \                     ADC1_GetConversionValue:
   \   000000 905F         CLRW      Y
    373            uint8_t templ = 0;
   \   000002 3F ..        CLR       S:?b0
    374            
    375            if ((ADC1->CR2 & ADC1_CR2_ALIGN) != 0) /* Right alignment */
   \   000004 7207 5402 23 BTJF      L:0x5402, #0x3, L:??ADC1_GetConversionValue_0
    376            {
    377              /* Read LSB first */
    378              templ = ADC1->DRL;
   \   000009 C6 5405      LD        A, L:0x5405
   \   00000C B7 ..        LD        S:?b0, A
    379              /* Then read MSB */
    380              temph = ADC1->DRH;
   \   00000E C6 5404      LD        A, L:0x5404
   \   000011 5F           CLRW      X
   \   000012 97           LD        XL, A
   \   000013 9093         LDW       Y, X
    381              
    382              temph = (uint16_t)(templ | (uint16_t)(temph << (uint8_t)8));
   \   000015 93           LDW       X, Y
   \   000016 4F           CLR       A
   \   000017 02           RLWA      X, A
   \   000018 905F         CLRW      Y
   \   00001A B6 ..        LD        A, S:?b0
   \   00001C 9097         LD        YL, A
   \   00001E BF ..        LDW       S:?w1, X
   \   000020 9001         RRWA      Y, A
   \   000022 BA ..        OR        A, S:?b3
   \   000024 9001         RRWA      Y, A
   \   000026 BA ..        OR        A, S:?b2
   \   000028 9001         RRWA      Y, A
   \   00002A 20 28        JRA       L:??ADC1_GetConversionValue_1
    383            }
    384            else /* Left alignment */
    385            {
    386              /* Read MSB first*/
    387              temph = ADC1->DRH;
   \                     ??ADC1_GetConversionValue_0:
   \   00002C C6 5404      LD        A, L:0x5404
   \   00002F 5F           CLRW      X
   \   000030 97           LD        XL, A
   \   000031 9093         LDW       Y, X
    388              /* Then read LSB */
    389              templ = ADC1->DRL;
   \   000033 C6 5405      LD        A, L:0x5405
   \   000036 B7 ..        LD        S:?b0, A
    390              
    391              temph = (uint16_t)((uint16_t)((uint16_t)templ << 6) | (uint16_t)((uint16_t)temph << 8));
   \   000038 5F           CLRW      X
   \   000039 B6 ..        LD        A, S:?b0
   \   00003B 97           LD        XL, A
   \   00003C 8D ......    CALLF     L:?sll16_x_x_6
   \   000040 BF ..        LDW       S:?w1, X
   \   000042 93           LDW       X, Y
   \   000043 4F           CLR       A
   \   000044 02           RLWA      X, A
   \   000045 BF ..        LDW       S:?w2, X
   \   000047 90BE ..      LDW       Y, S:?w1
   \   00004A 9001         RRWA      Y, A
   \   00004C BA ..        OR        A, S:?b5
   \   00004E 9001         RRWA      Y, A
   \   000050 BA ..        OR        A, S:?b4
   \   000052 9001         RRWA      Y, A
    392            }
    393            
    394            return ((uint16_t)temph);
   \                     ??ADC1_GetConversionValue_1:
   \   000054 93           LDW       X, Y
   \   000055 87           RETF
    395          }
    396          
    397          /**
    398            * @brief  Enables or disables the analog watchdog for the given channel.
    399            * @param   Channel specifies the desired Channel.
    400            * It can be set of the values of @ref ADC1_Channel_TypeDef.
    401            * @param   NewState specifies the analog watchdog new state.
    402            * can have one of the values of @ref FunctionalState.
    403            * @retval None
    404            */

   \                                 In section .far_func.text, align 1
    405          void ADC1_AWDChannelConfig(ADC1_Channel_TypeDef Channel, FunctionalState NewState)
    406          {
   \                     ADC1_AWDChannelConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
   \   000006 45 .. ..     MOV       S:?b8, S:?b0
    407            /* Check the parameters */
    408            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000009 3D ..        TNZ       S:?b8
   \   00000B 27 15        JREQ      L:??ADC1_AWDChannelConfig_0
   \   00000D B6 ..        LD        A, S:?b8
   \   00000F A1 01        CP        A, #0x1
   \   000011 27 0F        JREQ      L:??ADC1_AWDChannelConfig_0
   \   000013 AE 0198      LDW       X, #0x198
   \   000016 BF ..        LDW       S:?w1, X
   \   000018 5F           CLRW      X
   \   000019 BF ..        LDW       S:?w0, X
   \   00001B AE ....      LDW       X, #?_0
   \   00001E 8D ......    CALLF     assert_failed
    409            assert_param(IS_ADC1_CHANNEL_OK(Channel));
   \                     ??ADC1_AWDChannelConfig_0:
   \   000022 3D ..        TNZ       S:?b9
   \   000024 27 4B        JREQ      L:??ADC1_AWDChannelConfig_1
   \   000026 B6 ..        LD        A, S:?b9
   \   000028 A1 01        CP        A, #0x1
   \   00002A 27 45        JREQ      L:??ADC1_AWDChannelConfig_1
   \   00002C B6 ..        LD        A, S:?b9
   \   00002E A1 02        CP        A, #0x2
   \   000030 27 3F        JREQ      L:??ADC1_AWDChannelConfig_1
   \   000032 B6 ..        LD        A, S:?b9
   \   000034 A1 03        CP        A, #0x3
   \   000036 27 39        JREQ      L:??ADC1_AWDChannelConfig_1
   \   000038 B6 ..        LD        A, S:?b9
   \   00003A A1 04        CP        A, #0x4
   \   00003C 27 33        JREQ      L:??ADC1_AWDChannelConfig_1
   \   00003E B6 ..        LD        A, S:?b9
   \   000040 A1 05        CP        A, #0x5
   \   000042 27 2D        JREQ      L:??ADC1_AWDChannelConfig_1
   \   000044 B6 ..        LD        A, S:?b9
   \   000046 A1 06        CP        A, #0x6
   \   000048 27 27        JREQ      L:??ADC1_AWDChannelConfig_1
   \   00004A B6 ..        LD        A, S:?b9
   \   00004C A1 07        CP        A, #0x7
   \   00004E 27 21        JREQ      L:??ADC1_AWDChannelConfig_1
   \   000050 B6 ..        LD        A, S:?b9
   \   000052 A1 08        CP        A, #0x8
   \   000054 27 1B        JREQ      L:??ADC1_AWDChannelConfig_1
   \   000056 B6 ..        LD        A, S:?b9
   \   000058 A1 0C        CP        A, #0xc
   \   00005A 27 15        JREQ      L:??ADC1_AWDChannelConfig_1
   \   00005C B6 ..        LD        A, S:?b9
   \   00005E A1 09        CP        A, #0x9
   \   000060 27 0F        JREQ      L:??ADC1_AWDChannelConfig_1
   \   000062 AE 0199      LDW       X, #0x199
   \   000065 BF ..        LDW       S:?w1, X
   \   000067 5F           CLRW      X
   \   000068 BF ..        LDW       S:?w0, X
   \   00006A AE ....      LDW       X, #?_0
   \   00006D 8D ......    CALLF     assert_failed
    410            
    411            if (Channel < (uint8_t)8)
   \                     ??ADC1_AWDChannelConfig_1:
   \   000071 B6 ..        LD        A, S:?b9
   \   000073 A1 08        CP        A, #0x8
   \   000075 24 27        JRNC      L:??ADC1_AWDChannelConfig_2
    412            {
    413              if (NewState != DISABLE)
   \   000077 3D ..        TNZ       S:?b8
   \   000079 27 11        JREQ      L:??ADC1_AWDChannelConfig_3
    414              {
    415                ADC1->AWCRL |= (uint8_t)((uint8_t)1 << Channel);
   \   00007B 5F           CLRW      X
   \   00007C 5C           INCW      X
   \   00007D B6 ..        LD        A, S:?b9
   \   00007F 8D ......    CALLF     L:?sll16_x_x_a
   \   000083 9F           LD        A, XL
   \   000084 CA 540F      OR        A, L:0x540f
   \   000087 C7 540F      LD        L:0x540f, A
   \   00008A 20 3B        JRA       L:??ADC1_AWDChannelConfig_4
    416              }
    417              else /* NewState == DISABLE */
    418              {
    419                ADC1->AWCRL &= (uint8_t)~(uint8_t)((uint8_t)1 << Channel);
   \                     ??ADC1_AWDChannelConfig_3:
   \   00008C 5F           CLRW      X
   \   00008D 5C           INCW      X
   \   00008E B6 ..        LD        A, S:?b9
   \   000090 8D ......    CALLF     L:?sll16_x_x_a
   \   000094 9F           LD        A, XL
   \   000095 43           CPL       A
   \   000096 C4 540F      AND       A, L:0x540f
   \   000099 C7 540F      LD        L:0x540f, A
   \   00009C 20 29        JRA       L:??ADC1_AWDChannelConfig_4
    420              }
    421            }
    422            else
    423            {
    424              if (NewState != DISABLE)
   \                     ??ADC1_AWDChannelConfig_2:
   \   00009E 3D ..        TNZ       S:?b8
   \   0000A0 27 13        JREQ      L:??ADC1_AWDChannelConfig_5
    425              {
    426                ADC1->AWCRH |= (uint8_t)((uint8_t)1 << (Channel - (uint8_t)8));
   \   0000A2 B6 ..        LD        A, S:?b9
   \   0000A4 AB F8        ADD       A, #0xf8
   \   0000A6 5F           CLRW      X
   \   0000A7 5C           INCW      X
   \   0000A8 8D ......    CALLF     L:?sll16_x_x_a
   \   0000AC 9F           LD        A, XL
   \   0000AD CA 540E      OR        A, L:0x540e
   \   0000B0 C7 540E      LD        L:0x540e, A
   \   0000B3 20 12        JRA       L:??ADC1_AWDChannelConfig_4
    427              }
    428              else /* NewState == DISABLE */
    429              {
    430                ADC1->AWCRH &= (uint8_t)~(uint8_t)((uint8_t)1 << (uint8_t)(Channel - (uint8_t)8));
   \                     ??ADC1_AWDChannelConfig_5:
   \   0000B5 B6 ..        LD        A, S:?b9
   \   0000B7 AB F8        ADD       A, #0xf8
   \   0000B9 5F           CLRW      X
   \   0000BA 5C           INCW      X
   \   0000BB 8D ......    CALLF     L:?sll16_x_x_a
   \   0000BF 9F           LD        A, XL
   \   0000C0 43           CPL       A
   \   0000C1 C4 540E      AND       A, L:0x540e
   \   0000C4 C7 540E      LD        L:0x540e, A
    431              }
    432            }
    433          }
   \                     ??ADC1_AWDChannelConfig_4:
   \   0000C7 AC ......    JPF       L:?epilogue_w4
    434          
    435          /**
    436            * @brief  Sets the high threshold of the analog watchdog.
    437            * @param   Threshold specifies the high threshold value.
    438            * this value depends on the reference voltage range.
    439            * @retval None
    440            */

   \                                 In section .far_func.text, align 1
    441          void ADC1_SetHighThreshold(uint16_t Threshold)
    442          {
   \                     ADC1_SetHighThreshold:
   \   000000 9093         LDW       Y, X
    443            ADC1->HTRH = (uint8_t)(Threshold >> (uint8_t)2);
   \   000002 93           LDW       X, Y
   \   000003 54           SRLW      X
   \   000004 54           SRLW      X
   \   000005 9F           LD        A, XL
   \   000006 C7 5408      LD        L:0x5408, A
    444            ADC1->HTRL = (uint8_t)Threshold;
   \   000009 909F         LD        A, YL
   \   00000B C7 5409      LD        L:0x5409, A
    445          }
   \   00000E 87           RETF
    446          
    447          /**
    448            * @brief  Sets the low threshold of the analog watchdog.
    449            * @param   Threshold specifies the low threshold value.
    450            * this value depends on the reference voltage range.
    451            * @retval None
    452            */

   \                                 In section .far_func.text, align 1
    453          void ADC1_SetLowThreshold(uint16_t Threshold)
    454          {
   \                     ADC1_SetLowThreshold:
   \   000000 9093         LDW       Y, X
    455            ADC1->LTRL = (uint8_t)Threshold;
   \   000002 909F         LD        A, YL
   \   000004 C7 540B      LD        L:0x540b, A
    456            ADC1->LTRH = (uint8_t)(Threshold >> (uint8_t)2);
   \   000007 93           LDW       X, Y
   \   000008 54           SRLW      X
   \   000009 54           SRLW      X
   \   00000A 9F           LD        A, XL
   \   00000B C7 540A      LD        L:0x540a, A
    457          }
   \   00000E 87           RETF
    458          
    459          /**
    460            * @brief  Get one sample of measured signal.
    461            * @param   Buffer specifies the buffer to read.
    462            * @retval BufferValue:  value read from the given buffer.
    463            * @par Required preconditions:
    464            * ADC1 conversion finished.
    465            */

   \                                 In section .far_func.text, align 1
    466          uint16_t ADC1_GetBufferValue(uint8_t Buffer)
    467          {
   \                     ADC1_GetBufferValue:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 B7 ..        LD        S:?b10, A
    468            uint16_t temph = 0;
   \   000006 3F ..        CLR       S:?b9
   \   000008 3F ..        CLR       S:?b8
    469            uint8_t templ = 0;
   \   00000A 3F ..        CLR       S:?b11
    470            
    471            /* Check the parameters */
    472            assert_param(IS_ADC1_BUFFER_OK(Buffer));
   \   00000C B6 ..        LD        A, S:?b10
   \   00000E A1 0A        CP        A, #0xa
   \   000010 25 0F        JRC       L:??ADC1_GetBufferValue_0
   \   000012 AE 01D8      LDW       X, #0x1d8
   \   000015 BF ..        LDW       S:?w1, X
   \   000017 5F           CLRW      X
   \   000018 BF ..        LDW       S:?w0, X
   \   00001A AE ....      LDW       X, #?_0
   \   00001D 8D ......    CALLF     assert_failed
    473            
    474            if ((ADC1->CR2 & ADC1_CR2_ALIGN) != 0) /* Right alignment */
   \                     ??ADC1_GetBufferValue_0:
   \   000021 7207 5402 33 BTJF      L:0x5402, #0x3, L:??ADC1_GetBufferValue_1
    475            {
    476              /* Read LSB first */
    477              templ = *(uint8_t*)(uint16_t)((uint16_t)ADC1_BaseAddress + (uint8_t)(Buffer << 1) + 1);
   \   000026 B6 ..        LD        A, S:?b10
   \   000028 48           SLL       A
   \   000029 5F           CLRW      X
   \   00002A 97           LD        XL, A
   \   00002B 1C 53E1      ADDW      X, #0x53e1
   \   00002E F6           LD        A, (X)
   \   00002F B7 ..        LD        S:?b11, A
    478              /* Then read MSB */
    479              temph = *(uint8_t*)(uint16_t)((uint16_t)ADC1_BaseAddress + (uint8_t)(Buffer << 1));
   \   000031 B6 ..        LD        A, S:?b10
   \   000033 48           SLL       A
   \   000034 5F           CLRW      X
   \   000035 97           LD        XL, A
   \   000036 1C 53E0      ADDW      X, #0x53e0
   \   000039 F6           LD        A, (X)
   \   00003A 5F           CLRW      X
   \   00003B 97           LD        XL, A
   \   00003C BF ..        LDW       S:?w4, X
    480              
    481              temph = (uint16_t)(templ | (uint16_t)(temph << (uint8_t)8));
   \   00003E BE ..        LDW       X, S:?w4
   \   000040 4F           CLR       A
   \   000041 02           RLWA      X, A
   \   000042 905F         CLRW      Y
   \   000044 B6 ..        LD        A, S:?b11
   \   000046 9097         LD        YL, A
   \   000048 BF ..        LDW       S:?w0, X
   \   00004A 9001         RRWA      Y, A
   \   00004C BA ..        OR        A, S:?b1
   \   00004E 9001         RRWA      Y, A
   \   000050 BA ..        OR        A, S:?b0
   \   000052 9001         RRWA      Y, A
   \   000054 90BF ..      LDW       S:?w4, Y
   \   000057 20 32        JRA       L:??ADC1_GetBufferValue_2
    482            }
    483            else /* Left alignment */
    484            {
    485              /* Read MSB first*/
    486              temph = *(uint8_t*)(uint16_t)((uint16_t)ADC1_BaseAddress + (uint8_t)(Buffer << 1));
   \                     ??ADC1_GetBufferValue_1:
   \   000059 B6 ..        LD        A, S:?b10
   \   00005B 48           SLL       A
   \   00005C 5F           CLRW      X
   \   00005D 97           LD        XL, A
   \   00005E 1C 53E0      ADDW      X, #0x53e0
   \   000061 F6           LD        A, (X)
   \   000062 5F           CLRW      X
   \   000063 97           LD        XL, A
   \   000064 BF ..        LDW       S:?w4, X
    487              /* Then read LSB */
    488              templ = *(uint8_t*)(uint16_t)((uint16_t)ADC1_BaseAddress + (uint8_t)(Buffer << 1) + 1);
   \   000066 B6 ..        LD        A, S:?b10
   \   000068 48           SLL       A
   \   000069 5F           CLRW      X
   \   00006A 97           LD        XL, A
   \   00006B 1C 53E1      ADDW      X, #0x53e1
   \   00006E F6           LD        A, (X)
   \   00006F B7 ..        LD        S:?b11, A
    489              
    490              temph = (uint16_t)((uint16_t)((uint16_t)templ << 6) | (uint16_t)(temph << 8));
   \   000071 5F           CLRW      X
   \   000072 B6 ..        LD        A, S:?b11
   \   000074 97           LD        XL, A
   \   000075 8D ......    CALLF     L:?sll16_x_x_6
   \   000079 9093         LDW       Y, X
   \   00007B BE ..        LDW       X, S:?w4
   \   00007D 4F           CLR       A
   \   00007E 02           RLWA      X, A
   \   00007F BF ..        LDW       S:?w0, X
   \   000081 93           LDW       X, Y
   \   000082 01           RRWA      X, A
   \   000083 BA ..        OR        A, S:?b1
   \   000085 01           RRWA      X, A
   \   000086 BA ..        OR        A, S:?b0
   \   000088 01           RRWA      X, A
   \   000089 BF ..        LDW       S:?w4, X
    491            }
    492            
    493            return ((uint16_t)temph);
   \                     ??ADC1_GetBufferValue_2:
   \   00008B BE ..        LDW       X, S:?w4
   \   00008D AC ......    JPF       L:?epilogue_l2
    494          }
    495          
    496          /**
    497            * @brief  Checks the specified analog watchdog channel status.
    498            * @param   Channel: specify the channel of which to check the analog watchdog
    499            * can be one of the values of @ref ADC1_Channel_TypeDef.
    500            * @retval FlagStatus Status of the analog watchdog.
    501            */

   \                                 In section .far_func.text, align 1
    502          FlagStatus ADC1_GetAWDChannelStatus(ADC1_Channel_TypeDef Channel)
    503          {
   \                     ADC1_GetAWDChannelStatus:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
    504            uint8_t status = 0;
   \   000006 3F ..        CLR       S:?b8
    505            
    506            /* Check the parameters */
    507            assert_param(IS_ADC1_CHANNEL_OK(Channel));
   \   000008 3D ..        TNZ       S:?b9
   \   00000A 27 4B        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   00000C B6 ..        LD        A, S:?b9
   \   00000E A1 01        CP        A, #0x1
   \   000010 27 45        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000012 B6 ..        LD        A, S:?b9
   \   000014 A1 02        CP        A, #0x2
   \   000016 27 3F        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000018 B6 ..        LD        A, S:?b9
   \   00001A A1 03        CP        A, #0x3
   \   00001C 27 39        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   00001E B6 ..        LD        A, S:?b9
   \   000020 A1 04        CP        A, #0x4
   \   000022 27 33        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000024 B6 ..        LD        A, S:?b9
   \   000026 A1 05        CP        A, #0x5
   \   000028 27 2D        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   00002A B6 ..        LD        A, S:?b9
   \   00002C A1 06        CP        A, #0x6
   \   00002E 27 27        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000030 B6 ..        LD        A, S:?b9
   \   000032 A1 07        CP        A, #0x7
   \   000034 27 21        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000036 B6 ..        LD        A, S:?b9
   \   000038 A1 08        CP        A, #0x8
   \   00003A 27 1B        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   00003C B6 ..        LD        A, S:?b9
   \   00003E A1 0C        CP        A, #0xc
   \   000040 27 15        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000042 B6 ..        LD        A, S:?b9
   \   000044 A1 09        CP        A, #0x9
   \   000046 27 0F        JREQ      L:??ADC1_GetAWDChannelStatus_0
   \   000048 AE 01FB      LDW       X, #0x1fb
   \   00004B BF ..        LDW       S:?w1, X
   \   00004D 5F           CLRW      X
   \   00004E BF ..        LDW       S:?w0, X
   \   000050 AE ....      LDW       X, #?_0
   \   000053 8D ......    CALLF     assert_failed
    508            
    509            if (Channel < (uint8_t)8)
   \                     ??ADC1_GetAWDChannelStatus_0:
   \   000057 B6 ..        LD        A, S:?b9
   \   000059 A1 08        CP        A, #0x8
   \   00005B 24 10        JRNC      L:??ADC1_GetAWDChannelStatus_1
    510            {
    511              status = (uint8_t)(ADC1->AWSRL & (uint8_t)((uint8_t)1 << Channel));
   \   00005D 5F           CLRW      X
   \   00005E 5C           INCW      X
   \   00005F B6 ..        LD        A, S:?b9
   \   000061 8D ......    CALLF     L:?sll16_x_x_a
   \   000065 9F           LD        A, XL
   \   000066 C4 540D      AND       A, L:0x540d
   \   000069 B7 ..        LD        S:?b8, A
   \   00006B 20 10        JRA       L:??ADC1_GetAWDChannelStatus_2
    512            }
    513            else /* Channel = 8 | 9 */
    514            {
    515              status = (uint8_t)(ADC1->AWSRH & (uint8_t)((uint8_t)1 << (Channel - (uint8_t)8)));
   \                     ??ADC1_GetAWDChannelStatus_1:
   \   00006D B6 ..        LD        A, S:?b9
   \   00006F AB F8        ADD       A, #0xf8
   \   000071 5F           CLRW      X
   \   000072 5C           INCW      X
   \   000073 8D ......    CALLF     L:?sll16_x_x_a
   \   000077 9F           LD        A, XL
   \   000078 C4 540C      AND       A, L:0x540c
   \   00007B B7 ..        LD        S:?b8, A
    516            }
    517            
    518            return ((FlagStatus)status);
   \                     ??ADC1_GetAWDChannelStatus_2:
   \   00007D B6 ..        LD        A, S:?b8
   \   00007F AC ......    JPF       L:?epilogue_w4
    519          }
    520          
    521          /**
    522            * @brief  Checks the specified ADC1 flag status.
    523            * @param   Flag: ADC1 flag.
    524            * can be one of the values of @ref ADC1_Flag_TypeDef.
    525            * @retval FlagStatus Status of the ADC1 flag.
    526            */

   \                                 In section .far_func.text, align 1
    527          FlagStatus ADC1_GetFlagStatus(ADC1_Flag_TypeDef Flag)
    528          {
   \                     ADC1_GetFlagStatus:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b10, A
    529            uint8_t flagstatus = 0;
   \   000009 3F ..        CLR       S:?b9
    530            uint8_t temp = 0;
   \   00000B 3F ..        CLR       S:?b8
    531            
    532            /* Check the parameters */
    533            assert_param(IS_ADC1_FLAG_OK(Flag));
   \   00000D B6 ..        LD        A, S:?b10
   \   00000F A1 80        CP        A, #0x80
   \   000011 27 57        JREQ      L:??ADC1_GetFlagStatus_0
   \   000013 B6 ..        LD        A, S:?b10
   \   000015 A1 41        CP        A, #0x41
   \   000017 27 51        JREQ      L:??ADC1_GetFlagStatus_0
   \   000019 B6 ..        LD        A, S:?b10
   \   00001B A1 40        CP        A, #0x40
   \   00001D 27 4B        JREQ      L:??ADC1_GetFlagStatus_0
   \   00001F B6 ..        LD        A, S:?b10
   \   000021 A1 10        CP        A, #0x10
   \   000023 27 45        JREQ      L:??ADC1_GetFlagStatus_0
   \   000025 B6 ..        LD        A, S:?b10
   \   000027 A1 11        CP        A, #0x11
   \   000029 27 3F        JREQ      L:??ADC1_GetFlagStatus_0
   \   00002B B6 ..        LD        A, S:?b10
   \   00002D A1 12        CP        A, #0x12
   \   00002F 27 39        JREQ      L:??ADC1_GetFlagStatus_0
   \   000031 B6 ..        LD        A, S:?b10
   \   000033 A1 13        CP        A, #0x13
   \   000035 27 33        JREQ      L:??ADC1_GetFlagStatus_0
   \   000037 B6 ..        LD        A, S:?b10
   \   000039 A1 14        CP        A, #0x14
   \   00003B 27 2D        JREQ      L:??ADC1_GetFlagStatus_0
   \   00003D B6 ..        LD        A, S:?b10
   \   00003F A1 15        CP        A, #0x15
   \   000041 27 27        JREQ      L:??ADC1_GetFlagStatus_0
   \   000043 B6 ..        LD        A, S:?b10
   \   000045 A1 16        CP        A, #0x16
   \   000047 27 21        JREQ      L:??ADC1_GetFlagStatus_0
   \   000049 B6 ..        LD        A, S:?b10
   \   00004B A1 17        CP        A, #0x17
   \   00004D 27 1B        JREQ      L:??ADC1_GetFlagStatus_0
   \   00004F B6 ..        LD        A, S:?b10
   \   000051 A1 18        CP        A, #0x18
   \   000053 27 15        JREQ      L:??ADC1_GetFlagStatus_0
   \   000055 B6 ..        LD        A, S:?b10
   \   000057 A1 19        CP        A, #0x19
   \   000059 27 0F        JREQ      L:??ADC1_GetFlagStatus_0
   \   00005B AE 0215      LDW       X, #0x215
   \   00005E BF ..        LDW       S:?w1, X
   \   000060 5F           CLRW      X
   \   000061 BF ..        LDW       S:?w0, X
   \   000063 AE ....      LDW       X, #?_0
   \   000066 8D ......    CALLF     assert_failed
    534            
    535            if ((Flag & 0x0F) == 0x01)
   \                     ??ADC1_GetFlagStatus_0:
   \   00006A B6 ..        LD        A, S:?b10
   \   00006C A4 0F        AND       A, #0xf
   \   00006E A1 01        CP        A, #0x1
   \   000070 26 09        JRNE      L:??ADC1_GetFlagStatus_1
    536            {
    537              /* Get OVR flag status */
    538              flagstatus = (uint8_t)(ADC1->CR3 & ADC1_CR3_OVR);
   \   000072 C6 5403      LD        A, L:0x5403
   \   000075 A4 40        AND       A, #0x40
   \   000077 B7 ..        LD        S:?b9, A
   \   000079 20 3D        JRA       L:??ADC1_GetFlagStatus_2
    539            }
    540            else if ((Flag & 0xF0) == 0x10)
   \                     ??ADC1_GetFlagStatus_1:
   \   00007B B6 ..        LD        A, S:?b10
   \   00007D A4 F0        AND       A, #0xf0
   \   00007F A1 10        CP        A, #0x10
   \   000081 26 2E        JRNE      L:??ADC1_GetFlagStatus_3
    541            {
    542              /* Get analog watchdog channel status */
    543              temp = (uint8_t)(Flag & (uint8_t)0x0F);
   \   000083 B6 ..        LD        A, S:?b10
   \   000085 A4 0F        AND       A, #0xf
   \   000087 B7 ..        LD        S:?b8, A
    544              if (temp < 8)
   \   000089 B6 ..        LD        A, S:?b8
   \   00008B A1 08        CP        A, #0x8
   \   00008D 24 10        JRNC      L:??ADC1_GetFlagStatus_4
    545              {
    546                flagstatus = (uint8_t)(ADC1->AWSRL & (uint8_t)((uint8_t)1 << temp));
   \   00008F 5F           CLRW      X
   \   000090 5C           INCW      X
   \   000091 B6 ..        LD        A, S:?b8
   \   000093 8D ......    CALLF     L:?sll16_x_x_a
   \   000097 9F           LD        A, XL
   \   000098 C4 540D      AND       A, L:0x540d
   \   00009B B7 ..        LD        S:?b9, A
   \   00009D 20 19        JRA       L:??ADC1_GetFlagStatus_2
    547              }
    548              else
    549              {
    550                flagstatus = (uint8_t)(ADC1->AWSRH & (uint8_t)((uint8_t)1 << (temp - 8)));
   \                     ??ADC1_GetFlagStatus_4:
   \   00009F B6 ..        LD        A, S:?b8
   \   0000A1 AB F8        ADD       A, #0xf8
   \   0000A3 5F           CLRW      X
   \   0000A4 5C           INCW      X
   \   0000A5 8D ......    CALLF     L:?sll16_x_x_a
   \   0000A9 9F           LD        A, XL
   \   0000AA C4 540C      AND       A, L:0x540c
   \   0000AD B7 ..        LD        S:?b9, A
   \   0000AF 20 07        JRA       L:??ADC1_GetFlagStatus_2
    551              }
    552            }
    553            else  /* Get EOC | AWD flag status */
    554            {
    555              flagstatus = (uint8_t)(ADC1->CSR & Flag);
   \                     ??ADC1_GetFlagStatus_3:
   \   0000B1 C6 5400      LD        A, L:0x5400
   \   0000B4 B4 ..        AND       A, S:?b10
   \   0000B6 B7 ..        LD        S:?b9, A
    556            }
    557            return ((FlagStatus)flagstatus);
   \                     ??ADC1_GetFlagStatus_2:
   \   0000B8 B6 ..        LD        A, S:?b9
   \   0000BA 32 ....      POP       S:?b10
   \   0000BD AC ......    JPF       L:?epilogue_w4
    558            
    559          }
    560          
    561          /**
    562            * @brief  Clear the specified ADC1 Flag.
    563            * @param   Flag: ADC1 flag.
    564            * can be one of the values of @ref ADC1_Flag_TypeDef.
    565            * @retval None
    566            */

   \                                 In section .far_func.text, align 1
    567          void ADC1_ClearFlag(ADC1_Flag_TypeDef Flag)
    568          {
   \                     ADC1_ClearFlag:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
    569            uint8_t temp = 0;
   \   000006 3F ..        CLR       S:?b8
    570            
    571            /* Check the parameters */
    572            assert_param(IS_ADC1_FLAG_OK(Flag));
   \   000008 B6 ..        LD        A, S:?b9
   \   00000A A1 80        CP        A, #0x80
   \   00000C 27 57        JREQ      L:??ADC1_ClearFlag_0
   \   00000E B6 ..        LD        A, S:?b9
   \   000010 A1 41        CP        A, #0x41
   \   000012 27 51        JREQ      L:??ADC1_ClearFlag_0
   \   000014 B6 ..        LD        A, S:?b9
   \   000016 A1 40        CP        A, #0x40
   \   000018 27 4B        JREQ      L:??ADC1_ClearFlag_0
   \   00001A B6 ..        LD        A, S:?b9
   \   00001C A1 10        CP        A, #0x10
   \   00001E 27 45        JREQ      L:??ADC1_ClearFlag_0
   \   000020 B6 ..        LD        A, S:?b9
   \   000022 A1 11        CP        A, #0x11
   \   000024 27 3F        JREQ      L:??ADC1_ClearFlag_0
   \   000026 B6 ..        LD        A, S:?b9
   \   000028 A1 12        CP        A, #0x12
   \   00002A 27 39        JREQ      L:??ADC1_ClearFlag_0
   \   00002C B6 ..        LD        A, S:?b9
   \   00002E A1 13        CP        A, #0x13
   \   000030 27 33        JREQ      L:??ADC1_ClearFlag_0
   \   000032 B6 ..        LD        A, S:?b9
   \   000034 A1 14        CP        A, #0x14
   \   000036 27 2D        JREQ      L:??ADC1_ClearFlag_0
   \   000038 B6 ..        LD        A, S:?b9
   \   00003A A1 15        CP        A, #0x15
   \   00003C 27 27        JREQ      L:??ADC1_ClearFlag_0
   \   00003E B6 ..        LD        A, S:?b9
   \   000040 A1 16        CP        A, #0x16
   \   000042 27 21        JREQ      L:??ADC1_ClearFlag_0
   \   000044 B6 ..        LD        A, S:?b9
   \   000046 A1 17        CP        A, #0x17
   \   000048 27 1B        JREQ      L:??ADC1_ClearFlag_0
   \   00004A B6 ..        LD        A, S:?b9
   \   00004C A1 18        CP        A, #0x18
   \   00004E 27 15        JREQ      L:??ADC1_ClearFlag_0
   \   000050 B6 ..        LD        A, S:?b9
   \   000052 A1 19        CP        A, #0x19
   \   000054 27 0F        JREQ      L:??ADC1_ClearFlag_0
   \   000056 AE 023C      LDW       X, #0x23c
   \   000059 BF ..        LDW       S:?w1, X
   \   00005B 5F           CLRW      X
   \   00005C BF ..        LDW       S:?w0, X
   \   00005E AE ....      LDW       X, #?_0
   \   000061 8D ......    CALLF     assert_failed
    573            
    574            if ((Flag & 0x0F) == 0x01)
   \                     ??ADC1_ClearFlag_0:
   \   000065 B6 ..        LD        A, S:?b9
   \   000067 A4 0F        AND       A, #0xf
   \   000069 A1 01        CP        A, #0x1
   \   00006B 26 06        JRNE      L:??ADC1_ClearFlag_1
    575            {
    576              /* Clear OVR flag status */
    577              ADC1->CR3 &= (uint8_t)(~ADC1_CR3_OVR);
   \   00006D 721D 5403    BRES      L:0x5403, #0x6
   \   000071 20 43        JRA       L:??ADC1_ClearFlag_2
    578            }
    579            else if ((Flag & 0xF0) == 0x10)
   \                     ??ADC1_ClearFlag_1:
   \   000073 B6 ..        LD        A, S:?b9
   \   000075 A4 F0        AND       A, #0xf0
   \   000077 A1 10        CP        A, #0x10
   \   000079 26 32        JRNE      L:??ADC1_ClearFlag_3
    580            {
    581              /* Clear analog watchdog channel status */
    582              temp = (uint8_t)(Flag & (uint8_t)0x0F);
   \   00007B B6 ..        LD        A, S:?b9
   \   00007D A4 0F        AND       A, #0xf
   \   00007F B7 ..        LD        S:?b8, A
    583              if (temp < 8)
   \   000081 B6 ..        LD        A, S:?b8
   \   000083 A1 08        CP        A, #0x8
   \   000085 24 12        JRNC      L:??ADC1_ClearFlag_4
    584              {
    585                ADC1->AWSRL &= (uint8_t)~(uint8_t)((uint8_t)1 << temp);
   \   000087 5F           CLRW      X
   \   000088 5C           INCW      X
   \   000089 B6 ..        LD        A, S:?b8
   \   00008B 8D ......    CALLF     L:?sll16_x_x_a
   \   00008F 9F           LD        A, XL
   \   000090 43           CPL       A
   \   000091 C4 540D      AND       A, L:0x540d
   \   000094 C7 540D      LD        L:0x540d, A
   \   000097 20 1D        JRA       L:??ADC1_ClearFlag_2
    586              }
    587              else
    588              {
    589                ADC1->AWSRH &= (uint8_t)~(uint8_t)((uint8_t)1 << (temp - 8));
   \                     ??ADC1_ClearFlag_4:
   \   000099 B6 ..        LD        A, S:?b8
   \   00009B AB F8        ADD       A, #0xf8
   \   00009D 5F           CLRW      X
   \   00009E 5C           INCW      X
   \   00009F 8D ......    CALLF     L:?sll16_x_x_a
   \   0000A3 9F           LD        A, XL
   \   0000A4 43           CPL       A
   \   0000A5 C4 540C      AND       A, L:0x540c
   \   0000A8 C7 540C      LD        L:0x540c, A
   \   0000AB 20 09        JRA       L:??ADC1_ClearFlag_2
    590              }
    591            }
    592            else  /* Clear EOC | AWD flag status */
    593            {
    594              ADC1->CSR &= (uint8_t) (~Flag);
   \                     ??ADC1_ClearFlag_3:
   \   0000AD B6 ..        LD        A, S:?b9
   \   0000AF 43           CPL       A
   \   0000B0 C4 5400      AND       A, L:0x5400
   \   0000B3 C7 5400      LD        L:0x5400, A
    595            }
    596          }
   \                     ??ADC1_ClearFlag_2:
   \   0000B6 AC ......    JPF       L:?epilogue_w4
    597          
    598          /**
    599            * @brief  Returns the specified pending bit status
    600            * @param   ITPendingBit : the IT pending bit to check.
    601            * This parameter can be one of the following values:
    602            *    - ADC1_IT_AWD   : Analog WDG IT status
    603            *    - ADC1_IT_AWS0 : Analog channel 0 IT status
    604            *    - ADC1_IT_AWS1 : Analog channel 1 IT status
    605            *    - ADC1_IT_AWS2 : Analog channel 2 IT status
    606            *    - ADC1_IT_AWS3 : Analog channel 3 IT status
    607            *    - ADC1_IT_AWS4 : Analog channel 4 IT status
    608            *    - ADC1_IT_AWS5 : Analog channel 5 IT status
    609            *    - ADC1_IT_AWS6 : Analog channel 6 IT status
    610            *    - ADC1_IT_AWS7 : Analog channel 7 IT status
    611            *    - ADC1_IT_AWS8 : Analog channel 8 IT status
    612            *    - ADC1_IT_AWS9 : Analog channel 9 IT status
    613            *    - ADC1_IT_EOC    : EOC pending bit
    614            * @retval ITStatus: status of the specified pending bit.
    615            */

   \                                 In section .far_func.text, align 1
    616          ITStatus ADC1_GetITStatus(ADC1_IT_TypeDef ITPendingBit)
    617          {
   \                     ADC1_GetITStatus:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 BF ..        LDW       S:?w4, X
    618            ITStatus itstatus = RESET;
   \   000006 3F ..        CLR       S:?b11
    619            uint8_t temp = 0;
   \   000008 3F ..        CLR       S:?b10
    620            
    621            /* Check the parameters */
    622            assert_param(IS_ADC1_ITPENDINGBIT_OK(ITPendingBit));
   \   00000A BE ..        LDW       X, S:?w4
   \   00000C A3 0080      CPW       X, #0x80
   \   00000F 27 63        JREQ      L:??ADC1_GetITStatus_0
   \   000011 BE ..        LDW       X, S:?w4
   \   000013 A3 0140      CPW       X, #0x140
   \   000016 27 5C        JREQ      L:??ADC1_GetITStatus_0
   \   000018 BE ..        LDW       X, S:?w4
   \   00001A A3 0110      CPW       X, #0x110
   \   00001D 27 55        JREQ      L:??ADC1_GetITStatus_0
   \   00001F BE ..        LDW       X, S:?w4
   \   000021 A3 0111      CPW       X, #0x111
   \   000024 27 4E        JREQ      L:??ADC1_GetITStatus_0
   \   000026 BE ..        LDW       X, S:?w4
   \   000028 A3 0112      CPW       X, #0x112
   \   00002B 27 47        JREQ      L:??ADC1_GetITStatus_0
   \   00002D BE ..        LDW       X, S:?w4
   \   00002F A3 0113      CPW       X, #0x113
   \   000032 27 40        JREQ      L:??ADC1_GetITStatus_0
   \   000034 BE ..        LDW       X, S:?w4
   \   000036 A3 0114      CPW       X, #0x114
   \   000039 27 39        JREQ      L:??ADC1_GetITStatus_0
   \   00003B BE ..        LDW       X, S:?w4
   \   00003D A3 0115      CPW       X, #0x115
   \   000040 27 32        JREQ      L:??ADC1_GetITStatus_0
   \   000042 BE ..        LDW       X, S:?w4
   \   000044 A3 0116      CPW       X, #0x116
   \   000047 27 2B        JREQ      L:??ADC1_GetITStatus_0
   \   000049 BE ..        LDW       X, S:?w4
   \   00004B A3 0117      CPW       X, #0x117
   \   00004E 27 24        JREQ      L:??ADC1_GetITStatus_0
   \   000050 BE ..        LDW       X, S:?w4
   \   000052 A3 0118      CPW       X, #0x118
   \   000055 27 1D        JREQ      L:??ADC1_GetITStatus_0
   \   000057 BE ..        LDW       X, S:?w4
   \   000059 A3 011C      CPW       X, #0x11c
   \   00005C 27 16        JREQ      L:??ADC1_GetITStatus_0
   \   00005E BE ..        LDW       X, S:?w4
   \   000060 A3 0119      CPW       X, #0x119
   \   000063 27 0F        JREQ      L:??ADC1_GetITStatus_0
   \   000065 AE 026E      LDW       X, #0x26e
   \   000068 BF ..        LDW       S:?w1, X
   \   00006A 5F           CLRW      X
   \   00006B BF ..        LDW       S:?w0, X
   \   00006D AE ....      LDW       X, #?_0
   \   000070 8D ......    CALLF     assert_failed
    623            
    624            if (((uint16_t)ITPendingBit & 0xF0) == 0x10)
   \                     ??ADC1_GetITStatus_0:
   \   000074 B6 ..        LD        A, S:?b9
   \   000076 A4 F0        AND       A, #0xf0
   \   000078 A1 10        CP        A, #0x10
   \   00007A 26 2E        JRNE      L:??ADC1_GetITStatus_1
    625            {
    626              /* Get analog watchdog channel status */
    627              temp = (uint8_t)((uint16_t)ITPendingBit & 0x0F);
   \   00007C B6 ..        LD        A, S:?b9
   \   00007E A4 0F        AND       A, #0xf
   \   000080 B7 ..        LD        S:?b10, A
    628              if (temp < 8)
   \   000082 B6 ..        LD        A, S:?b10
   \   000084 A1 08        CP        A, #0x8
   \   000086 24 10        JRNC      L:??ADC1_GetITStatus_2
    629              {
    630                itstatus = (ITStatus)(ADC1->AWSRL & (uint8_t)((uint8_t)1 << temp));
   \   000088 5F           CLRW      X
   \   000089 5C           INCW      X
   \   00008A B6 ..        LD        A, S:?b10
   \   00008C 8D ......    CALLF     L:?sll16_x_x_a
   \   000090 9F           LD        A, XL
   \   000091 C4 540D      AND       A, L:0x540d
   \   000094 B7 ..        LD        S:?b11, A
   \   000096 20 19        JRA       L:??ADC1_GetITStatus_3
    631              }
    632              else
    633              {
    634                itstatus = (ITStatus)(ADC1->AWSRH & (uint8_t)((uint8_t)1 << (temp - 8)));
   \                     ??ADC1_GetITStatus_2:
   \   000098 B6 ..        LD        A, S:?b10
   \   00009A AB F8        ADD       A, #0xf8
   \   00009C 5F           CLRW      X
   \   00009D 5C           INCW      X
   \   00009E 8D ......    CALLF     L:?sll16_x_x_a
   \   0000A2 9F           LD        A, XL
   \   0000A3 C4 540C      AND       A, L:0x540c
   \   0000A6 B7 ..        LD        S:?b11, A
   \   0000A8 20 07        JRA       L:??ADC1_GetITStatus_3
    635              }
    636            }
    637            else  /* Get EOC | AWD flag status */
    638            {
    639              itstatus = (ITStatus)(ADC1->CSR & (uint8_t)ITPendingBit);
   \                     ??ADC1_GetITStatus_1:
   \   0000AA B6 ..        LD        A, S:?b9
   \   0000AC C4 5400      AND       A, L:0x5400
   \   0000AF B7 ..        LD        S:?b11, A
    640            }
    641            return ((ITStatus)itstatus);
   \                     ??ADC1_GetITStatus_3:
   \   0000B1 B6 ..        LD        A, S:?b11
   \   0000B3 AC ......    JPF       L:?epilogue_l2
    642          }
    643          
    644          /**
    645            * @brief  Clear the ADC1 End of Conversion pending bit.
    646            * @param   ITPendingBit : the IT pending bit to clear.
    647            * This parameter can be one of the following values:
    648            *    - ADC1_IT_AWD   : Analog WDG IT status
    649            *    - ADC1_IT_AWS0 : Analog channel 0 IT status
    650            *    - ADC1_IT_AWS1 : Analog channel 1 IT status
    651            *    - ADC1_IT_AWS2 : Analog channel 2 IT status
    652            *    - ADC1_IT_AWS3 : Analog channel 3 IT status
    653            *    - ADC1_IT_AWS4 : Analog channel 4 IT status
    654            *    - ADC1_IT_AWS5 : Analog channel 5 IT status
    655            *    - ADC1_IT_AWS6 : Analog channel 6 IT status
    656            *    - ADC1_IT_AWS7 : Analog channel 7 IT status
    657            *    - ADC1_IT_AWS8 : Analog channel 8 IT status
    658            *    - ADC1_IT_AWS9 : Analog channel 9 IT status
    659            *    - ADC1_IT_EOC  : EOC pending bit
    660            * @retval None
    661            */

   \                                 In section .far_func.text, align 1
    662          void ADC1_ClearITPendingBit(ADC1_IT_TypeDef ITPendingBit)
    663          {
   \                     ADC1_ClearITPendingBit:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
    664            uint8_t temp = 0;
   \   000009 3F ..        CLR       S:?b10
    665            
    666            /* Check the parameters */
    667            assert_param(IS_ADC1_ITPENDINGBIT_OK(ITPendingBit));
   \   00000B BE ..        LDW       X, S:?w4
   \   00000D A3 0080      CPW       X, #0x80
   \   000010 27 63        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000012 BE ..        LDW       X, S:?w4
   \   000014 A3 0140      CPW       X, #0x140
   \   000017 27 5C        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000019 BE ..        LDW       X, S:?w4
   \   00001B A3 0110      CPW       X, #0x110
   \   00001E 27 55        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000020 BE ..        LDW       X, S:?w4
   \   000022 A3 0111      CPW       X, #0x111
   \   000025 27 4E        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000027 BE ..        LDW       X, S:?w4
   \   000029 A3 0112      CPW       X, #0x112
   \   00002C 27 47        JREQ      L:??ADC1_ClearITPendingBit_0
   \   00002E BE ..        LDW       X, S:?w4
   \   000030 A3 0113      CPW       X, #0x113
   \   000033 27 40        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000035 BE ..        LDW       X, S:?w4
   \   000037 A3 0114      CPW       X, #0x114
   \   00003A 27 39        JREQ      L:??ADC1_ClearITPendingBit_0
   \   00003C BE ..        LDW       X, S:?w4
   \   00003E A3 0115      CPW       X, #0x115
   \   000041 27 32        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000043 BE ..        LDW       X, S:?w4
   \   000045 A3 0116      CPW       X, #0x116
   \   000048 27 2B        JREQ      L:??ADC1_ClearITPendingBit_0
   \   00004A BE ..        LDW       X, S:?w4
   \   00004C A3 0117      CPW       X, #0x117
   \   00004F 27 24        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000051 BE ..        LDW       X, S:?w4
   \   000053 A3 0118      CPW       X, #0x118
   \   000056 27 1D        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000058 BE ..        LDW       X, S:?w4
   \   00005A A3 011C      CPW       X, #0x11c
   \   00005D 27 16        JREQ      L:??ADC1_ClearITPendingBit_0
   \   00005F BE ..        LDW       X, S:?w4
   \   000061 A3 0119      CPW       X, #0x119
   \   000064 27 0F        JREQ      L:??ADC1_ClearITPendingBit_0
   \   000066 AE 029B      LDW       X, #0x29b
   \   000069 BF ..        LDW       S:?w1, X
   \   00006B 5F           CLRW      X
   \   00006C BF ..        LDW       S:?w0, X
   \   00006E AE ....      LDW       X, #?_0
   \   000071 8D ......    CALLF     assert_failed
    668            
    669            if (((uint16_t)ITPendingBit & 0xF0) == 0x10)
   \                     ??ADC1_ClearITPendingBit_0:
   \   000075 B6 ..        LD        A, S:?b9
   \   000077 A4 F0        AND       A, #0xf0
   \   000079 A1 10        CP        A, #0x10
   \   00007B 26 32        JRNE      L:??ADC1_ClearITPendingBit_1
    670            {
    671              /* Clear analog watchdog channel status */
    672              temp = (uint8_t)((uint16_t)ITPendingBit & 0x0F);
   \   00007D B6 ..        LD        A, S:?b9
   \   00007F A4 0F        AND       A, #0xf
   \   000081 B7 ..        LD        S:?b10, A
    673              if (temp < 8)
   \   000083 B6 ..        LD        A, S:?b10
   \   000085 A1 08        CP        A, #0x8
   \   000087 24 12        JRNC      L:??ADC1_ClearITPendingBit_2
    674              {
    675                ADC1->AWSRL &= (uint8_t)~(uint8_t)((uint8_t)1 << temp);
   \   000089 5F           CLRW      X
   \   00008A 5C           INCW      X
   \   00008B B6 ..        LD        A, S:?b10
   \   00008D 8D ......    CALLF     L:?sll16_x_x_a
   \   000091 9F           LD        A, XL
   \   000092 43           CPL       A
   \   000093 C4 540D      AND       A, L:0x540d
   \   000096 C7 540D      LD        L:0x540d, A
   \   000099 20 1D        JRA       L:??ADC1_ClearITPendingBit_3
    676              }
    677              else
    678              {
    679                ADC1->AWSRH &= (uint8_t)~(uint8_t)((uint8_t)1 << (temp - 8));
   \                     ??ADC1_ClearITPendingBit_2:
   \   00009B B6 ..        LD        A, S:?b10
   \   00009D AB F8        ADD       A, #0xf8
   \   00009F 5F           CLRW      X
   \   0000A0 5C           INCW      X
   \   0000A1 8D ......    CALLF     L:?sll16_x_x_a
   \   0000A5 9F           LD        A, XL
   \   0000A6 43           CPL       A
   \   0000A7 C4 540C      AND       A, L:0x540c
   \   0000AA C7 540C      LD        L:0x540c, A
   \   0000AD 20 09        JRA       L:??ADC1_ClearITPendingBit_3
    680              }
    681            }
    682            else  /* Clear EOC | AWD flag status */
    683            {
    684              ADC1->CSR &= (uint8_t)((uint16_t)~(uint16_t)ITPendingBit);
   \                     ??ADC1_ClearITPendingBit_1:
   \   0000AF B6 ..        LD        A, S:?b9
   \   0000B1 43           CPL       A
   \   0000B2 C4 5400      AND       A, L:0x5400
   \   0000B5 C7 5400      LD        L:0x5400, A
    685            }
    686          }
   \                     ??ADC1_ClearITPendingBit_3:
   \   0000B8 32 ....      POP       S:?b10
   \   0000BB AC ......    JPF       L:?epilogue_w4

   \                                 In section .near.rodata, align 1
   \                     ?_0:
   \   000000 2E 5C 4C 69  DC8 ".\\Lib\\C\\stm8s_adc1.c"
   \          62 5C 43 5C 
    687          
    688          /**
    689            * @}
    690            */
    691            
    692          /**
    693            * @}
    694            */
    695            
    696          
    697          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      21  ?_0
     203  ADC1_AWDChannelConfig
     186  ADC1_ClearFlag
     191  ADC1_ClearITPendingBit
      48  ADC1_Cmd
     195  ADC1_ConversionConfig
      48  ADC1_DataBufferCmd
      49  ADC1_DeInit
      93  ADC1_ExternalTriggerConfig
     131  ADC1_GetAWDChannelStatus
     145  ADC1_GetBufferValue
      86  ADC1_GetConversionValue
     193  ADC1_GetFlagStatus
     183  ADC1_GetITStatus
      95  ADC1_ITConfig
     425  ADC1_Init
      86  ADC1_PrescalerConfig
      48  ADC1_ScanModeCmd
     255  ADC1_SchmittTriggerConfig
      15  ADC1_SetHighThreshold
      15  ADC1_SetLowThreshold
       5  ADC1_StartConversion

 
 2 695 bytes in section .far_func.text
    21 bytes in section .near.rodata
 
 2 695 bytes of CODE  memory
    21 bytes of CONST memory

Errors: none
Warnings: none
