###############################################################################
#
# IAR C/C++ Compiler V3.11.1.207 for STM8                 28/Jan/2024  21:49:09
# Copyright 2010-2019 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for STMicroelectronics STM8
#
#    Source file  =  .\Lib\C\stm8s_clk.c
#    Command line =  
#        -f
#        c:\Users\Administrator\Desktop\新建文件夹\C\build\Debug\.obj\Lib\C\stm8s_clk.args.txt
#        (--silent -lCN .\build\Debug\.obj\Lib\C\stm8s_clk.lst -I "d:/Program
#        Files (x86)/IAR Systems/STM8" -I "d:/Program Files (x86)/IAR
#        Systems/STM8/stm8/lib" -I Lib/H -I Lib/C -I User -D STM8S003
#        --data_model medium --code_model medium --dlib_config dlstm8smn.h -e
#        --vregs 16 -On --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_cross_call --debug --dependencies=m + -o
#        .\build\Debug\.obj\Lib\C\stm8s_clk.o .\Lib\C\stm8s_clk.c)
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  .\build\Debug\.obj\Lib\C\stm8s_clk.lst
#    Object file  =  .\build\Debug\.obj\Lib\C\stm8s_clk.o
#
###############################################################################

c:\Users\Administrator\Desktop\新建文件夹\C\Lib\C\stm8s_clk.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_clk.c
      4            * @author  MCD Application Team
      5            * @version V2.3.0
      6            * @date    16-June-2017
      7            * @brief   This file contains all the functions for the CLK peripheral.
      8             ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          
     30          #include "stm8s_clk.h"
     31          
     32          /** @addtogroup STM8S_StdPeriph_Driver
     33            * @{
     34            */
     35          /* Private typedef -----------------------------------------------------------*/
     36          /* Private define ------------------------------------------------------------*/
     37          /* Private macro -------------------------------------------------------------*/
     38          /* Private variables ---------------------------------------------------------*/
     39          /* Private function prototypes -----------------------------------------------*/
     40          
     41          /* Private Constants ---------------------------------------------------------*/
     42          
     43          /**
     44            * @addtogroup CLK_Private_Constants
     45            * @{
     46            */
     47          

   \                                 In section .near.rodata, align 1
     48          CONST uint8_t HSIDivFactor[4] = {1, 2, 4, 8}; /*!< Holds the different HSI Divider factors */
   \                     HSIDivFactor:
   \   000000 01 02 04 08  DC8 1, 2, 4, 8

   \                                 In section .near.rodata, align 1
     49          CONST uint8_t CLKPrescTable[8] = {1, 2, 4, 8, 10, 16, 20, 40}; /*!< Holds the different CLK prescaler values */
   \                     CLKPrescTable:
   \   000000 01 02 04 08  DC8 1, 2, 4, 8, 10, 16, 20, 40
   \          0A 10 14 28 
     50          
     51          /**
     52            * @}
     53            */
     54          
     55          /* Public functions ----------------------------------------------------------*/
     56          /**
     57            * @addtogroup CLK_Public_Functions
     58            * @{
     59            */
     60          
     61          /**
     62            * @brief  Deinitializes the CLK peripheral registers to their default reset
     63            * values.
     64            * @param  None
     65            * @retval None
     66            * @par Warning:
     67            * Resetting the CCOR register: \n
     68            * When the CCOEN bit is set, the reset of the CCOR register require
     69            * two consecutive write instructions in order to reset first the CCOEN bit
     70            * and the second one is to reset the CCOSEL bits.
     71            */

   \                                 In section .far_func.text, align 1
     72          void CLK_DeInit(void)
     73          {
     74            CLK->ICKR = CLK_ICKR_RESET_VALUE;
   \                     CLK_DeInit:
   \   000000 35 01 50C0   MOV       L:0x50c0, #0x1
     75            CLK->ECKR = CLK_ECKR_RESET_VALUE;
   \   000004 725F 50C1    CLR       L:0x50c1
     76            CLK->SWR  = CLK_SWR_RESET_VALUE;
   \   000008 35 E1 50C4   MOV       L:0x50c4, #0xe1
     77            CLK->SWCR = CLK_SWCR_RESET_VALUE;
   \   00000C 725F 50C5    CLR       L:0x50c5
     78            CLK->CKDIVR = CLK_CKDIVR_RESET_VALUE;
   \   000010 35 18 50C6   MOV       L:0x50c6, #0x18
     79            CLK->PCKENR1 = CLK_PCKENR1_RESET_VALUE;
   \   000014 35 FF 50C7   MOV       L:0x50c7, #0xff
     80            CLK->PCKENR2 = CLK_PCKENR2_RESET_VALUE;
   \   000018 35 FF 50CA   MOV       L:0x50ca, #0xff
     81            CLK->CSSR = CLK_CSSR_RESET_VALUE;
   \   00001C 725F 50C8    CLR       L:0x50c8
     82            CLK->CCOR = CLK_CCOR_RESET_VALUE;
   \   000020 725F 50C9    CLR       L:0x50c9
     83            while ((CLK->CCOR & CLK_CCOR_CCOEN)!= 0)
   \                     ??CLK_DeInit_0:
   \   000024 7200 50C9 FB BTJT      L:0x50c9, #0x0, L:??CLK_DeInit_0
     84            {}
     85            CLK->CCOR = CLK_CCOR_RESET_VALUE;
   \   000029 725F 50C9    CLR       L:0x50c9
     86            CLK->HSITRIMR = CLK_HSITRIMR_RESET_VALUE;
   \   00002D 725F 50CC    CLR       L:0x50cc
     87            CLK->SWIMCCR = CLK_SWIMCCR_RESET_VALUE;
   \   000031 725F 50CD    CLR       L:0x50cd
     88          }
   \   000035 87           RETF
     89          
     90          /**
     91            * @brief   Configures the High Speed Internal oscillator (HSI).
     92            * @par Full description:
     93            * If CLK_FastHaltWakeup is enabled, HSI oscillator is automatically
     94            * switched-on (HSIEN=1) and selected as next clock master
     95            * (CKM=SWI=HSI) when resuming from HALT/ActiveHalt modes.\n
     96            * @param   NewState this parameter is the Wake-up Mode state.
     97            * @retval None
     98            */

   \                                 In section .far_func.text, align 1
     99          void CLK_FastHaltWakeUpCmd(FunctionalState NewState)
    100          {
   \                     CLK_FastHaltWakeUpCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    101            /* check the parameters */
    102            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??CLK_FastHaltWakeUpCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??CLK_FastHaltWakeUpCmd_0
   \   00000F AE 0066      LDW       X, #0x66
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    103            
    104            if (NewState != DISABLE)
   \                     ??CLK_FastHaltWakeUpCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??CLK_FastHaltWakeUpCmd_1
    105            {
    106              /* Set FHWU bit (HSI oscillator is automatically switched-on) */
    107              CLK->ICKR |= CLK_ICKR_FHWU;
   \   000022 7214 50C0    BSET      L:0x50c0, #0x2
   \   000026 20 04        JRA       L:??CLK_FastHaltWakeUpCmd_2
    108            }
    109            else  /* FastHaltWakeup = DISABLE */
    110            {
    111              /* Reset FHWU bit */
    112              CLK->ICKR &= (uint8_t)(~CLK_ICKR_FHWU);
   \                     ??CLK_FastHaltWakeUpCmd_1:
   \   000028 7215 50C0    BRES      L:0x50c0, #0x2
    113            }
    114          }
   \                     ??CLK_FastHaltWakeUpCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    115          
    116          /**
    117            * @brief  Enable or Disable the External High Speed oscillator (HSE).
    118            * @param   NewState new state of HSEEN, value accepted ENABLE, DISABLE.
    119            * @retval None
    120            */

   \                                 In section .far_func.text, align 1
    121          void CLK_HSECmd(FunctionalState NewState)
    122          {
   \                     CLK_HSECmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    123            /* Check the parameters */
    124            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??CLK_HSECmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??CLK_HSECmd_0
   \   00000F AE 007C      LDW       X, #0x7c
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    125            
    126            if (NewState != DISABLE)
   \                     ??CLK_HSECmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??CLK_HSECmd_1
    127            {
    128              /* Set HSEEN bit */
    129              CLK->ECKR |= CLK_ECKR_HSEEN;
   \   000022 7210 50C1    BSET      L:0x50c1, #0x0
   \   000026 20 04        JRA       L:??CLK_HSECmd_2
    130            }
    131            else
    132            {
    133              /* Reset HSEEN bit */
    134              CLK->ECKR &= (uint8_t)(~CLK_ECKR_HSEEN);
   \                     ??CLK_HSECmd_1:
   \   000028 7211 50C1    BRES      L:0x50c1, #0x0
    135            }
    136          }
   \                     ??CLK_HSECmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    137          
    138          /**
    139            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    140            * @param   NewState new state of HSIEN, value accepted ENABLE, DISABLE.
    141            * @retval None
    142            */

   \                                 In section .far_func.text, align 1
    143          void CLK_HSICmd(FunctionalState NewState)
    144          {
   \                     CLK_HSICmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    145            /* Check the parameters */
    146            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??CLK_HSICmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??CLK_HSICmd_0
   \   00000F AE 0092      LDW       X, #0x92
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    147            
    148            if (NewState != DISABLE)
   \                     ??CLK_HSICmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??CLK_HSICmd_1
    149            {
    150              /* Set HSIEN bit */
    151              CLK->ICKR |= CLK_ICKR_HSIEN;
   \   000022 7210 50C0    BSET      L:0x50c0, #0x0
   \   000026 20 04        JRA       L:??CLK_HSICmd_2
    152            }
    153            else
    154            {
    155              /* Reset HSIEN bit */
    156              CLK->ICKR &= (uint8_t)(~CLK_ICKR_HSIEN);
   \                     ??CLK_HSICmd_1:
   \   000028 7211 50C0    BRES      L:0x50c0, #0x0
    157            }
    158          }
   \                     ??CLK_HSICmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    159          
    160          /**
    161            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    162            * @param  NewState new state of LSIEN, value accepted ENABLE, DISABLE.
    163            * @note   Before using the LSI clock you have to enable the option bytes (LSI_EN option bit is set).
    164            * @retval None
    165            */

   \                                 In section .far_func.text, align 1
    166          void CLK_LSICmd(FunctionalState NewState)
    167          {
   \                     CLK_LSICmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    168            /* Check the parameters */
    169            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??CLK_LSICmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??CLK_LSICmd_0
   \   00000F AE 00A9      LDW       X, #0xa9
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    170            
    171            if (NewState != DISABLE)
   \                     ??CLK_LSICmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??CLK_LSICmd_1
    172            {
    173              /* Set LSIEN bit */
    174              CLK->ICKR |= CLK_ICKR_LSIEN;
   \   000022 7216 50C0    BSET      L:0x50c0, #0x3
   \   000026 20 04        JRA       L:??CLK_LSICmd_2
    175            }
    176            else
    177            {
    178              /* Reset LSIEN bit */
    179              CLK->ICKR &= (uint8_t)(~CLK_ICKR_LSIEN);
   \                     ??CLK_LSICmd_1:
   \   000028 7217 50C0    BRES      L:0x50c0, #0x3
    180            }
    181          }
   \                     ??CLK_LSICmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    182          
    183          /**
    184            * @brief  Enables or disablle the Configurable Clock Output (CCO).
    185            * @param   NewState : New state of CCEN bit (CCO register).
    186            * This parameter can be any of the @ref FunctionalState enumeration.
    187            * @retval None
    188            */

   \                                 In section .far_func.text, align 1
    189          void CLK_CCOCmd(FunctionalState NewState)
    190          {
   \                     CLK_CCOCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    191            /* Check the parameters */
    192            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??CLK_CCOCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??CLK_CCOCmd_0
   \   00000F AE 00C0      LDW       X, #0xc0
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    193            
    194            if (NewState != DISABLE)
   \                     ??CLK_CCOCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??CLK_CCOCmd_1
    195            {
    196              /* Set CCOEN bit */
    197              CLK->CCOR |= CLK_CCOR_CCOEN;
   \   000022 7210 50C9    BSET      L:0x50c9, #0x0
   \   000026 20 04        JRA       L:??CLK_CCOCmd_2
    198            }
    199            else
    200            {
    201              /* Reset CCOEN bit */
    202              CLK->CCOR &= (uint8_t)(~CLK_CCOR_CCOEN);
   \                     ??CLK_CCOCmd_1:
   \   000028 7211 50C9    BRES      L:0x50c9, #0x0
    203            }
    204          }
   \                     ??CLK_CCOCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    205          
    206          /**
    207            * @brief  Starts or Stops manually the clock switch execution.
    208            * @par Full description:
    209            * NewState parameter set the SWEN.
    210            * @param   NewState new state of SWEN, value accepted ENABLE, DISABLE.
    211            * @retval None
    212            */

   \                                 In section .far_func.text, align 1
    213          void CLK_ClockSwitchCmd(FunctionalState NewState)
    214          {
   \                     CLK_ClockSwitchCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    215            /* Check the parameters */
    216            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??CLK_ClockSwitchCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??CLK_ClockSwitchCmd_0
   \   00000F AE 00D8      LDW       X, #0xd8
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    217            
    218            if (NewState != DISABLE )
   \                     ??CLK_ClockSwitchCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??CLK_ClockSwitchCmd_1
    219            {
    220              /* Enable the Clock Switch */
    221              CLK->SWCR |= CLK_SWCR_SWEN;
   \   000022 7212 50C5    BSET      L:0x50c5, #0x1
   \   000026 20 04        JRA       L:??CLK_ClockSwitchCmd_2
    222            }
    223            else
    224            {
    225              /* Disable the Clock Switch */
    226              CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWEN);
   \                     ??CLK_ClockSwitchCmd_1:
   \   000028 7213 50C5    BRES      L:0x50c5, #0x1
    227            }
    228          }
   \                     ??CLK_ClockSwitchCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    229          
    230          /**
    231            * @brief  Configures the slow active halt wake up
    232            * @param   NewState: specifies the Slow Active Halt wake up state.
    233            * can be set of the following values:
    234            * - DISABLE: Slow Active Halt mode disabled;
    235            * - ENABLE:  Slow Active Halt mode enabled.
    236            * @retval None
    237            */

   \                                 In section .far_func.text, align 1
    238          void CLK_SlowActiveHaltWakeUpCmd(FunctionalState NewState)
    239          {
   \                     CLK_SlowActiveHaltWakeUpCmd:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    240            /* check the parameters */
    241            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??CLK_SlowActiveHaltWakeUpCmd_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??CLK_SlowActiveHaltWakeUpCmd_0
   \   00000F AE 00F1      LDW       X, #0xf1
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    242            
    243            if (NewState != DISABLE)
   \                     ??CLK_SlowActiveHaltWakeUpCmd_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??CLK_SlowActiveHaltWakeUpCmd_1
    244            {
    245              /* Set S_ACTHALT bit */
    246              CLK->ICKR |= CLK_ICKR_SWUAH;
   \   000022 721A 50C0    BSET      L:0x50c0, #0x5
   \   000026 20 04        JRA       L:??CLK_SlowActiveHaltWakeUpCmd_2
    247            }
    248            else
    249            {
    250              /* Reset S_ACTHALT bit */
    251              CLK->ICKR &= (uint8_t)(~CLK_ICKR_SWUAH);
   \                     ??CLK_SlowActiveHaltWakeUpCmd_1:
   \   000028 721B 50C0    BRES      L:0x50c0, #0x5
    252            }
    253          }
   \                     ??CLK_SlowActiveHaltWakeUpCmd_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    254          
    255          /**
    256            * @brief   Enables or disables the specified peripheral CLK.
    257            * @param   CLK_Peripheral : This parameter specifies the peripheral clock to gate.
    258            * This parameter can be any of the  @ref CLK_Peripheral_TypeDef enumeration.
    259            * @param   NewState : New state of specified peripheral clock.
    260            * This parameter can be any of the @ref FunctionalState enumeration.
    261            * @retval None
    262            */

   \                                 In section .far_func.text, align 1
    263          void CLK_PeripheralClockConfig(CLK_Peripheral_TypeDef CLK_Peripheral, FunctionalState NewState)
    264          {
   \                     CLK_PeripheralClockConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
   \   000006 45 .. ..     MOV       S:?b8, S:?b0
    265            /* Check the parameters */
    266            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000009 3D ..        TNZ       S:?b8
   \   00000B 27 15        JREQ      L:??CLK_PeripheralClockConfig_0
   \   00000D B6 ..        LD        A, S:?b8
   \   00000F A1 01        CP        A, #0x1
   \   000011 27 0F        JREQ      L:??CLK_PeripheralClockConfig_0
   \   000013 AE 010A      LDW       X, #0x10a
   \   000016 BF ..        LDW       S:?w1, X
   \   000018 5F           CLRW      X
   \   000019 BF ..        LDW       S:?w0, X
   \   00001B AE ....      LDW       X, #?_0
   \   00001E 8D ......    CALLF     assert_failed
    267            assert_param(IS_CLK_PERIPHERAL_OK(CLK_Peripheral));
   \                     ??CLK_PeripheralClockConfig_0:
   \   000022 3D ..        TNZ       S:?b9
   \   000024 27 5D        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000026 B6 ..        LD        A, S:?b9
   \   000028 A1 01        CP        A, #0x1
   \   00002A 27 57        JREQ      L:??CLK_PeripheralClockConfig_1
   \   00002C B6 ..        LD        A, S:?b9
   \   00002E A1 03        CP        A, #0x3
   \   000030 27 51        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000032 B6 ..        LD        A, S:?b9
   \   000034 A1 03        CP        A, #0x3
   \   000036 27 4B        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000038 B6 ..        LD        A, S:?b9
   \   00003A A1 03        CP        A, #0x3
   \   00003C 27 45        JREQ      L:??CLK_PeripheralClockConfig_1
   \   00003E B6 ..        LD        A, S:?b9
   \   000040 A1 04        CP        A, #0x4
   \   000042 27 3F        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000044 B6 ..        LD        A, S:?b9
   \   000046 A1 05        CP        A, #0x5
   \   000048 27 39        JREQ      L:??CLK_PeripheralClockConfig_1
   \   00004A B6 ..        LD        A, S:?b9
   \   00004C A1 05        CP        A, #0x5
   \   00004E 27 33        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000050 B6 ..        LD        A, S:?b9
   \   000052 A1 04        CP        A, #0x4
   \   000054 27 2D        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000056 B6 ..        LD        A, S:?b9
   \   000058 A1 06        CP        A, #0x6
   \   00005A 27 27        JREQ      L:??CLK_PeripheralClockConfig_1
   \   00005C B6 ..        LD        A, S:?b9
   \   00005E A1 07        CP        A, #0x7
   \   000060 27 21        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000062 B6 ..        LD        A, S:?b9
   \   000064 A1 17        CP        A, #0x17
   \   000066 27 1B        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000068 B6 ..        LD        A, S:?b9
   \   00006A A1 13        CP        A, #0x13
   \   00006C 27 15        JREQ      L:??CLK_PeripheralClockConfig_1
   \   00006E B6 ..        LD        A, S:?b9
   \   000070 A1 12        CP        A, #0x12
   \   000072 27 0F        JREQ      L:??CLK_PeripheralClockConfig_1
   \   000074 AE 010B      LDW       X, #0x10b
   \   000077 BF ..        LDW       S:?w1, X
   \   000079 5F           CLRW      X
   \   00007A BF ..        LDW       S:?w0, X
   \   00007C AE ....      LDW       X, #?_0
   \   00007F 8D ......    CALLF     assert_failed
    268            
    269            if (((uint8_t)CLK_Peripheral & (uint8_t)0x10) == 0x00)
   \                     ??CLK_PeripheralClockConfig_1:
   \   000083 B6 ..        LD        A, S:?b9
   \   000085 A4 10        AND       A, #0x10
   \   000087 A1 00        CP        A, #0x0
   \   000089 26 2B        JRNE      L:??CLK_PeripheralClockConfig_2
    270            {
    271              if (NewState != DISABLE)
   \   00008B 3D ..        TNZ       S:?b8
   \   00008D 27 13        JREQ      L:??CLK_PeripheralClockConfig_3
    272              {
    273                /* Enable the peripheral Clock */
    274                CLK->PCKENR1 |= (uint8_t)((uint8_t)1 << ((uint8_t)CLK_Peripheral & (uint8_t)0x0F));
   \   00008F B6 ..        LD        A, S:?b9
   \   000091 A4 0F        AND       A, #0xf
   \   000093 5F           CLRW      X
   \   000094 5C           INCW      X
   \   000095 8D ......    CALLF     L:?sll16_x_x_a
   \   000099 9F           LD        A, XL
   \   00009A CA 50C7      OR        A, L:0x50c7
   \   00009D C7 50C7      LD        L:0x50c7, A
   \   0000A0 20 3D        JRA       L:??CLK_PeripheralClockConfig_4
    275              }
    276              else
    277              {
    278                /* Disable the peripheral Clock */
    279                CLK->PCKENR1 &= (uint8_t)(~(uint8_t)(((uint8_t)1 << ((uint8_t)CLK_Peripheral & (uint8_t)0x0F))));
   \                     ??CLK_PeripheralClockConfig_3:
   \   0000A2 B6 ..        LD        A, S:?b9
   \   0000A4 A4 0F        AND       A, #0xf
   \   0000A6 5F           CLRW      X
   \   0000A7 5C           INCW      X
   \   0000A8 8D ......    CALLF     L:?sll16_x_x_a
   \   0000AC 9F           LD        A, XL
   \   0000AD 43           CPL       A
   \   0000AE C4 50C7      AND       A, L:0x50c7
   \   0000B1 C7 50C7      LD        L:0x50c7, A
   \   0000B4 20 29        JRA       L:??CLK_PeripheralClockConfig_4
    280              }
    281            }
    282            else
    283            {
    284              if (NewState != DISABLE)
   \                     ??CLK_PeripheralClockConfig_2:
   \   0000B6 3D ..        TNZ       S:?b8
   \   0000B8 27 13        JREQ      L:??CLK_PeripheralClockConfig_5
    285              {
    286                /* Enable the peripheral Clock */
    287                CLK->PCKENR2 |= (uint8_t)((uint8_t)1 << ((uint8_t)CLK_Peripheral & (uint8_t)0x0F));
   \   0000BA B6 ..        LD        A, S:?b9
   \   0000BC A4 0F        AND       A, #0xf
   \   0000BE 5F           CLRW      X
   \   0000BF 5C           INCW      X
   \   0000C0 8D ......    CALLF     L:?sll16_x_x_a
   \   0000C4 9F           LD        A, XL
   \   0000C5 CA 50CA      OR        A, L:0x50ca
   \   0000C8 C7 50CA      LD        L:0x50ca, A
   \   0000CB 20 12        JRA       L:??CLK_PeripheralClockConfig_4
    288              }
    289              else
    290              {
    291                /* Disable the peripheral Clock */
    292                CLK->PCKENR2 &= (uint8_t)(~(uint8_t)(((uint8_t)1 << ((uint8_t)CLK_Peripheral & (uint8_t)0x0F))));
   \                     ??CLK_PeripheralClockConfig_5:
   \   0000CD B6 ..        LD        A, S:?b9
   \   0000CF A4 0F        AND       A, #0xf
   \   0000D1 5F           CLRW      X
   \   0000D2 5C           INCW      X
   \   0000D3 8D ......    CALLF     L:?sll16_x_x_a
   \   0000D7 9F           LD        A, XL
   \   0000D8 43           CPL       A
   \   0000D9 C4 50CA      AND       A, L:0x50ca
   \   0000DC C7 50CA      LD        L:0x50ca, A
    293              }
    294            }
    295          }
   \                     ??CLK_PeripheralClockConfig_4:
   \   0000DF AC ......    JPF       L:?epilogue_w4
    296          
    297          /**
    298            * @brief  configures the Switch from one clock to another
    299            * @param   CLK_SwitchMode select the clock switch mode.
    300            * It can be set of the values of @ref CLK_SwitchMode_TypeDef
    301            * @param   CLK_NewClock choice of the future clock.
    302            * It can be set of the values of @ref CLK_Source_TypeDef
    303            * @param   ITState Enable or Disable the Clock Switch interrupt.
    304            * @param   CLK_CurrentClockState current clock to switch OFF or to keep ON.
    305            * It can be set of the values of @ref CLK_CurrentClockState_TypeDef
    306            * @note LSI selected as master clock source only if LSI_EN option bit is set.
    307            * @retval ErrorStatus this shows the clock switch status (ERROR/SUCCESS).
    308            */

   \                                 In section .far_func.text, align 1
    309          ErrorStatus CLK_ClockSwitchConfig(CLK_SwitchMode_TypeDef CLK_SwitchMode, CLK_Source_TypeDef CLK_NewClock, FunctionalState ITState, CLK_CurrentClockState_TypeDef CLK_CurrentClockState)
    310          {
   \                     CLK_ClockSwitchConfig:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 B7 ..        LD        S:?b13, A
   \   00000A 45 .. ..     MOV       S:?b12, S:?b0
   \   00000D 45 .. ..     MOV       S:?b11, S:?b1
   \   000010 45 .. ..     MOV       S:?b10, S:?b2
    311            CLK_Source_TypeDef clock_master;
    312            uint16_t DownCounter = CLK_TIMEOUT;
   \   000013 5F           CLRW      X
   \   000014 5A           DECW      X
   \   000015 BF ..        LDW       S:?w4, X
    313            ErrorStatus Swif = ERROR;
   \   000017 3F ..        CLR       S:?b14
    314            
    315            /* Check the parameters */
    316            assert_param(IS_CLK_SOURCE_OK(CLK_NewClock));
   \   000019 B6 ..        LD        A, S:?b12
   \   00001B A1 E1        CP        A, #0xe1
   \   00001D 27 1B        JREQ      L:??CLK_ClockSwitchConfig_0
   \   00001F B6 ..        LD        A, S:?b12
   \   000021 A1 D2        CP        A, #0xd2
   \   000023 27 15        JREQ      L:??CLK_ClockSwitchConfig_0
   \   000025 B6 ..        LD        A, S:?b12
   \   000027 A1 B4        CP        A, #0xb4
   \   000029 27 0F        JREQ      L:??CLK_ClockSwitchConfig_0
   \   00002B AE 013C      LDW       X, #0x13c
   \   00002E BF ..        LDW       S:?w1, X
   \   000030 5F           CLRW      X
   \   000031 BF ..        LDW       S:?w0, X
   \   000033 AE ....      LDW       X, #?_0
   \   000036 8D ......    CALLF     assert_failed
    317            assert_param(IS_CLK_SWITCHMODE_OK(CLK_SwitchMode));
   \                     ??CLK_ClockSwitchConfig_0:
   \   00003A 3D ..        TNZ       S:?b13
   \   00003C 27 15        JREQ      L:??CLK_ClockSwitchConfig_1
   \   00003E B6 ..        LD        A, S:?b13
   \   000040 A1 01        CP        A, #0x1
   \   000042 27 0F        JREQ      L:??CLK_ClockSwitchConfig_1
   \   000044 AE 013D      LDW       X, #0x13d
   \   000047 BF ..        LDW       S:?w1, X
   \   000049 5F           CLRW      X
   \   00004A BF ..        LDW       S:?w0, X
   \   00004C AE ....      LDW       X, #?_0
   \   00004F 8D ......    CALLF     assert_failed
    318            assert_param(IS_FUNCTIONALSTATE_OK(ITState));
   \                     ??CLK_ClockSwitchConfig_1:
   \   000053 3D ..        TNZ       S:?b11
   \   000055 27 15        JREQ      L:??CLK_ClockSwitchConfig_2
   \   000057 B6 ..        LD        A, S:?b11
   \   000059 A1 01        CP        A, #0x1
   \   00005B 27 0F        JREQ      L:??CLK_ClockSwitchConfig_2
   \   00005D AE 013E      LDW       X, #0x13e
   \   000060 BF ..        LDW       S:?w1, X
   \   000062 5F           CLRW      X
   \   000063 BF ..        LDW       S:?w0, X
   \   000065 AE ....      LDW       X, #?_0
   \   000068 8D ......    CALLF     assert_failed
    319            assert_param(IS_CLK_CURRENTCLOCKSTATE_OK(CLK_CurrentClockState));
   \                     ??CLK_ClockSwitchConfig_2:
   \   00006C 3D ..        TNZ       S:?b10
   \   00006E 27 15        JREQ      L:??CLK_ClockSwitchConfig_3
   \   000070 B6 ..        LD        A, S:?b10
   \   000072 A1 01        CP        A, #0x1
   \   000074 27 0F        JREQ      L:??CLK_ClockSwitchConfig_3
   \   000076 AE 013F      LDW       X, #0x13f
   \   000079 BF ..        LDW       S:?w1, X
   \   00007B 5F           CLRW      X
   \   00007C BF ..        LDW       S:?w0, X
   \   00007E AE ....      LDW       X, #?_0
   \   000081 8D ......    CALLF     assert_failed
    320            
    321            /* Current clock master saving */
    322            clock_master = (CLK_Source_TypeDef)CLK->CMSR;
   \                     ??CLK_ClockSwitchConfig_3:
   \   000085 C6 50C3      LD        A, L:0x50c3
   \   000088 B7 ..        LD        S:?b15, A
    323            
    324            /* Automatic switch mode management */
    325            if (CLK_SwitchMode == CLK_SWITCHMODE_AUTO)
   \   00008A B6 ..        LD        A, S:?b13
   \   00008C A1 01        CP        A, #0x1
   \   00008E 26 37        JRNE      L:??CLK_ClockSwitchConfig_4
    326            {
    327              /* Enables Clock switch */
    328              CLK->SWCR |= CLK_SWCR_SWEN;
   \   000090 7212 50C5    BSET      L:0x50c5, #0x1
    329              
    330              /* Enables or Disables Switch interrupt */
    331              if (ITState != DISABLE)
   \   000094 3D ..        TNZ       S:?b11
   \   000096 27 06        JREQ      L:??CLK_ClockSwitchConfig_5
    332              {
    333                CLK->SWCR |= CLK_SWCR_SWIEN;
   \   000098 7214 50C5    BSET      L:0x50c5, #0x2
   \   00009C 20 04        JRA       L:??CLK_ClockSwitchConfig_6
    334              }
    335              else
    336              {
    337                CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWIEN);
   \                     ??CLK_ClockSwitchConfig_5:
   \   00009E 7215 50C5    BRES      L:0x50c5, #0x2
    338              }
    339              
    340              /* Selection of the target clock source */
    341              CLK->SWR = (uint8_t)CLK_NewClock;
   \                     ??CLK_ClockSwitchConfig_6:
   \   0000A2 B6 ..        LD        A, S:?b12
   \   0000A4 C7 50C4      LD        L:0x50c4, A
    342              
    343              /* Wait until the target clock source is ready */
    344              while((((CLK->SWCR & CLK_SWCR_SWBSY) != 0 )&& (DownCounter != 0)))
   \                     ??CLK_ClockSwitchConfig_7:
   \   0000A7 7201 50C5 0C BTJF      L:0x50c5, #0x0, L:??CLK_ClockSwitchConfig_8
   \   0000AC BE ..        LDW       X, S:?w4
   \   0000AE 5D           TNZW      X
   \   0000AF 27 07        JREQ      L:??CLK_ClockSwitchConfig_8
    345              {
    346                DownCounter--;
   \   0000B1 BE ..        LDW       X, S:?w4
   \   0000B3 5A           DECW      X
   \   0000B4 BF ..        LDW       S:?w4, X
   \   0000B6 20 EF        JRA       L:??CLK_ClockSwitchConfig_7
    347              }
    348              
    349              if(DownCounter != 0)
   \                     ??CLK_ClockSwitchConfig_8:
   \   0000B8 BE ..        LDW       X, S:?w4
   \   0000BA 5D           TNZW      X
   \   0000BB 27 06        JREQ      L:??CLK_ClockSwitchConfig_9
    350              {
    351                Swif = SUCCESS;
   \   0000BD A6 01        LD        A, #0x1
   \   0000BF B7 ..        LD        S:?b14, A
   \   0000C1 20 39        JRA       L:??CLK_ClockSwitchConfig_10
    352              }
    353              else
    354              {
    355                Swif = ERROR;
   \                     ??CLK_ClockSwitchConfig_9:
   \   0000C3 3F ..        CLR       S:?b14
   \   0000C5 20 35        JRA       L:??CLK_ClockSwitchConfig_10
    356              }
    357            }
    358            else /* CLK_SwitchMode == CLK_SWITCHMODE_MANUAL */
    359            {
    360              /* Enables or Disables Switch interrupt  if required  */
    361              if (ITState != DISABLE)
   \                     ??CLK_ClockSwitchConfig_4:
   \   0000C7 3D ..        TNZ       S:?b11
   \   0000C9 27 06        JREQ      L:??CLK_ClockSwitchConfig_11
    362              {
    363                CLK->SWCR |= CLK_SWCR_SWIEN;
   \   0000CB 7214 50C5    BSET      L:0x50c5, #0x2
   \   0000CF 20 04        JRA       L:??CLK_ClockSwitchConfig_12
    364              }
    365              else
    366              {
    367                CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWIEN);
   \                     ??CLK_ClockSwitchConfig_11:
   \   0000D1 7215 50C5    BRES      L:0x50c5, #0x2
    368              }
    369              
    370              /* Selection of the target clock source */
    371              CLK->SWR = (uint8_t)CLK_NewClock;
   \                     ??CLK_ClockSwitchConfig_12:
   \   0000D5 B6 ..        LD        A, S:?b12
   \   0000D7 C7 50C4      LD        L:0x50c4, A
    372              
    373              /* Wait until the target clock source is ready */
    374              while((((CLK->SWCR & CLK_SWCR_SWIF) != 0 ) && (DownCounter != 0)))
   \                     ??CLK_ClockSwitchConfig_13:
   \   0000DA 7207 50C5 0C BTJF      L:0x50c5, #0x3, L:??CLK_ClockSwitchConfig_14
   \   0000DF BE ..        LDW       X, S:?w4
   \   0000E1 5D           TNZW      X
   \   0000E2 27 07        JREQ      L:??CLK_ClockSwitchConfig_14
    375              {
    376                DownCounter--;
   \   0000E4 BE ..        LDW       X, S:?w4
   \   0000E6 5A           DECW      X
   \   0000E7 BF ..        LDW       S:?w4, X
   \   0000E9 20 EF        JRA       L:??CLK_ClockSwitchConfig_13
    377              }
    378              
    379              if(DownCounter != 0)
   \                     ??CLK_ClockSwitchConfig_14:
   \   0000EB BE ..        LDW       X, S:?w4
   \   0000ED 5D           TNZW      X
   \   0000EE 27 0A        JREQ      L:??CLK_ClockSwitchConfig_15
    380              {
    381                /* Enables Clock switch */
    382                CLK->SWCR |= CLK_SWCR_SWEN;
   \   0000F0 7212 50C5    BSET      L:0x50c5, #0x1
    383                Swif = SUCCESS;
   \   0000F4 A6 01        LD        A, #0x1
   \   0000F6 B7 ..        LD        S:?b14, A
   \   0000F8 20 02        JRA       L:??CLK_ClockSwitchConfig_10
    384              }
    385              else
    386              {
    387                Swif = ERROR;
   \                     ??CLK_ClockSwitchConfig_15:
   \   0000FA 3F ..        CLR       S:?b14
    388              }
    389            }
    390            if(Swif != ERROR)
   \                     ??CLK_ClockSwitchConfig_10:
   \   0000FC 3D ..        TNZ       S:?b14
   \   0000FE 27 2E        JREQ      L:??CLK_ClockSwitchConfig_16
    391            {
    392              /* Switch OFF current clock if required */
    393              if((CLK_CurrentClockState == CLK_CURRENTCLOCKSTATE_DISABLE) && ( clock_master == CLK_SOURCE_HSI))
   \   000100 3D ..        TNZ       S:?b10
   \   000102 26 0C        JRNE      L:??CLK_ClockSwitchConfig_17
   \   000104 B6 ..        LD        A, S:?b15
   \   000106 A1 E1        CP        A, #0xe1
   \   000108 26 06        JRNE      L:??CLK_ClockSwitchConfig_17
    394              {
    395                CLK->ICKR &= (uint8_t)(~CLK_ICKR_HSIEN);
   \   00010A 7211 50C0    BRES      L:0x50c0, #0x0
   \   00010E 20 1E        JRA       L:??CLK_ClockSwitchConfig_16
    396              }
    397              else if((CLK_CurrentClockState == CLK_CURRENTCLOCKSTATE_DISABLE) && ( clock_master == CLK_SOURCE_LSI))
   \                     ??CLK_ClockSwitchConfig_17:
   \   000110 3D ..        TNZ       S:?b10
   \   000112 26 0C        JRNE      L:??CLK_ClockSwitchConfig_18
   \   000114 B6 ..        LD        A, S:?b15
   \   000116 A1 D2        CP        A, #0xd2
   \   000118 26 06        JRNE      L:??CLK_ClockSwitchConfig_18
    398              {
    399                CLK->ICKR &= (uint8_t)(~CLK_ICKR_LSIEN);
   \   00011A 7217 50C0    BRES      L:0x50c0, #0x3
   \   00011E 20 0E        JRA       L:??CLK_ClockSwitchConfig_16
    400              }
    401              else if ((CLK_CurrentClockState == CLK_CURRENTCLOCKSTATE_DISABLE) && ( clock_master == CLK_SOURCE_HSE))
   \                     ??CLK_ClockSwitchConfig_18:
   \   000120 3D ..        TNZ       S:?b10
   \   000122 26 0A        JRNE      L:??CLK_ClockSwitchConfig_16
   \   000124 B6 ..        LD        A, S:?b15
   \   000126 A1 B4        CP        A, #0xb4
   \   000128 26 04        JRNE      L:??CLK_ClockSwitchConfig_16
    402              {
    403                CLK->ECKR &= (uint8_t)(~CLK_ECKR_HSEEN);
   \   00012A 7211 50C1    BRES      L:0x50c1, #0x0
    404              }
    405            }
    406            return(Swif);
   \                     ??CLK_ClockSwitchConfig_16:
   \   00012E B6 ..        LD        A, S:?b14
   \   000130 AC ......    JPF       L:?epilogue_l2_l3
    407          }
    408          
    409          /**
    410            * @brief  Configures the HSI clock dividers.
    411            * @param   HSIPrescaler : Specifies the HSI clock divider to apply.
    412            * This parameter can be any of the @ref CLK_Prescaler_TypeDef enumeration.
    413            * @retval None
    414            */

   \                                 In section .far_func.text, align 1
    415          void CLK_HSIPrescalerConfig(CLK_Prescaler_TypeDef HSIPrescaler)
    416          {
   \                     CLK_HSIPrescalerConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    417            /* check the parameters */
    418            assert_param(IS_CLK_HSIPRESCALER_OK(HSIPrescaler));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 21        JREQ      L:??CLK_HSIPrescalerConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 08        CP        A, #0x8
   \   00000D 27 1B        JREQ      L:??CLK_HSIPrescalerConfig_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 10        CP        A, #0x10
   \   000013 27 15        JREQ      L:??CLK_HSIPrescalerConfig_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 18        CP        A, #0x18
   \   000019 27 0F        JREQ      L:??CLK_HSIPrescalerConfig_0
   \   00001B AE 01A2      LDW       X, #0x1a2
   \   00001E BF ..        LDW       S:?w1, X
   \   000020 5F           CLRW      X
   \   000021 BF ..        LDW       S:?w0, X
   \   000023 AE ....      LDW       X, #?_0
   \   000026 8D ......    CALLF     assert_failed
    419            
    420            /* Clear High speed internal clock prescaler */
    421            CLK->CKDIVR &= (uint8_t)(~CLK_CKDIVR_HSIDIV);
   \                     ??CLK_HSIPrescalerConfig_0:
   \   00002A C6 50C6      LD        A, L:0x50c6
   \   00002D A4 E7        AND       A, #0xe7
   \   00002F C7 50C6      LD        L:0x50c6, A
    422            
    423            /* Set High speed internal clock prescaler */
    424            CLK->CKDIVR |= (uint8_t)HSIPrescaler;
   \   000032 C6 50C6      LD        A, L:0x50c6
   \   000035 BA ..        OR        A, S:?b8
   \   000037 C7 50C6      LD        L:0x50c6, A
    425          }
   \   00003A 32 ....      POP       S:?b8
   \   00003D 87           RETF
    426          
    427          /**
    428            * @brief  Output the selected clock on a dedicated I/O pin.
    429            * @param   CLK_CCO : Specifies the clock source.
    430            * This parameter can be any of the  @ref CLK_Output_TypeDef enumeration.
    431            * @retval None
    432            * @par Required preconditions:
    433            * The dedicated I/O pin must be set at 1 in the corresponding Px_CR1 register \n
    434            * to be set as input with pull-up or push-pull output.
    435            */

   \                                 In section .far_func.text, align 1
    436          void CLK_CCOConfig(CLK_Output_TypeDef CLK_CCO)
    437          {
   \                     CLK_CCOConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    438            /* check the parameters */
    439            assert_param(IS_CLK_OUTPUT_OK(CLK_CCO));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 57        JREQ      L:??CLK_CCOConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 04        CP        A, #0x4
   \   00000D 27 51        JREQ      L:??CLK_CCOConfig_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 02        CP        A, #0x2
   \   000013 27 4B        JREQ      L:??CLK_CCOConfig_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 08        CP        A, #0x8
   \   000019 27 45        JREQ      L:??CLK_CCOConfig_0
   \   00001B B6 ..        LD        A, S:?b8
   \   00001D A1 0A        CP        A, #0xa
   \   00001F 27 3F        JREQ      L:??CLK_CCOConfig_0
   \   000021 B6 ..        LD        A, S:?b8
   \   000023 A1 0C        CP        A, #0xc
   \   000025 27 39        JREQ      L:??CLK_CCOConfig_0
   \   000027 B6 ..        LD        A, S:?b8
   \   000029 A1 0E        CP        A, #0xe
   \   00002B 27 33        JREQ      L:??CLK_CCOConfig_0
   \   00002D B6 ..        LD        A, S:?b8
   \   00002F A1 10        CP        A, #0x10
   \   000031 27 2D        JREQ      L:??CLK_CCOConfig_0
   \   000033 B6 ..        LD        A, S:?b8
   \   000035 A1 12        CP        A, #0x12
   \   000037 27 27        JREQ      L:??CLK_CCOConfig_0
   \   000039 B6 ..        LD        A, S:?b8
   \   00003B A1 14        CP        A, #0x14
   \   00003D 27 21        JREQ      L:??CLK_CCOConfig_0
   \   00003F B6 ..        LD        A, S:?b8
   \   000041 A1 16        CP        A, #0x16
   \   000043 27 1B        JREQ      L:??CLK_CCOConfig_0
   \   000045 B6 ..        LD        A, S:?b8
   \   000047 A1 18        CP        A, #0x18
   \   000049 27 15        JREQ      L:??CLK_CCOConfig_0
   \   00004B B6 ..        LD        A, S:?b8
   \   00004D A1 1A        CP        A, #0x1a
   \   00004F 27 0F        JREQ      L:??CLK_CCOConfig_0
   \   000051 AE 01B7      LDW       X, #0x1b7
   \   000054 BF ..        LDW       S:?w1, X
   \   000056 5F           CLRW      X
   \   000057 BF ..        LDW       S:?w0, X
   \   000059 AE ....      LDW       X, #?_0
   \   00005C 8D ......    CALLF     assert_failed
    440            
    441            /* Clears of the CCO type bits part */
    442            CLK->CCOR &= (uint8_t)(~CLK_CCOR_CCOSEL);
   \                     ??CLK_CCOConfig_0:
   \   000060 C6 50C9      LD        A, L:0x50c9
   \   000063 A4 E1        AND       A, #0xe1
   \   000065 C7 50C9      LD        L:0x50c9, A
    443            
    444            /* Selects the source provided on cco_ck output */
    445            CLK->CCOR |= (uint8_t)CLK_CCO;
   \   000068 C6 50C9      LD        A, L:0x50c9
   \   00006B BA ..        OR        A, S:?b8
   \   00006D C7 50C9      LD        L:0x50c9, A
    446            
    447            /* Enable the clock output */
    448            CLK->CCOR |= CLK_CCOR_CCOEN;
   \   000070 7210 50C9    BSET      L:0x50c9, #0x0
    449          }
   \   000074 32 ....      POP       S:?b8
   \   000077 87           RETF
    450          
    451          /**
    452            * @brief   Enables or disables the specified CLK interrupts.
    453            * @param   CLK_IT This parameter specifies the interrupt sources.
    454            * It can be one of the values of @ref CLK_IT_TypeDef.
    455            * @param   NewState New state of the Interrupt.
    456            * Value accepted ENABLE, DISABLE.
    457            * @retval None
    458            */

   \                                 In section .far_func.text, align 1
    459          void CLK_ITConfig(CLK_IT_TypeDef CLK_IT, FunctionalState NewState)
    460          {
   \                     CLK_ITConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
   \   000006 45 .. ..     MOV       S:?b8, S:?b0
    461            /* check the parameters */
    462            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \   000009 3D ..        TNZ       S:?b8
   \   00000B 27 15        JREQ      L:??CLK_ITConfig_0
   \   00000D B6 ..        LD        A, S:?b8
   \   00000F A1 01        CP        A, #0x1
   \   000011 27 0F        JREQ      L:??CLK_ITConfig_0
   \   000013 AE 01CE      LDW       X, #0x1ce
   \   000016 BF ..        LDW       S:?w1, X
   \   000018 5F           CLRW      X
   \   000019 BF ..        LDW       S:?w0, X
   \   00001B AE ....      LDW       X, #?_0
   \   00001E 8D ......    CALLF     assert_failed
    463            assert_param(IS_CLK_IT_OK(CLK_IT));
   \                     ??CLK_ITConfig_0:
   \   000022 B6 ..        LD        A, S:?b9
   \   000024 A1 0C        CP        A, #0xc
   \   000026 27 15        JREQ      L:??CLK_ITConfig_1
   \   000028 B6 ..        LD        A, S:?b9
   \   00002A A1 1C        CP        A, #0x1c
   \   00002C 27 0F        JREQ      L:??CLK_ITConfig_1
   \   00002E AE 01CF      LDW       X, #0x1cf
   \   000031 BF ..        LDW       S:?w1, X
   \   000033 5F           CLRW      X
   \   000034 BF ..        LDW       S:?w0, X
   \   000036 AE ....      LDW       X, #?_0
   \   000039 8D ......    CALLF     assert_failed
    464            
    465            if (NewState != DISABLE)
   \                     ??CLK_ITConfig_1:
   \   00003D 3D ..        TNZ       S:?b8
   \   00003F 27 1A        JREQ      L:??CLK_ITConfig_2
    466            {
    467              switch (CLK_IT)
   \   000041 B6 ..        LD        A, S:?b9
   \   000043 A1 0C        CP        A, #0xc
   \   000045 27 0C        JREQ      L:??CLK_ITConfig_3
   \   000047 A1 1C        CP        A, #0x1c
   \   000049 27 02        JREQ      L:??CLK_ITConfig_4
   \   00004B 20 0C        JRA       L:??CLK_ITConfig_5
    468              {
    469              case CLK_IT_SWIF: /* Enable the clock switch interrupt */
    470                CLK->SWCR |= CLK_SWCR_SWIEN;
   \                     ??CLK_ITConfig_4:
   \   00004D 7214 50C5    BSET      L:0x50c5, #0x2
    471                break;
   \   000051 20 20        JRA       L:??CLK_ITConfig_6
    472              case CLK_IT_CSSD: /* Enable the clock security system detection interrupt */
    473                CLK->CSSR |= CLK_CSSR_CSSDIE;
   \                     ??CLK_ITConfig_3:
   \   000053 7214 50C8    BSET      L:0x50c8, #0x2
    474                break;
   \   000057 20 1A        JRA       L:??CLK_ITConfig_6
    475              default:
    476                break;
   \                     ??CLK_ITConfig_5:
   \   000059 20 18        JRA       L:??CLK_ITConfig_6
    477              }
    478            }
    479            else  /*(NewState == DISABLE)*/
    480            {
    481              switch (CLK_IT)
   \                     ??CLK_ITConfig_2:
   \   00005B B6 ..        LD        A, S:?b9
   \   00005D A1 0C        CP        A, #0xc
   \   00005F 27 0C        JREQ      L:??CLK_ITConfig_7
   \   000061 A1 1C        CP        A, #0x1c
   \   000063 27 02        JREQ      L:??CLK_ITConfig_8
   \   000065 20 0C        JRA       L:??CLK_ITConfig_9
    482              {
    483              case CLK_IT_SWIF: /* Disable the clock switch interrupt */
    484                CLK->SWCR  &= (uint8_t)(~CLK_SWCR_SWIEN);
   \                     ??CLK_ITConfig_8:
   \   000067 7215 50C5    BRES      L:0x50c5, #0x2
    485                break;
   \   00006B 20 06        JRA       L:??CLK_ITConfig_6
    486              case CLK_IT_CSSD: /* Disable the clock security system detection interrupt */
    487                CLK->CSSR &= (uint8_t)(~CLK_CSSR_CSSDIE);
   \                     ??CLK_ITConfig_7:
   \   00006D 7215 50C8    BRES      L:0x50c8, #0x2
    488                break;
   \   000071 20 00        JRA       L:??CLK_ITConfig_6
    489              default:
    490                break;
    491              }
    492            }
    493          }
   \                     ??CLK_ITConfig_9:
   \                     ??CLK_ITConfig_6:
   \   000073 AC ......    JPF       L:?epilogue_w4
    494          
    495          /**
    496            * @brief  Configures the HSI and CPU clock dividers.
    497            * @param  CLK_Prescaler Specifies the HSI or CPU clock divider to apply.
    498            * @retval None
    499            */

   \                                 In section .far_func.text, align 1
    500          void CLK_SYSCLKConfig(CLK_Prescaler_TypeDef CLK_Prescaler)
    501          {
   \                     CLK_SYSCLKConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    502            /* check the parameters */
    503            assert_param(IS_CLK_PRESCALER_OK(CLK_Prescaler));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 51        JREQ      L:??CLK_SYSCLKConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 08        CP        A, #0x8
   \   00000D 27 4B        JREQ      L:??CLK_SYSCLKConfig_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 10        CP        A, #0x10
   \   000013 27 45        JREQ      L:??CLK_SYSCLKConfig_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 18        CP        A, #0x18
   \   000019 27 3F        JREQ      L:??CLK_SYSCLKConfig_0
   \   00001B B6 ..        LD        A, S:?b8
   \   00001D A1 80        CP        A, #0x80
   \   00001F 27 39        JREQ      L:??CLK_SYSCLKConfig_0
   \   000021 B6 ..        LD        A, S:?b8
   \   000023 A1 81        CP        A, #0x81
   \   000025 27 33        JREQ      L:??CLK_SYSCLKConfig_0
   \   000027 B6 ..        LD        A, S:?b8
   \   000029 A1 82        CP        A, #0x82
   \   00002B 27 2D        JREQ      L:??CLK_SYSCLKConfig_0
   \   00002D B6 ..        LD        A, S:?b8
   \   00002F A1 83        CP        A, #0x83
   \   000031 27 27        JREQ      L:??CLK_SYSCLKConfig_0
   \   000033 B6 ..        LD        A, S:?b8
   \   000035 A1 84        CP        A, #0x84
   \   000037 27 21        JREQ      L:??CLK_SYSCLKConfig_0
   \   000039 B6 ..        LD        A, S:?b8
   \   00003B A1 85        CP        A, #0x85
   \   00003D 27 1B        JREQ      L:??CLK_SYSCLKConfig_0
   \   00003F B6 ..        LD        A, S:?b8
   \   000041 A1 86        CP        A, #0x86
   \   000043 27 15        JREQ      L:??CLK_SYSCLKConfig_0
   \   000045 B6 ..        LD        A, S:?b8
   \   000047 A1 87        CP        A, #0x87
   \   000049 27 0F        JREQ      L:??CLK_SYSCLKConfig_0
   \   00004B AE 01F7      LDW       X, #0x1f7
   \   00004E BF ..        LDW       S:?w1, X
   \   000050 5F           CLRW      X
   \   000051 BF ..        LDW       S:?w0, X
   \   000053 AE ....      LDW       X, #?_0
   \   000056 8D ......    CALLF     assert_failed
    504            
    505            if (((uint8_t)CLK_Prescaler & (uint8_t)0x80) == 0x00) /* Bit7 = 0 means HSI divider */
   \                     ??CLK_SYSCLKConfig_0:
   \   00005A B6 ..        LD        A, S:?b8
   \   00005C A4 80        AND       A, #0x80
   \   00005E A1 00        CP        A, #0x0
   \   000060 26 14        JRNE      L:??CLK_SYSCLKConfig_1
    506            {
    507              CLK->CKDIVR &= (uint8_t)(~CLK_CKDIVR_HSIDIV);
   \   000062 C6 50C6      LD        A, L:0x50c6
   \   000065 A4 E7        AND       A, #0xe7
   \   000067 C7 50C6      LD        L:0x50c6, A
    508              CLK->CKDIVR |= (uint8_t)((uint8_t)CLK_Prescaler & (uint8_t)CLK_CKDIVR_HSIDIV);
   \   00006A B6 ..        LD        A, S:?b8
   \   00006C A4 18        AND       A, #0x18
   \   00006E CA 50C6      OR        A, L:0x50c6
   \   000071 C7 50C6      LD        L:0x50c6, A
   \   000074 20 12        JRA       L:??CLK_SYSCLKConfig_2
    509            }
    510            else /* Bit7 = 1 means CPU divider */
    511            {
    512              CLK->CKDIVR &= (uint8_t)(~CLK_CKDIVR_CPUDIV);
   \                     ??CLK_SYSCLKConfig_1:
   \   000076 C6 50C6      LD        A, L:0x50c6
   \   000079 A4 F8        AND       A, #0xf8
   \   00007B C7 50C6      LD        L:0x50c6, A
    513              CLK->CKDIVR |= (uint8_t)((uint8_t)CLK_Prescaler & (uint8_t)CLK_CKDIVR_CPUDIV);
   \   00007E B6 ..        LD        A, S:?b8
   \   000080 A4 07        AND       A, #0x7
   \   000082 CA 50C6      OR        A, L:0x50c6
   \   000085 C7 50C6      LD        L:0x50c6, A
    514            }
    515          }
   \                     ??CLK_SYSCLKConfig_2:
   \   000088 32 ....      POP       S:?b8
   \   00008B 87           RETF
    516          
    517          /**
    518            * @brief  Configures the SWIM clock frequency on the fly.
    519            * @param   CLK_SWIMDivider Specifies the SWIM clock divider to apply.
    520            * can be one of the value of @ref CLK_SWIMDivider_TypeDef
    521            * @retval None
    522            */

   \                                 In section .far_func.text, align 1
    523          void CLK_SWIMConfig(CLK_SWIMDivider_TypeDef CLK_SWIMDivider)
    524          {
   \                     CLK_SWIMConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    525            /* check the parameters */
    526            assert_param(IS_CLK_SWIMDIVIDER_OK(CLK_SWIMDivider));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 15        JREQ      L:??CLK_SWIMConfig_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 0F        JREQ      L:??CLK_SWIMConfig_0
   \   00000F AE 020E      LDW       X, #0x20e
   \   000012 BF ..        LDW       S:?w1, X
   \   000014 5F           CLRW      X
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 AE ....      LDW       X, #?_0
   \   00001A 8D ......    CALLF     assert_failed
    527            
    528            if (CLK_SWIMDivider != CLK_SWIMDIVIDER_2)
   \                     ??CLK_SWIMConfig_0:
   \   00001E 3D ..        TNZ       S:?b8
   \   000020 27 06        JREQ      L:??CLK_SWIMConfig_1
    529            {
    530              /* SWIM clock is not divided by 2 */
    531              CLK->SWIMCCR |= CLK_SWIMCCR_SWIMDIV;
   \   000022 7210 50CD    BSET      L:0x50cd, #0x0
   \   000026 20 04        JRA       L:??CLK_SWIMConfig_2
    532            }
    533            else /* CLK_SWIMDivider == CLK_SWIMDIVIDER_2 */
    534            {
    535              /* SWIM clock is divided by 2 */
    536              CLK->SWIMCCR &= (uint8_t)(~CLK_SWIMCCR_SWIMDIV);
   \                     ??CLK_SWIMConfig_1:
   \   000028 7211 50CD    BRES      L:0x50cd, #0x0
    537            }
    538          }
   \                     ??CLK_SWIMConfig_2:
   \   00002C 32 ....      POP       S:?b8
   \   00002F 87           RETF
    539          
    540          /**
    541            * @brief  Enables the Clock Security System.
    542            * @par Full description:
    543            * once CSS is enabled it cannot be disabled until the next reset.
    544            * @param  None
    545            * @retval None
    546            */

   \                                 In section .far_func.text, align 1
    547          void CLK_ClockSecuritySystemEnable(void)
    548          {
    549            /* Set CSSEN bit */
    550            CLK->CSSR |= CLK_CSSR_CSSEN;
   \                     CLK_ClockSecuritySystemEnable:
   \   000000 7210 50C8    BSET      L:0x50c8, #0x0
    551          }
   \   000004 87           RETF
    552          
    553          /**
    554            * @brief  Returns the clock source used as system clock.
    555            * @param  None
    556            * @retval  Clock source used.
    557            * can be one of the values of @ref CLK_Source_TypeDef
    558            */

   \                                 In section .far_func.text, align 1
    559          CLK_Source_TypeDef CLK_GetSYSCLKSource(void)
    560          {
    561            return((CLK_Source_TypeDef)CLK->CMSR);
   \                     CLK_GetSYSCLKSource:
   \   000000 C6 50C3      LD        A, L:0x50c3
   \   000003 87           RETF
    562          }
    563          
    564          /**
    565            * @brief  This function returns the frequencies of different on chip clocks.
    566            * @param  None
    567            * @retval the master clock frequency
    568            */

   \                                 In section .far_func.text, align 1
    569          uint32_t CLK_GetClockFreq(void)
    570          {
   \                     CLK_GetClockFreq:
   \   000000 8D ......    CALLF     L:?push_l3
   \   000004 8D ......    CALLF     L:?push_w4
   \   000008 3B ....      PUSH      S:?b11
    571            uint32_t clockfrequency = 0;
   \   00000B 5F           CLRW      X
   \   00000C BF ..        LDW       S:?w7, X
   \   00000E BF ..        LDW       S:?w6, X
    572            CLK_Source_TypeDef clocksource = CLK_SOURCE_HSI;
   \   000010 35 E1 ....   MOV       S:?b9, #0xe1
    573            uint8_t tmp = 0, presc = 0;
   \   000014 3F ..        CLR       S:?b8
   \   000016 3F ..        CLR       S:?b11
    574            
    575            /* Get CLK source. */
    576            clocksource = (CLK_Source_TypeDef)CLK->CMSR;
   \   000018 C6 50C3      LD        A, L:0x50c3
   \   00001B B7 ..        LD        S:?b9, A
    577            
    578            if (clocksource == CLK_SOURCE_HSI)
   \   00001D B6 ..        LD        A, S:?b9
   \   00001F A1 E1        CP        A, #0xe1
   \   000021 26 2E        JRNE      L:??CLK_GetClockFreq_0
    579            {
    580              tmp = (uint8_t)(CLK->CKDIVR & CLK_CKDIVR_HSIDIV);
   \   000023 C6 50C6      LD        A, L:0x50c6
   \   000026 A4 18        AND       A, #0x18
   \   000028 B7 ..        LD        S:?b8, A
    581              tmp = (uint8_t)(tmp >> 3);
   \   00002A B6 ..        LD        A, S:?b8
   \   00002C 44           SRL       A
   \   00002D 44           SRL       A
   \   00002E 44           SRL       A
   \   00002F B7 ..        LD        S:?b8, A
    582              presc = HSIDivFactor[tmp];
   \   000031 5F           CLRW      X
   \   000032 B6 ..        LD        A, S:?b8
   \   000034 97           LD        XL, A
   \   000035 D6 ....      LD        A, (L:HSIDivFactor,X)
   \   000038 B7 ..        LD        S:?b11, A
    583              clockfrequency = HSI_VALUE / presc;
   \   00003A 5F           CLRW      X
   \   00003B B6 ..        LD        A, S:?b11
   \   00003D 97           LD        XL, A
   \   00003E BF ..        LDW       S:?w3, X
   \   000040 5F           CLRW      X
   \   000041 BF ..        LDW       S:?w2, X
   \   000043 8D ......    CALLF     L:?udiv32_l0_dl_l1
   \   000047 00F42400     DC32      0xf42400
   \   00004B 8D ......    CALLF     L:?mov_l3_l0
   \   00004F 20 23        JRA       L:??CLK_GetClockFreq_1
    584            }
    585            else if ( clocksource == CLK_SOURCE_LSI)
   \                     ??CLK_GetClockFreq_0:
   \   000051 B6 ..        LD        A, S:?b9
   \   000053 A1 D2        CP        A, #0xd2
   \   000055 26 0F        JRNE      L:??CLK_GetClockFreq_2
    586            {
    587              clockfrequency = LSI_VALUE;
   \   000057 AE F400      LDW       X, #0xf400
   \   00005A BF ..        LDW       S:?w1, X
   \   00005C 5F           CLRW      X
   \   00005D 5C           INCW      X
   \   00005E BF ..        LDW       S:?w0, X
   \   000060 8D ......    CALLF     L:?mov_l3_l0
   \   000064 20 0E        JRA       L:??CLK_GetClockFreq_1
    588            }
    589            else
    590            {
    591              clockfrequency = HSE_VALUE;
   \                     ??CLK_GetClockFreq_2:
   \   000066 AE 2400      LDW       X, #0x2400
   \   000069 BF ..        LDW       S:?w1, X
   \   00006B AE 00F4      LDW       X, #0xf4
   \   00006E BF ..        LDW       S:?w0, X
   \   000070 8D ......    CALLF     L:?mov_l3_l0
    592            }
    593            
    594            return((uint32_t)clockfrequency);
   \                     ??CLK_GetClockFreq_1:
   \   000074 8D ......    CALLF     L:?mov_l0_l3
   \   000078 32 ....      POP       S:?b11
   \   00007B 8D ......    CALLF     L:?pop_w4
   \   00007F 8D ......    CALLF     L:?pop_l3
   \   000083 87           RETF
    595          }
    596          
    597          /**
    598            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    599            * @par Full description:
    600            * @param   CLK_HSICalibrationValue calibration trimming value.
    601            * can be one of the values of @ref CLK_HSITrimValue_TypeDef
    602            * @retval None
    603            */

   \                                 In section .far_func.text, align 1
    604          void CLK_AdjustHSICalibrationValue(CLK_HSITrimValue_TypeDef CLK_HSICalibrationValue)
    605          {
   \                     CLK_AdjustHSICalibrationValue:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    606            /* check the parameters */
    607            assert_param(IS_CLK_HSITRIMVALUE_OK(CLK_HSICalibrationValue));
   \   000005 3D ..        TNZ       S:?b8
   \   000007 27 39        JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000009 B6 ..        LD        A, S:?b8
   \   00000B A1 01        CP        A, #0x1
   \   00000D 27 33        JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   00000F B6 ..        LD        A, S:?b8
   \   000011 A1 02        CP        A, #0x2
   \   000013 27 2D        JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 A1 03        CP        A, #0x3
   \   000019 27 27        JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   00001B B6 ..        LD        A, S:?b8
   \   00001D A1 04        CP        A, #0x4
   \   00001F 27 21        JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000021 B6 ..        LD        A, S:?b8
   \   000023 A1 05        CP        A, #0x5
   \   000025 27 1B        JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000027 B6 ..        LD        A, S:?b8
   \   000029 A1 06        CP        A, #0x6
   \   00002B 27 15        JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   00002D B6 ..        LD        A, S:?b8
   \   00002F A1 07        CP        A, #0x7
   \   000031 27 0F        JREQ      L:??CLK_AdjustHSICalibrationValue_0
   \   000033 AE 025F      LDW       X, #0x25f
   \   000036 BF ..        LDW       S:?w1, X
   \   000038 5F           CLRW      X
   \   000039 BF ..        LDW       S:?w0, X
   \   00003B AE ....      LDW       X, #?_0
   \   00003E 8D ......    CALLF     assert_failed
    608            
    609            /* Store the new value */
    610            CLK->HSITRIMR = (uint8_t)( (uint8_t)(CLK->HSITRIMR & (uint8_t)(~CLK_HSITRIMR_HSITRIM))|((uint8_t)CLK_HSICalibrationValue));
   \                     ??CLK_AdjustHSICalibrationValue_0:
   \   000042 C6 50CC      LD        A, L:0x50cc
   \   000045 A4 F8        AND       A, #0xf8
   \   000047 BA ..        OR        A, S:?b8
   \   000049 C7 50CC      LD        L:0x50cc, A
    611          }
   \   00004C 32 ....      POP       S:?b8
   \   00004F 87           RETF
    612          
    613          /**
    614            * @brief  Reset the SWBSY flag (SWICR Register)
    615            * @par Full description:
    616            * This function reset SWBSY flag in order to reset clock switch operations (target
    617            * oscillator is broken, stabilization is longing too much, etc.).  If at the same time \n
    618            * software attempts to set SWEN and clear SWBSY, SWBSY action takes precedence.
    619            * @param  None
    620            * @retval None
    621            */

   \                                 In section .far_func.text, align 1
    622          void CLK_SYSCLKEmergencyClear(void)
    623          {
    624            CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWBSY);
   \                     CLK_SYSCLKEmergencyClear:
   \   000000 7211 50C5    BRES      L:0x50c5, #0x0
    625          }
   \   000004 87           RETF
    626          
    627          /**
    628            * @brief  Checks whether the specified CLK flag is set or not.
    629            * @par Full description:
    630            * @param   CLK_FLAG Flag to check.
    631            * can be one of the values of @ref CLK_Flag_TypeDef
    632            * @retval FlagStatus, status of the checked flag
    633            */

   \                                 In section .far_func.text, align 1
    634          FlagStatus CLK_GetFlagStatus(CLK_Flag_TypeDef CLK_FLAG)
    635          {
   \                     CLK_GetFlagStatus:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 BF ..        LDW       S:?w4, X
    636            uint16_t statusreg = 0;
   \   00000A 3F ..        CLR       S:?b11
   \   00000C 3F ..        CLR       S:?b10
    637            uint8_t tmpreg = 0;
   \   00000E 3F ..        CLR       S:?b12
    638            FlagStatus bitstatus = RESET;
   \   000010 3F ..        CLR       S:?b13
    639            
    640            /* check the parameters */
    641            assert_param(IS_CLK_FLAG_OK(CLK_FLAG));
   \   000012 BE ..        LDW       X, S:?w4
   \   000014 A3 0110      CPW       X, #0x110
   \   000017 27 47        JREQ      L:??CLK_GetFlagStatus_0
   \   000019 BE ..        LDW       X, S:?w4
   \   00001B A3 0102      CPW       X, #0x102
   \   00001E 27 40        JREQ      L:??CLK_GetFlagStatus_0
   \   000020 BE ..        LDW       X, S:?w4
   \   000022 A3 0202      CPW       X, #0x202
   \   000025 27 39        JREQ      L:??CLK_GetFlagStatus_0
   \   000027 BE ..        LDW       X, S:?w4
   \   000029 A3 0308      CPW       X, #0x308
   \   00002C 27 32        JREQ      L:??CLK_GetFlagStatus_0
   \   00002E BE ..        LDW       X, S:?w4
   \   000030 A3 0301      CPW       X, #0x301
   \   000033 27 2B        JREQ      L:??CLK_GetFlagStatus_0
   \   000035 BE ..        LDW       X, S:?w4
   \   000037 A3 0408      CPW       X, #0x408
   \   00003A 27 24        JREQ      L:??CLK_GetFlagStatus_0
   \   00003C BE ..        LDW       X, S:?w4
   \   00003E A3 0402      CPW       X, #0x402
   \   000041 27 1D        JREQ      L:??CLK_GetFlagStatus_0
   \   000043 BE ..        LDW       X, S:?w4
   \   000045 A3 0504      CPW       X, #0x504
   \   000048 27 16        JREQ      L:??CLK_GetFlagStatus_0
   \   00004A BE ..        LDW       X, S:?w4
   \   00004C A3 0502      CPW       X, #0x502
   \   00004F 27 0F        JREQ      L:??CLK_GetFlagStatus_0
   \   000051 AE 0281      LDW       X, #0x281
   \   000054 BF ..        LDW       S:?w1, X
   \   000056 5F           CLRW      X
   \   000057 BF ..        LDW       S:?w0, X
   \   000059 AE ....      LDW       X, #?_0
   \   00005C 8D ......    CALLF     assert_failed
    642            
    643            /* Get the CLK register index */
    644            statusreg = (uint16_t)((uint16_t)CLK_FLAG & (uint16_t)0xFF00);
   \                     ??CLK_GetFlagStatus_0:
   \   000060 BE ..        LDW       X, S:?w4
   \   000062 02           RLWA      X, A
   \   000063 A4 FF        AND       A, #0xff
   \   000065 02           RLWA      X, A
   \   000066 A4 00        AND       A, #0x0
   \   000068 02           RLWA      X, A
   \   000069 BF ..        LDW       S:?w5, X
    645            
    646            
    647            if (statusreg == 0x0100) /* The flag to check is in ICKRregister */
   \   00006B BE ..        LDW       X, S:?w5
   \   00006D A3 0100      CPW       X, #0x100
   \   000070 26 07        JRNE      L:??CLK_GetFlagStatus_1
    648            {
    649              tmpreg = CLK->ICKR;
   \   000072 C6 50C0      LD        A, L:0x50c0
   \   000075 B7 ..        LD        S:?b12, A
   \   000077 20 2F        JRA       L:??CLK_GetFlagStatus_2
    650            }
    651            else if (statusreg == 0x0200) /* The flag to check is in ECKRregister */
   \                     ??CLK_GetFlagStatus_1:
   \   000079 BE ..        LDW       X, S:?w5
   \   00007B A3 0200      CPW       X, #0x200
   \   00007E 26 07        JRNE      L:??CLK_GetFlagStatus_3
    652            {
    653              tmpreg = CLK->ECKR;
   \   000080 C6 50C1      LD        A, L:0x50c1
   \   000083 B7 ..        LD        S:?b12, A
   \   000085 20 21        JRA       L:??CLK_GetFlagStatus_2
    654            }
    655            else if (statusreg == 0x0300) /* The flag to check is in SWIC register */
   \                     ??CLK_GetFlagStatus_3:
   \   000087 BE ..        LDW       X, S:?w5
   \   000089 A3 0300      CPW       X, #0x300
   \   00008C 26 07        JRNE      L:??CLK_GetFlagStatus_4
    656            {
    657              tmpreg = CLK->SWCR;
   \   00008E C6 50C5      LD        A, L:0x50c5
   \   000091 B7 ..        LD        S:?b12, A
   \   000093 20 13        JRA       L:??CLK_GetFlagStatus_2
    658            }
    659            else if (statusreg == 0x0400) /* The flag to check is in CSS register */
   \                     ??CLK_GetFlagStatus_4:
   \   000095 BE ..        LDW       X, S:?w5
   \   000097 A3 0400      CPW       X, #0x400
   \   00009A 26 07        JRNE      L:??CLK_GetFlagStatus_5
    660            {
    661              tmpreg = CLK->CSSR;
   \   00009C C6 50C8      LD        A, L:0x50c8
   \   00009F B7 ..        LD        S:?b12, A
   \   0000A1 20 05        JRA       L:??CLK_GetFlagStatus_2
    662            }
    663            else /* The flag to check is in CCO register */
    664            {
    665              tmpreg = CLK->CCOR;
   \                     ??CLK_GetFlagStatus_5:
   \   0000A3 C6 50C9      LD        A, L:0x50c9
   \   0000A6 B7 ..        LD        S:?b12, A
    666            }
    667            
    668            if ((tmpreg & (uint8_t)CLK_FLAG) != (uint8_t)RESET)
   \                     ??CLK_GetFlagStatus_2:
   \   0000A8 B6 ..        LD        A, S:?b9
   \   0000AA B4 ..        AND       A, S:?b12
   \   0000AC A1 00        CP        A, #0x0
   \   0000AE 27 06        JREQ      L:??CLK_GetFlagStatus_6
    669            {
    670              bitstatus = SET;
   \   0000B0 A6 01        LD        A, #0x1
   \   0000B2 B7 ..        LD        S:?b13, A
   \   0000B4 20 02        JRA       L:??CLK_GetFlagStatus_7
    671            }
    672            else
    673            {
    674              bitstatus = RESET;
   \                     ??CLK_GetFlagStatus_6:
   \   0000B6 3F ..        CLR       S:?b13
    675            }
    676            
    677            /* Return the flag status */
    678            return((FlagStatus)bitstatus);
   \                     ??CLK_GetFlagStatus_7:
   \   0000B8 B6 ..        LD        A, S:?b13
   \   0000BA AC ......    JPF       L:?epilogue_l2_w6
    679          }
    680          
    681          /**
    682            * @brief  Checks whether the specified CLK interrupt has is enabled or not.
    683            * @param   CLK_IT specifies the CLK interrupt.
    684            * can be one of the values of @ref CLK_IT_TypeDef
    685            * @retval ITStatus, new state of CLK_IT (SET or RESET).
    686            */

   \                                 In section .far_func.text, align 1
    687          ITStatus CLK_GetITStatus(CLK_IT_TypeDef CLK_IT)
    688          {
   \                     CLK_GetITStatus:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b9, A
    689            ITStatus bitstatus = RESET;
   \   000006 3F ..        CLR       S:?b8
    690            
    691            /* check the parameters */
    692            assert_param(IS_CLK_IT_OK(CLK_IT));
   \   000008 B6 ..        LD        A, S:?b9
   \   00000A A1 0C        CP        A, #0xc
   \   00000C 27 15        JREQ      L:??CLK_GetITStatus_0
   \   00000E B6 ..        LD        A, S:?b9
   \   000010 A1 1C        CP        A, #0x1c
   \   000012 27 0F        JREQ      L:??CLK_GetITStatus_0
   \   000014 AE 02B4      LDW       X, #0x2b4
   \   000017 BF ..        LDW       S:?w1, X
   \   000019 5F           CLRW      X
   \   00001A BF ..        LDW       S:?w0, X
   \   00001C AE ....      LDW       X, #?_0
   \   00001F 8D ......    CALLF     assert_failed
    693            
    694            if (CLK_IT == CLK_IT_SWIF)
   \                     ??CLK_GetITStatus_0:
   \   000023 B6 ..        LD        A, S:?b9
   \   000025 A1 1C        CP        A, #0x1c
   \   000027 26 13        JRNE      L:??CLK_GetITStatus_1
    695            {
    696              /* Check the status of the clock switch interrupt */
    697              if ((CLK->SWCR & (uint8_t)CLK_IT) == (uint8_t)0x0C)
   \   000029 C6 50C5      LD        A, L:0x50c5
   \   00002C B4 ..        AND       A, S:?b9
   \   00002E A1 0C        CP        A, #0xc
   \   000030 26 06        JRNE      L:??CLK_GetITStatus_2
    698              {
    699                bitstatus = SET;
   \   000032 A6 01        LD        A, #0x1
   \   000034 B7 ..        LD        S:?b8, A
   \   000036 20 15        JRA       L:??CLK_GetITStatus_3
    700              }
    701              else
    702              {
    703                bitstatus = RESET;
   \                     ??CLK_GetITStatus_2:
   \   000038 3F ..        CLR       S:?b8
   \   00003A 20 11        JRA       L:??CLK_GetITStatus_3
    704              }
    705            }
    706            else /* CLK_IT == CLK_IT_CSSDIE */
    707            {
    708              /* Check the status of the security system detection interrupt */
    709              if ((CLK->CSSR & (uint8_t)CLK_IT) == (uint8_t)0x0C)
   \                     ??CLK_GetITStatus_1:
   \   00003C C6 50C8      LD        A, L:0x50c8
   \   00003F B4 ..        AND       A, S:?b9
   \   000041 A1 0C        CP        A, #0xc
   \   000043 26 06        JRNE      L:??CLK_GetITStatus_4
    710              {
    711                bitstatus = SET;
   \   000045 A6 01        LD        A, #0x1
   \   000047 B7 ..        LD        S:?b8, A
   \   000049 20 02        JRA       L:??CLK_GetITStatus_3
    712              }
    713              else
    714              {
    715                bitstatus = RESET;
   \                     ??CLK_GetITStatus_4:
   \   00004B 3F ..        CLR       S:?b8
    716              }
    717            }
    718            
    719            /* Return the CLK_IT status */
    720            return bitstatus;
   \                     ??CLK_GetITStatus_3:
   \   00004D B6 ..        LD        A, S:?b8
   \   00004F AC ......    JPF       L:?epilogue_w4
    721          }
    722          
    723          /**
    724            * @brief  Clears the CLKs interrupt pending bits.
    725            * @param   CLK_IT specifies the interrupt pending bits.
    726            * can be one of the values of @ref CLK_IT_TypeDef
    727            * @retval None
    728            */

   \                                 In section .far_func.text, align 1
    729          void CLK_ClearITPendingBit(CLK_IT_TypeDef CLK_IT)
    730          {
   \                     CLK_ClearITPendingBit:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    731            /* check the parameters */
    732            assert_param(IS_CLK_IT_OK(CLK_IT));
   \   000005 B6 ..        LD        A, S:?b8
   \   000007 A1 0C        CP        A, #0xc
   \   000009 27 15        JREQ      L:??CLK_ClearITPendingBit_0
   \   00000B B6 ..        LD        A, S:?b8
   \   00000D A1 1C        CP        A, #0x1c
   \   00000F 27 0F        JREQ      L:??CLK_ClearITPendingBit_0
   \   000011 AE 02DC      LDW       X, #0x2dc
   \   000014 BF ..        LDW       S:?w1, X
   \   000016 5F           CLRW      X
   \   000017 BF ..        LDW       S:?w0, X
   \   000019 AE ....      LDW       X, #?_0
   \   00001C 8D ......    CALLF     assert_failed
    733            
    734            if (CLK_IT == (uint8_t)CLK_IT_CSSD)
   \                     ??CLK_ClearITPendingBit_0:
   \   000020 B6 ..        LD        A, S:?b8
   \   000022 A1 0C        CP        A, #0xc
   \   000024 26 06        JRNE      L:??CLK_ClearITPendingBit_1
    735            {
    736              /* Clear the status of the security system detection interrupt */
    737              CLK->CSSR &= (uint8_t)(~CLK_CSSR_CSSD);
   \   000026 7217 50C8    BRES      L:0x50c8, #0x3
   \   00002A 20 04        JRA       L:??CLK_ClearITPendingBit_2
    738            }
    739            else /* CLK_PendingBit == (uint8_t)CLK_IT_SWIF */
    740            {
    741              /* Clear the status of the clock switch interrupt */
    742              CLK->SWCR &= (uint8_t)(~CLK_SWCR_SWIF);
   \                     ??CLK_ClearITPendingBit_1:
   \   00002C 7217 50C5    BRES      L:0x50c5, #0x3
    743            }
    744            
    745          }
   \                     ??CLK_ClearITPendingBit_2:
   \   000030 32 ....      POP       S:?b8
   \   000033 87           RETF

   \                                 In section .near.rodata, align 1
   \                     ?_0:
   \   000000 2E 5C 4C 69  DC8 ".\\Lib\\C\\stm8s_clk.c"
   \          62 5C 43 5C 
    746          
    747          /**
    748            * @}
    749            */
    750            
    751          /**
    752            * @}
    753            */
    754            
    755          
    756          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?_0
       8  CLKPrescTable
      80  CLK_AdjustHSICalibrationValue
      48  CLK_CCOCmd
     120  CLK_CCOConfig
      52  CLK_ClearITPendingBit
       5  CLK_ClockSecuritySystemEnable
      48  CLK_ClockSwitchCmd
     308  CLK_ClockSwitchConfig
      54  CLK_DeInit
      48  CLK_FastHaltWakeUpCmd
     132  CLK_GetClockFreq
     190  CLK_GetFlagStatus
      83  CLK_GetITStatus
       4  CLK_GetSYSCLKSource
      48  CLK_HSECmd
      48  CLK_HSICmd
      62  CLK_HSIPrescalerConfig
     119  CLK_ITConfig
      48  CLK_LSICmd
     227  CLK_PeripheralClockConfig
      48  CLK_SWIMConfig
     140  CLK_SYSCLKConfig
       5  CLK_SYSCLKEmergencyClear
      48  CLK_SlowActiveHaltWakeUpCmd
       4  HSIDivFactor

 
 1 965 bytes in section .far_func.text
    32 bytes in section .near.rodata
 
 1 965 bytes of CODE  memory
    32 bytes of CONST memory

Errors: none
Warnings: none
